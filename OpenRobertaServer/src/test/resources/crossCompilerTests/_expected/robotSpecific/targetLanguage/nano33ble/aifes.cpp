// This file is automatically generated by the Open Roberta Lab.

#define _ARDUINO_STL_NOT_NEEDED
#include <Arduino.h>

#include <Arduino_LSM9DS1.h>
#include <aifes.h>
#include <Arduino_HTS221.h>
#include <Arduino_LPS22HB.h>
#include <Arduino_APDS9960.h>
#include <NEPODefs.h>

void ____checkClassification(bool ___expectSmall);


double ___error;
std::list<double> ___outputs;
bool ___success;
double ___output;
float xAsFloat, yAsFloat, zAsFloat;
uint32_t global_epoch_counter = 0; 
uint32_t FNN_structure[3] = {2,3,1}; 
AIFES_E_activations FNN_activations[2];
uint32_t weight_number = AIFES_E_flat_weights_number_fnn_f32(FNN_structure,3);
float *FlatWeights;
AIFES_E_model_parameter_fnn_f32 FNN;
uint32_t i;
AIFES_E_init_weights_parameter_fnn_f32  FNN_INIT_WEIGHTS;
AIFES_E_training_parameter_fnn_f32  FNN_TRAIN;

void printLoss(float loss) {
    global_epoch_counter++;
}
 
float input_data[4][2];
float target_data[4][1];
float classify_data[2];
int8_t errorInference = 0;
int8_t targetSet = 0;
int8_t targetData = 0;
int8_t trainingSet = 0;
int8_t trainingData = 0;
int8_t currentClassifySet = 0;
uint16_t input_shape[] = {4, (uint16_t)FNN_structure[0]};
aitensor_t input_tensor = AITENSOR_2D_F32(input_shape, input_data);
uint16_t target_shape[] = {4, (uint16_t)FNN_structure[2]};
aitensor_t target_tensor = AITENSOR_2D_F32(target_shape, target_data);
float output_train_data[4];
uint16_t output_train_shape[] = {4, (uint16_t)FNN_structure[2]};
aitensor_t output_train_tensor = AITENSOR_2D_F32(output_train_shape, output_train_data);
uint16_t classify_shape[] = {1, (uint16_t)FNN_structure[0]};
aitensor_t classify_tensor = AITENSOR_2D_F32(classify_shape, classify_data);
float output_classify_data[1];
uint16_t output_classify_shape[] = {1, (uint16_t)FNN_structure[2]};
aitensor_t output_classify_tensor = AITENSOR_2D_F32(output_classify_shape, output_classify_data);

void addInputData(float data) {
     input_data[trainingSet][trainingData] = data;
     if ((trainingSet >= 3) && (trainingData >= 1 )) {
          trainingSet = 0;
          trainingData = 0;
     } else if ((trainingSet < 3) && (trainingData >= 1)){
          trainingSet = trainingSet + 1;
          trainingData = 0;
     } else if (trainingData < 1) {
          trainingData = trainingData + 1;
     }
}

void addTargetData(float data) {
     target_data[targetSet][targetData] = data;
     if ((targetSet >= 3) && (targetData >= 0)) {
          targetSet = 0;
          targetData = 0;
     } else if ((targetSet < 3) && (targetData >= 0)){
          targetSet = targetSet + 1;
          targetData = 0;
     } else if (targetData < 0) {
          targetData = targetData + 1;
     }
}

void addClassifyData(float data) {
     classify_data[currentClassifySet] = data;
     if (currentClassifySet >= 1) {
          currentClassifySet = 0;
     } else if (currentClassifySet < 1) {
          currentClassifySet = currentClassifySet + 1;
     }
}
int _led_L = LED_BUILTIN;
int rAsInt, gAsInt, bAsInt;

void ____checkClassification(bool ___expectSmall) {
    if ( ___error != 0 ) {
        Serial.println("Error in classify");
        Serial.println(___error);
        ___success = false;
    }
    ___output = _getListElementByIndex(___outputs, 0);
    if ( ___expectSmall ) {
        if ( ___output > 0.2 ) {
            Serial.println("LT-Error in output");
            Serial.println(___output);
            ___success = false;
        }
    } else {
        if ( ___output < 0.8 ) {
            Serial.println("GT-Error in output");
            Serial.println(___output);
            ___success = false;
        }
    }
}

void setup()
{
    Serial.begin(9600);
    IMU.begin();
    FNN_activations[0] = AIfES_E_sigmoid;
    FNN_activations[1] = AIfES_E_sigmoid;
    FNN.layer_count = 3;
    FNN.fnn_structure = FNN_structure;
    FNN.fnn_activations = FNN_activations;
    FlatWeights = (float *)malloc(sizeof(float)*weight_number);
    FNN.flat_weights = FlatWeights;
    FNN_INIT_WEIGHTS.init_weights_method = AIfES_E_init_uniform;
    FNN_INIT_WEIGHTS.min_init_uniform = -2;
    FNN_INIT_WEIGHTS.max_init_uniform = 2;
    FNN_TRAIN.optimizer = AIfES_E_adam;
    FNN_TRAIN.learn_rate = 0.5f;
    FNN_TRAIN.sgd_momentum = 0.0;
    FNN_TRAIN.batch_size = 4;
    FNN_TRAIN.epochs = 1000;
    FNN_TRAIN.epochs_loss_print_interval = 10;
    FNN_TRAIN.early_stopping = AIfES_E_early_stopping_on;
    FNN_TRAIN.early_stopping_target_loss = 0.004;
    FNN_TRAIN.loss_print_function = printLoss;
    HTS.begin();
    pinMode(_led_L, OUTPUT);
    BARO.begin();
    APDS.begin();
    ___error = 0;
    ___outputs = {0};
    ___success = true;
    ___output = 0;
}

void loop()
{
    ___success = true;
    Serial.println("START");
    trainingData = 0;
    trainingSet = 0;
    targetData = 0;
    targetSet = 0;
    currentClassifySet = 0;

    for (int i = 0; i < 4; i++){
        for (int j = 0; j < 2; j++) {
            input_data[i][j] = 0.0;
        }
     }

    for (int i = 0; i < 4; i++){
        for (int j = 0; j < 1; j++) {
            target_data[i][j] = 0.0;
        }
     }
    addInputData(0);
    addInputData(0);
    addTargetData(0);
    addInputData(0);
    addInputData(1);
    addTargetData(1);
    addInputData(1);
    addInputData(0);
    addTargetData(1);
    addInputData(1);
    addInputData(1);
    addTargetData(0);
    ___error = AIFES_E_training_fnn_f32(&input_tensor,&target_tensor,&FNN,&FNN_TRAIN,&FNN_INIT_WEIGHTS,&output_train_tensor);
    if ( ___error != 0 ) {
        Serial.println("Error in train");
        Serial.println(___error);
        ___success = false;
    } else {
        
    for (int i = 0; i < 2; i++) {
        classify_data[i] = 0.0;
    }
        addClassifyData(0);
        addClassifyData(0);
        ___error = (errorInference = AIFES_E_inference_fnn_f32(&classify_tensor,&FNN,&output_classify_tensor)==0?(___outputs.assign(output_classify_data, output_classify_data + ___outputs.size()),0):errorInference);
        ____checkClassification(true);
        
    for (int i = 0; i < 2; i++) {
        classify_data[i] = 0.0;
    }
        addClassifyData(0);
        addClassifyData(1);
        ___error = (errorInference = AIFES_E_inference_fnn_f32(&classify_tensor,&FNN,&output_classify_tensor)==0?(___outputs.assign(output_classify_data, output_classify_data + ___outputs.size()),0):errorInference);
        ____checkClassification(false);
        
    for (int i = 0; i < 2; i++) {
        classify_data[i] = 0.0;
    }
        addClassifyData(1);
        addClassifyData(0);
        ___error = (errorInference = AIFES_E_inference_fnn_f32(&classify_tensor,&FNN,&output_classify_tensor)==0?(___outputs.assign(output_classify_data, output_classify_data + ___outputs.size()),0):errorInference);
        ____checkClassification(false);
        
    for (int i = 0; i < 2; i++) {
        classify_data[i] = 0.0;
    }
        addClassifyData(1);
        addClassifyData(1);
        ___error = (errorInference = AIFES_E_inference_fnn_f32(&classify_tensor,&FNN,&output_classify_tensor)==0?(___outputs.assign(output_classify_data, output_classify_data + ___outputs.size()),0):errorInference);
        ____checkClassification(true);
        if ( ___success ) {
            Serial.println("SUCCESS");
        } else {
            Serial.println("AT LEAST ONE ERROR");
        }
        delay(10000);
    }
}
