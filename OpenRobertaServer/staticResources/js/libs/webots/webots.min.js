define(['exports'],(function(exports){'use strict';function requestFullscreen(view) {
  const elem = view.view3D;
  if (typeof elem.requestFullscreen !== 'undefined')
    elem.requestFullscreen();
  else if (typeof elem.msRequestFullscreen !== 'undefined')
    elem.msRequestFullscreen();
  else if (typeof elem.mozRequestFullScreen !== 'undefined')
    elem.mozRequestFullScreen();
  else if (typeof elem.webkitRequestFullscreen !== 'undefined')
    elem.webkitRequestFullscreen();
}

function exitFullscreen() {
  if (typeof document.exitFullscreen !== 'undefined')
    document.exitFullscreen();
  else if (typeof document.msExitFullscreen !== 'undefined')
    document.msExitFullscreen();
  else if (typeof document.mozCancelFullScreen !== 'undefined')
    document.mozCancelFullScreen();
  else if (typeof document.webkitExitFullscreen !== 'undefined')
    document.webkitExitFullscreen();
}

function onFullscreenChange(fullscreenButton, exitFullscreenButton) {
  const element = document.fullScreenElement || document.mozFullScreenElement || document.webkitFullScreenElement || document.msFullScreenElement || document.webkitCurrentFullScreenElement;
  if (element != null) {
    fullscreenButton.style.display = 'none';
    exitFullscreenButton.style.display = 'inline';
  } else {
    fullscreenButton.style.display = 'inline';
    exitFullscreenButton.style.display = 'none';
  }
}const template = document.createElement('template');

template.innerHTML = `
<link rel="stylesheet" href="https://cyberbotics.com/wwi/R2021b/css/animation_slider.css">

<div class="range" id="range">
  <div class="slider" id="slider">
    <div class="thumb" id="thumb"></div>
</div>
<span class="floating-time" id="floating-time">00:<small>00</small></span>
`;

// The name of this web component have to be "animation-slider"
class AnimationSlider extends HTMLElement {
  constructor() {
    super();
    this._shadowRoot = this.attachShadow({ mode: 'open' });
    this._shadowRoot.appendChild(template.content.cloneNode(true));

    this._shadowRoot.getElementById('range').addEventListener('mousedown', _ => this._mouseDown(_));
    document.addEventListener('mousemove', _ => this._mouseMove(_));
    document.addEventListener('mouseup', () => this._mouseUp());

    this._offset = 0; // use to center the floating time correctly
    this._isSelected = false;
  }

  _mouseDown(e) {
    let bounds = document.querySelector('animation-slider').shadowRoot.getElementById('range').getBoundingClientRect();
    let x = (e.clientX - bounds.left) / (bounds.right - bounds.left) * 100;
    document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.width = x + '%';

    let event = new Event('slider_input', {
      bubbles: true,
      cancelable: true
    });

    event.detail = x;
    document.dispatchEvent(event);

    this._isSelected = true;
    document.querySelector('animation-slider').shadowRoot.getElementById('thumb').style.visibility = 'visible';
    document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.height = '5px';
    document.querySelector('animation-slider').shadowRoot.getElementById('range').style.height = '5px';
  }

  _mouseUp() {
    if (this._isSelected) {
      let event = new Event('slider_input', {
        bubbles: true,
        cancelable: true
      });

      event.mouseup = true;
      document.dispatchEvent(event);

      this._isSelected = false;
      document.querySelector('animation-slider').shadowRoot.getElementById('thumb').style.visibility = '';
      document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.height = '';
      document.querySelector('animation-slider').shadowRoot.getElementById('range').style.height = '';
      document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').style.visibility = '';
    }
  }

  _mouseMove(e) {
    if (this._isSelected) {
      let bounds = document.querySelector('animation-slider').shadowRoot.getElementById('range').getBoundingClientRect();
      let x = (e.clientX - bounds.left) / (bounds.right - bounds.left) * 100;
      if (x > 100)
        x = 100;
      else if (x < 0)
        x = 0;

      document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.width = x + '%';

      this.setFloatingTimePosition(e.clientX);

      let event = new Event('slider_input', {
        bubbles: true,
        cancelable: true
      });

      event.detail = x;
      document.dispatchEvent(event);
    }
  }

  value() {
    return document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.width;
  }

  setValue(percentage) {
    document.querySelector('animation-slider').shadowRoot.getElementById('slider').style.width = percentage + '%';
  }

  setTime(time) {
    document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').innerHTML = time;
    document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').style.visibility = 'visible';
  }

  setFloatingTimePosition(position) {
    let bounds = document.querySelector('animation-slider').shadowRoot.getElementById('range').getBoundingClientRect();
    let x = (position - bounds.left);
    if (x - this._offset < bounds.left)
      x = bounds.left + this._offset;
    else if (x + this._offset + 20 > bounds.right)
      x = bounds.right - this._offset - 20;
    document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').style.left = x - this._offset + 'px';
  }

  setOffset(offset) {
    this._offset = offset;
  }

  selected() {
    return this._isSelected;
  }
}class WbWorld {
  constructor() {
    this.hasFog = false;
    this.coordinateSystem = 'ENU';
    this.upVector = glm.vec3(0, 0, 1);
    // Only the top level nodes are represented here
    this.sceneTree = [];
    // All the nodes are included here so it is easier to retrieve them for updates
    // map from id to node
    this.nodes = new Map();

    this.billboards = [];
    this.readyForUpdates = false;
  }

  static init() {
    WbWorld.instance = new WbWorld();
  }

  static computeUpVector() {
    WbWorld.instance.upVector = glm.vec3(WbWorld.instance.coordinateSystem[0] === 'U' ? 1 : 0, WbWorld.instance.coordinateSystem[1] === 'U' ? 1 : 0, WbWorld.instance.coordinateSystem[2] === 'U' ? 1 : 0);
  }
}let GtaoLevel = 4; // [0 - 4], 0 disable it
let disableShadows = false;
const textureQuality = 2; // [0 - 2]
const textureFiltering = 5; // [0 - 5]

function changeShadows() {
  disableShadows = !disableShadows;
  _wr_config_enable_shadows(!disableShadows);
}

function changeGtaoLevel(level) {
  GtaoLevel = level;
}class Animation {
  constructor(url, scene, view, gui, loop) {
    this._url = url;
    this._scene = scene;
    this._view = view;
    this._gui = typeof gui === 'undefined' || gui === 'play' ? 'real_time' : 'pause';
    this._loop = typeof loop === 'undefined' ? true : loop;
    this._speed = 1;
  };

  init(onReady) {
    this._onReady = onReady;
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open('GET', this._url, true);
    xmlhttp.overrideMimeType('application/json');
    xmlhttp.onreadystatechange = () => {
      if (xmlhttp.readyState === 4 && (xmlhttp.status === 200 || xmlhttp.status === 0))
        this._setup(JSON.parse(xmlhttp.responseText));
    };
    xmlhttp.send();
  }

  // private methods
  _setup(data) {
    this._data = data;
    // extract animated node ids: remove empty items and convert to integer
    this._allIds = this._data.ids.split(';').filter(Boolean).map(s => parseInt(s));
    this._labelsIds = typeof this._data.labelsIds === 'undefined' ? [] : this._data.labelsIds.split(';').filter(Boolean).map(s => parseInt(s));

    this._createPlayBar();
    this._createSlider();
    this._createPlayButton();
    this._createTimeIndicator();
    this._createSettings();
    this._createFullscreenButton();

    document.addEventListener('keydown', _ => this._keyboardHandler(_));
    // Initialize animation data.
    this._start = new Date().getTime();
    this._step = 0;
    this._previousStep = 0;
    this._updateAnimation();

    // Notify creation completed.
    if (typeof this._onReady === 'function')
      this._onReady();
  }

  _elapsedTime() {
    const end = new Date().getTime();
    return end - this._start;
  }

  _triggerPlayPauseButton() {
    if (this._gui === 'real_time') {
      this._gui = 'pause';
      if (this._step < 0 || this._step >= this._data.frames.length) {
        this._start = new Date().getTime();
        this._updateAnimationState();
      } else
        this._start = new Date().getTime() - this._data.basicTimeStep * this._step;
    } else {
      this._gui = 'real_time';
      this._start = new Date().getTime() - this._data.basicTimeStep * this._step / this._speed;
      window.requestAnimationFrame(() => this._updateAnimation());
    }
    const action = (this._gui === 'real_time') ? 'pause' : 'play';
    document.getElementById('play-tooltip').innerHTML = 'P' + action.substring(1) + ' (k)';
    document.getElementById('play-button').className = 'player-btn icon-' + action;
  }

  _updateSlider(event) {
    if (event.mouseup) {
      if (this._previousState === 'real_time' && this._gui === 'pause') {
        this._previousState = undefined;
        this._triggerPlayPauseButton();
      } else {
        // Fix gtao "ghost" when modifying manually the position on the slidebar
        for (let x = 0; x < 5; x++)
          this._scene.renderer.render();
      }
      return;
    }

    const value = event.detail;

    if (this._gui === 'real_time') {
      this._previousState = 'real_time';
      this._triggerPlayPauseButton();
    }

    const clampedValued = Math.min(value, 99); // set maximum value to get valid step index
    const requestedStep = Math.floor(this._data.frames.length * clampedValued / 100);
    this._start = (new Date().getTime()) - Math.floor(this._data.basicTimeStep * this._step);
    this._updateAnimationState(requestedStep);

    document.getElementById('time-slider').setTime(this._formatTime(this._data.frames[requestedStep].time));
  }

  _updateAnimationState(requestedStep = undefined) {
    const automaticMove = typeof requestedStep === 'undefined';
    if (automaticMove) {
      requestedStep = Math.floor(this._elapsedTime() * this._speed / this._data.basicTimeStep);
      if (requestedStep < 0 || requestedStep >= this._data.frames.length) {
        if (this._loop) {
          if (requestedStep > this._data.frames.length) {
            requestedStep = 0;
            this._previousStep = 0;
            this._start = new Date().getTime();
          } else
            return;
        } else if (this._gui === 'real_time') {
          this._triggerPlayPauseButton();
          return;
        } else
          return;
      }
    }
    if (requestedStep !== this._step) {
      this._step = requestedStep;

      const appliedIds = [];
      const appliedLabelsIds = [];

      if (this._data.frames[this._step].hasOwnProperty('poses')) {
        const poses = this._data.frames[this._step].poses;
        for (let p = 0; p < poses.length; p++)
          appliedIds[poses[p].id] = this._scene.applyPose(poses[p], undefined, automaticMove);
      }

      if (this._data.frames[this._step].hasOwnProperty('labels')) {
        const labels = this._data.frames[this._step].labels;
        for (let i = 0; i < labels.length; i++) {
          this._scene.applyLabel(labels[i], this._view);
          appliedLabelsIds.push(labels[i].id);
        }
      }

      // lookback mechanism: search in history
      if (this._step !== this._previousStep + 1) {
        let previousPoseStep;
        if (this._step > this._previousStep)
          // in forward animation check only the changes since last pose
          previousPoseStep = this._previousStep;
        else
          previousPoseStep = 0;
        for (let i in this._allIds) {
          const id = this._allIds[i];
          let appliedFields = appliedIds[id];
          for (let f = this._step - 1; f >= previousPoseStep; f--) {
            if (this._data.frames[f].poses) {
              for (let p = 0; p < this._data.frames[f].poses.length; p++) {
                if (this._data.frames[f].poses[p].id === id)
                  appliedFields = this._scene.applyPose(this._data.frames[f].poses[p], appliedFields, automaticMove);
              }
            }
          }
        }

        for (let id of this._labelsIds) {
          for (let f = this._step - 1; f >= previousPoseStep; f--) {
            if (this._data.frames[f].labels) {
              for (let p = 0; p < this._data.frames[f].labels.length; p++) {
                if (this._data.frames[f].labels[p].id === id) {
                  if (!appliedLabelsIds.includes(id)) {
                    this._scene.applyLabel(this._data.frames[f].labels[p], this._view);
                    appliedLabelsIds.push(id);
                  }
                }
              }
            }
          }
        }
      }

      if (automaticMove)
        document.getElementById('time-slider').setValue(100 * this._step / this._data.frames.length);

      this._previousStep = this._step;
      this._view.time = this._data.frames[this._step].time;
      this._currentTime.innerHTML = this._formatTime(this._view.time);
      WbWorld.instance.viewpoint.updateFollowUp(this._view.time, !automaticMove || this.step === 0);
      this._scene.render();
    }
  }

  _updateAnimation() {
    if (this._gui === 'real_time')
      this._updateAnimationState();

    window.requestAnimationFrame(() => this._updateAnimation());
  }

  _parseMillisecondsIntoReadableTime(milliseconds) {
    const hours = (milliseconds + 0.9) / (1000 * 60 * 60);
    const absoluteHours = Math.floor(hours);
    const h = absoluteHours > 9 ? absoluteHours : '0' + absoluteHours;
    const minutes = (hours - absoluteHours) * 60;
    const absoluteMinutes = Math.floor(minutes);
    const m = absoluteMinutes > 9 ? absoluteMinutes : '0' + absoluteMinutes;
    const seconds = (minutes - absoluteMinutes) * 60;
    const absoluteSeconds = Math.floor(seconds);
    const s = absoluteSeconds > 9 ? absoluteSeconds : '0' + absoluteSeconds;
    let ms = Math.floor((seconds - absoluteSeconds) * 1000);
    if (ms < 10)
      ms = '00' + ms;
    else if (ms < 100)
      ms = '0' + ms;
    return h + ':' + m + ':' + s + ':<small>' + ms + '<small>';
  };

  _formatTime(time) {
    if (typeof this._unusedPrefix === 'undefined') {
      const maxTime = this._data.frames[this._data.frames.length - 1].time;
      if (maxTime < 60000)
        this._unusedPrefix = 6;
      else if (maxTime < 600000)
        this._unusedPrefix = 4;
      else if (maxTime < 3600000)
        this._unusedPrefix = 3;
      else if (maxTime < 36000000)
        this._unusedPrefix = 1;
    }

    return this._parseMillisecondsIntoReadableTime(time).substring(this._unusedPrefix);
  }

  _showPlayBar() {
    document.getElementById('play-bar').style.opacity = '1';
    document.getElementById('canvas').style.cursor = 'auto';
  }

  _hidePlayBar() {
    const isPlaying = document.getElementById('play-button').className === 'player-btn icon-pause';
    const isSelected = document.getElementById('time-slider').selected();

    if (!isSelected && isPlaying &&
    document.getElementById('settings-pane').style.visibility === 'hidden' &&
    document.getElementById('gtao-pane').style.visibility === 'hidden' &&
    document.getElementById('speed-pane').style.visibility === 'hidden') {
      document.getElementById('play-bar').style.opacity = '0';
      document.getElementById('canvas').style.cursor = 'none'; // Warning: it does not always work if chrome dev tools is open
    }
  }

  _onMouseLeave(e) {
    if (e.relatedTarget != null &&
    e.relatedTarget.id !== 'canvas')
      this._view.mouseEvents.onMouseLeave();
  }

  _changeSettingsPaneVisibility(event) {
    if (event.srcElement.id === 'enable-shadows' || event.srcElement.id === 'playback-li' || event.srcElement.id === 'gtao-settings') // avoid to close the settings when modifying the shadows or the other options
      return;

    if (event.target.id === 'settings-button' && document.getElementById('settings-pane').style.visibility === 'hidden' && document.getElementById('gtao-pane').style.visibility === 'hidden' && document.getElementById('speed-pane').style.visibility === 'hidden') {
      document.getElementById('settings-pane').style.visibility = 'visible';
      document.getElementById('settings-button').style.transform = 'rotate(10deg)';
      const tooltips = document.getElementsByClassName('tooltip');
      for (let i of tooltips)
        i.style.visibility = 'hidden';
    } else if (document.getElementById('settings-pane').style.visibility === 'visible' || document.getElementById('gtao-pane').style.visibility === 'visible' || document.getElementById('speed-pane').style.visibility === 'visible') {
      document.getElementById('settings-pane').style.visibility = 'hidden';
      if (document.getElementById('gtao-pane').style.visibility === 'hidden' && document.getElementById('speed-pane').style.visibility === 'hidden') {
        document.getElementById('settings-button').style.transform = '';
        const tooltips = document.getElementsByClassName('tooltip');
        for (let i of tooltips)
          i.style.visibility = '';
      }
    }

    document.getElementById('gtao-pane').style.visibility = 'hidden';
    document.getElementById('speed-pane').style.visibility = 'hidden';
  }

  _resetViewpoint() {
    WbWorld.instance.viewpoint.resetViewpoint();
    this._scene.render(); // render once to reset immediatly the viewpoint even if the animation is on pause
  }

  _changeSpeed(event) {
    this._speed = event.srcElement.id;
    document.getElementById('speed-pane').style.visibility = 'hidden';
    document.getElementById('speed-display').innerHTML = this._speed === '1' ? 'Normal' : this._speed;
    document.getElementById('settings-pane').style.visibility = 'visible';
    for (let i of document.getElementsByClassName('check-speed')) {
      if (i.id === 'c' + this._speed)
        i.innerHTML = '&check;';
      else
        i.innerHTML = '';
    }
    this._start = new Date().getTime() - this._data.basicTimeStep * this._step / this._speed;
  }

  _openSpeedPane() {
    document.getElementById('settings-pane').style.visibility = 'hidden';
    document.getElementById('speed-pane').style.visibility = 'visible';
  }

  _closeSpeedPane() {
    document.getElementById('settings-pane').style.visibility = 'visible';
    document.getElementById('speed-pane').style.visibility = 'hidden';
  }

  _changeGtao(event) {
    changeGtaoLevel(this._textToGtaoLevel(event.srcElement.id));
    document.getElementById('gtao-pane').style.visibility = 'hidden';
    document.getElementById('gtao-display').innerHTML = event.srcElement.id;
    document.getElementById('settings-pane').style.visibility = 'visible';
    for (let i of document.getElementsByClassName('check-gtao')) {
      if (i.id === 'c' + event.srcElement.id)
        i.innerHTML = '&check;';
      else
        i.innerHTML = '';
    }
    this._start = new Date().getTime() - this._data.basicTimeStep * this._step / this._speed;
    this._scene.render();
  }

  _openGtaoPane() {
    document.getElementById('settings-pane').style.visibility = 'hidden';
    document.getElementById('gtao-pane').style.visibility = 'visible';
  }

  _closeGtaoPane() {
    document.getElementById('settings-pane').style.visibility = 'visible';
    document.getElementById('gtao-pane').style.visibility = 'hidden';
  }

  _gtaoLevelToText(number) {
    const pairs = {
      1: 'Low',
      2: 'Medium',
      3: 'High',
      4: 'Ultra'
    };
    return (number in pairs) ? pairs[number] : '';
  }

  _textToGtaoLevel(text) {
    const pairs = {
      'Low': 1,
      'Medium': 2,
      'High': 3,
      'Ultra': 4
    };
    return (text in pairs) ? pairs[text] : 4;
  }

  _createPlayBar() {
    const div = document.createElement('div');
    div.id = 'play-bar';
    this._view.view3D.appendChild(div);

    div.addEventListener('mouseover', () => this._showPlayBar());
    div.addEventListener('mouseleave', _ => this._onMouseLeave(_));

    const leftPane = document.createElement('div');
    leftPane.className = 'left-pane';
    leftPane.id = 'left-pane';

    const rightPane = document.createElement('div');
    rightPane.className = 'right-pane';
    rightPane.id = 'right-pane';

    document.getElementById('play-bar').appendChild(leftPane);
    document.getElementById('play-bar').appendChild(rightPane);
    this._view.mouseEvents.hidePlayBar = this._hidePlayBar;
    this._view.mouseEvents.showPlayBar = this._showPlayBar;
  }

  _createSlider() {
    window.customElements.define('animation-slider', AnimationSlider);
    const timeSlider = document.createElement('animation-slider');
    timeSlider.id = 'time-slider';
    document.addEventListener('slider_input', _ => this._updateSlider(_));
    document.getElementById('play-bar').appendChild(timeSlider);
    document.querySelector('animation-slider').shadowRoot.getElementById('range').addEventListener('mousemove', _ => this._updateFloatingTimePosition(_));
    document.querySelector('animation-slider').shadowRoot.getElementById('range').addEventListener('mouseleave', _ => this._hideFloatingTimePosition(_));
  }

  _createPlayButton() {
    const playButton = document.createElement('button');
    const action = (this._gui === 'real_time') ? 'pause' : 'play';
    playButton.className = 'player-btn icon-' + action;
    playButton.id = 'play-button';
    playButton.addEventListener('click', () => this._triggerPlayPauseButton());
    document.getElementById('left-pane').appendChild(playButton);

    const playTooltip = document.createElement('span');
    playTooltip.className = 'tooltip play-tooltip';
    playTooltip.id = 'play-tooltip';
    playTooltip.innerHTML = 'P' + action.substring(1) + ' (k)';
    playButton.appendChild(playTooltip);
  }

  _createTimeIndicator() {
    this._currentTime = document.createElement('span');
    this._currentTime.className = 'current-time';
    this._currentTime.disabled = false;
    this._currentTime.innerHTML = this._formatTime(this._data.frames[0].time);
    document.getElementById('left-pane').appendChild(this._currentTime);

    const timeDivider = document.createElement('span');
    timeDivider.innerHTML = '\\';
    timeDivider.className = 'time-divider';
    document.getElementById('left-pane').appendChild(timeDivider);

    const totalTime = document.createElement('span');
    totalTime.className = 'total-time';
    const time = this._formatTime(this._data.frames[this._data.frames.length - 1].time);
    totalTime.innerHTML = time;
    document.getElementById('left-pane').appendChild(totalTime);

    let offset;
    switch (time.length) {
      case 20:
        offset = 19;
        break;
      case 22:
        offset = 25;
        break;
      case 23:
        offset = 30;
        break;
      case 25:
        offset = 36;
        break;
      default:
        offset = 0;
    }

    document.getElementById('time-slider').setOffset(offset);
  }

  _createSettings() {
    this._createSettingsButton();
    this._createSettingsPane();
  }

  _createSettingsButton() {
    const settingsButton = document.createElement('button');
    settingsButton.className = 'player-btn icon-settings';
    settingsButton.id = 'settings-button';
    document.getElementById('right-pane').appendChild(settingsButton);

    const settingsTooltip = document.createElement('span');
    settingsTooltip.className = 'tooltip settings-tooltip';
    settingsTooltip.innerHTML = 'Settings';
    settingsButton.appendChild(settingsTooltip);
  }

  _createSettingsPane() {
    const settingsPane = document.createElement('div');
    settingsPane.className = 'settings-pane';
    settingsPane.id = 'settings-pane';
    settingsPane.style.visibility = 'hidden';
    document.addEventListener('mouseup', _ => this._changeSettingsPaneVisibility(_));
    document.getElementById('view3d').appendChild(settingsPane);

    const settingsList = document.createElement('ul');
    settingsList.id = 'settings-list';
    document.getElementById('settings-pane').appendChild(settingsList);

    this._createResetViewpoint();
    this._createChangeShadows();
    this._createChangeGtao();
    this._createChangeSpeed();
  }

  _createResetViewpoint() {
    const resetViewpoint = document.createElement('li');
    resetViewpoint.onclick = () => this._resetViewpoint();
    document.getElementById('settings-list').appendChild(resetViewpoint);

    let label = document.createElement('span');
    label.className = 'setting-span';
    label.innerHTML = 'Reset viewpoint';
    resetViewpoint.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    resetViewpoint.appendChild(label);
  }

  _createChangeShadows() {
    const shadowLi = document.createElement('li');
    shadowLi.id = 'enable-shadows';
    document.getElementById('settings-list').appendChild(shadowLi);

    let label = document.createElement('span');
    label.className = 'setting-span';
    label.innerHTML = 'Shadows';
    shadowLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    shadowLi.appendChild(label);

    const button = document.createElement('label');
    button.className = 'switch';
    shadowLi.appendChild(button);

    label = document.createElement('input');
    label.type = 'checkbox';
    label.checked = true;
    button.appendChild(label);

    label = document.createElement('span');
    label.className = 'slider round';
    button.appendChild(label);

    shadowLi.onclick = _ => {
      button.click();
      changeShadows();
      this._scene.render();
    };
  }

  _createChangeGtao() {
    const gtaoLi = document.createElement('li');
    gtaoLi.id = 'gtao-settings';
    document.getElementById('settings-list').appendChild(gtaoLi);
    gtaoLi.onclick = () => this._openGtaoPane();

    let label = document.createElement('span');
    label.className = 'setting-span';
    label.innerHTML = 'Ambient Occlusion';
    gtaoLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    gtaoLi.appendChild(label);

    label = document.createElement('span');
    label.className = 'setting-text';
    label.innerHTML = this._gtaoLevelToText(GtaoLevel);
    label.id = 'gtao-display';
    gtaoLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'arrow-right';
    gtaoLi.appendChild(label);

    this._createGtaoPane();
  }

  _createGtaoPane() {
    const gtaoPane = document.createElement('div');
    gtaoPane.className = 'settings-pane';
    gtaoPane.id = 'gtao-pane';
    gtaoPane.style.visibility = 'hidden';
    document.getElementById('view3d').appendChild(gtaoPane);

    const gtaoList = document.createElement('ul');
    gtaoPane.appendChild(gtaoList);

    let gtaoLevelLi = document.createElement('li');
    gtaoLevelLi.className = 'first-li';

    let label = document.createElement('div');
    label.className = 'arrow-left';
    gtaoLevelLi.appendChild(label);

    label = document.createElement('span');
    label.innerHTML = 'Ambient Occlusion Level';
    label.className = 'setting-span';
    gtaoLevelLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    gtaoLevelLi.appendChild(label);
    gtaoLevelLi.onclick = () => this._closeGtaoPane();
    gtaoList.appendChild(gtaoLevelLi);

    for (let i of ['Low', 'Normal', 'High', 'Ultra']) {
      gtaoLevelLi = document.createElement('li');
      gtaoLevelLi.id = i;
      label = document.createElement('span');
      if (this._gtaoLevelToText(GtaoLevel) === i)
        label.innerHTML = '&check;';
      label.id = 'c' + i;
      label.className = 'check-gtao';
      gtaoLevelLi.appendChild(label);
      label = document.createElement('span');
      label.innerHTML = i;
      label.className = 'setting-span';
      gtaoLevelLi.appendChild(label);
      label = document.createElement('div');
      label.className = 'spacer';
      gtaoLevelLi.appendChild(label);
      gtaoLevelLi.onclick = _ => this._changeGtao(_);
      gtaoList.appendChild(gtaoLevelLi);
    }
  }

  _createChangeSpeed() {
    const playbackLi = document.createElement('li');
    playbackLi.id = 'playback-li';
    document.getElementById('settings-list').appendChild(playbackLi);
    playbackLi.onclick = () => this._openSpeedPane();

    let label = document.createElement('span');
    label.innerHTML = 'Playback speed';
    label.className = 'setting-span';
    playbackLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    playbackLi.appendChild(label);

    label = document.createElement('span');
    label.className = 'setting-text';
    label.innerHTML = 'Normal';
    label.id = 'speed-display';
    playbackLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'arrow-right';
    playbackLi.appendChild(label);

    this._createSpeedPane();
  }

  _createSpeedPane() {
    const speedPane = document.createElement('div');
    speedPane.className = 'settings-pane';
    speedPane.id = 'speed-pane';
    speedPane.style.visibility = 'hidden';

    const speedList = document.createElement('ul');
    speedPane.appendChild(speedList);
    document.getElementById('view3d').appendChild(speedPane);

    let playbackLi = document.createElement('li');
    playbackLi.className = 'first-li';

    let label = document.createElement('div');
    label.className = 'arrow-left';
    playbackLi.appendChild(label);

    label = document.createElement('span');
    label.innerHTML = 'Playback speed';
    label.className = 'setting-span';
    playbackLi.appendChild(label);

    label = document.createElement('div');
    label.className = 'spacer';
    playbackLi.appendChild(label);
    playbackLi.onclick = () => this._closeSpeedPane();
    speedList.appendChild(playbackLi);

    for (let i of ['0.25', '0.5', '0.75', '1', '1.25', '1.5', '1.75', '2']) {
      playbackLi = document.createElement('li');
      playbackLi.id = i;
      label = document.createElement('span');
      if (i === '1')
        label.innerHTML = '&check;';
      label.id = 'c' + i;
      label.className = 'check-speed';
      playbackLi.appendChild(label);
      label = document.createElement('span');
      if (i === '1')
        label.innerHTML = 'Normal';
      else
        label.innerHTML = i;
      label.className = 'setting-span';
      playbackLi.appendChild(label);
      label = document.createElement('div');
      label.className = 'spacer';
      playbackLi.appendChild(label);
      playbackLi.onclick = _ => this._changeSpeed(_);
      speedList.appendChild(playbackLi);
    }
  }

  _createFullscreenButton() {
    this._fullscreenButton = document.createElement('button');
    this._fullscreenButton.className = 'player-btn icon-fullscreen';
    this._fullscreenButton.title = 'Full screen (f)';
    this._fullscreenButton.onclick = () => requestFullscreen(this._view);
    document.getElementById('right-pane').appendChild(this._fullscreenButton);

    let fullscreenTooltip = document.createElement('span');
    fullscreenTooltip.className = 'tooltip fullscreen-tooltip';
    fullscreenTooltip.innerHTML = 'Full screen (f)';
    this._fullscreenButton.appendChild(fullscreenTooltip);

    const exitFullscreenButton = document.createElement('button');
    exitFullscreenButton.title = 'Exit full screen (f)';
    exitFullscreenButton.className = 'player-btn icon-partscreen';
    exitFullscreenButton.style.display = 'none';
    exitFullscreenButton.onclick = () => exitFullscreen();
    document.getElementById('right-pane').appendChild(exitFullscreenButton);

    fullscreenTooltip = document.createElement('span');
    fullscreenTooltip.className = 'tooltip fullscreen-tooltip';
    fullscreenTooltip.innerHTML = 'Exit full screen (f)';
    exitFullscreenButton.appendChild(fullscreenTooltip);

    document.addEventListener('fullscreenchange', () => onFullscreenChange(this._fullscreenButton, exitFullscreenButton));
    document.addEventListener('webkitfullscreenchange', () => onFullscreenChange(this._fullscreenButton, exitFullscreenButton));
    document.addEventListener('mozfullscreenchange', () => onFullscreenChange(this._fullscreenButton, exitFullscreenButton));
    document.addEventListener('MSFullscreenChange', () => onFullscreenChange(this._fullscreenButton, exitFullscreenButton));
  }

  _keyboardHandler(e) {
    if (e.code === 'KeyK')
      this._triggerPlayPauseButton();
    else if (e.code === 'KeyF')
      this._fullscreenButton.style.display === 'none' ? exitFullscreen() : requestFullscreen(this._view);
  }

  _updateFloatingTimePosition(e) {
    document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').style.visibility = 'visible';

    const bounds = document.querySelector('animation-slider').shadowRoot.getElementById('range').getBoundingClientRect();
    let x = (e.clientX - bounds.left) / (bounds.right - bounds.left) * 100;
    if (x > 100)
      x = 100;
    else if (x < 0)
      x = 0;

    const clampedValued = Math.min(x, 99); // set maximum value to get valid step index
    const requestedStep = Math.floor(this._data.frames.length * clampedValued / 100);
    document.getElementById('time-slider').setTime(this._formatTime(this._data.frames[requestedStep].time));

    document.getElementById('time-slider').setFloatingTimePosition(e.clientX);
  }

  _hideFloatingTimePosition() {
    document.querySelector('animation-slider').shadowRoot.getElementById('floating-time').style.visibility = '';
  }
}class DefaultUrl {
  static wwiUrl() {
    if (typeof this._wwiUrl === 'undefined') {
      this._wwiUrl = '';
      const scripts = document.getElementsByTagName('script');
      for (let i = scripts.length - 1; i >= 0; i--) {
        let src = scripts[i].src;
        if (src.indexOf('?') > 0)
          src = src.substring(0, src.indexOf('?'));
        if (src.endsWith('init_animation.js') || src.endsWith('enum.js') || src.endsWith('wrenjs.js')) {
          this._wwiUrl = src.substring(0, src.lastIndexOf('/')); // remove "wrenjs.js"
          break;
        }
      }
    }
    return this._wwiUrl;
  }

  static wwiImagesUrl() {
    return this.wwiUrl() + '/images/';
  }

  static wrenImagesUrl() {
    return this.wwiUrl() + '/images/post_processing/';
  }
}class WbVector3 {
  constructor(x = 0.0, y = 0.0, z = 0.0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  add(vector) {
    return new WbVector3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
  }

  almostEquals(vector, tolerance) {
    return Math.abs(this.x - vector.x) < tolerance && Math.abs(this.y - vector.y) < tolerance && Math.abs(this.z - vector.z) < tolerance;
  }

  // angle between two vectors (in radians)
  angle(vector) {
    const s = this.dot(vector) / Math.sqrt(this.length2() * vector.length2());
    return (s >= 1.0) ? 0 : (s <= -1.0) ? Math.PI : Math.acos(s);
  }

  cross(vector) {
    return new WbVector3(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);
  }

  div(number) {
    return new WbVector3(this.x / number, this.y / number, this.z / number);
  }

  dot(vector) {
    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
  }

  equal(vector) {
    return this.x === vector.x && this.y === vector.y && this.z === vector.z;
  }

  get(index) {
    if (index === 0)
      return this.x;
    else if (index === 1)
      return this.y;
    else if (index === 2)
      return this.z;
  }

  isNull() {
    return this.x === 0.0 && this.y === 0.0 && this.z === 0.0;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  length2() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  mul(number) {
    return new WbVector3(this.x * number, this.y * number, this.z * number);
  }

  normalize() {
    const result = this.div(this.length());
    this.x = result.x;
    this.y = result.y;
    this.z = result.z;
  }

  normalized() {
    return this.div(this.length());
  }

  setXyz(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  sub(vector) {
    return new WbVector3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
  }

  clone() {
    return new WbVector3(this.x, this.y, this.z);
  }
}class WbVector4 {
  constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  div(number) {
    return new WbVector4(this.x / number, this.y / number, this.z / number, this.w / number);
  }

  clone() {
    return new WbVector4(this.x, this.y, this.z, this.w);
  }
}class WbBaseNode {
  constructor(id) {
    this.id = id;

    this.wrenObjectsCreatedCalled = false;
    this.isPreFinalizeCalled = false;
    this.isPostFinalizeCalled = false;

    this._upperTransformFirstTimeSearch = true;
    this.upperTransform = false;

    this._boundingObjectFirstTimeSearch = true;
    this.isInBoundingObject = false;

    this.useList = [];
  }

  createWrenObjects() {
    this.wrenObjectsCreatedCalled = true;

    if (typeof this.parent !== 'undefined')
      this.wrenNode = WbWorld.instance.nodes.get(this.parent).wrenNode;
    else
      this.wrenNode = _wr_scene_get_root(_wr_scene_get_instance());
  }

  delete() {
    if (this.useList.length !== 0) {
      let newDef;
      let index = 0;
      while (typeof newDef === 'undefined' && index < this.useList.length) {
        newDef = WbWorld.instance.nodes.get(this.useList[index]);
        this.useList.splice(index, 1);
        index++;
      }

      if (typeof newDef !== 'undefined')
        newDef.useList = this.useList;
    }

    WbWorld.instance.nodes.delete(this.id);
  }

  finalize() {
    if (!this.isPreFinalizeCalled)
      this.preFinalize();

    if (!this.wrenObjectsCreatedCalled)
      this.createWrenObjects();

    if (!this.isPostFinalizeCalled)
      this.postFinalize();
  }

  isInBoundingObject() {
    if (this._boundingObjectFirstTimeSearch) {
      this.isInBoundingObject = nodeIsInBoundingObject(this);
      if (this.wrenObjectsCreatedCalled)
        this._boundingObjectFirstTimeSearch = false;
    }

    return this.isInBoundingObject;
  }

  upperTransform() {
    if (this._upperTransformFirstTimeSearch) {
      this.upperTransform = findUpperTransform(this);
      if (this.wrenObjectsCreatedCalled)
        this._upperTransformFirstTimeSearch = false;
    }

    return this.upperTransform;
  }

  preFinalize() {
    this.isPreFinalizeCalled = true;
  }

  postFinalize() {
    this.isPostFinalizeCalled = true;
  }
}class WbLight extends WbBaseNode {
  constructor(id, on, color, intensity, castShadows, ambientIntensity) {
    super(id);
    this.color = color;

    this.ambientIntensity = ambientIntensity;
    this.intensity = intensity;

    this.on = on;
    this.castShadows = castShadows;
  }

  createWrenObjects() {
    super.createWrenObjects();

    this._applyLightColorToWren();
    this._applyLightIntensityToWren();
    this._applyLightVisibilityToWren();
    this._applyLightShadowsToWren();
    this._applySceneAmbientColorToWren();
  }

  delete() {
    if (typeof this.parent === 'undefined') {
      const index = WbWorld.instance.sceneTree.indexOf(this);
      WbWorld.instance.sceneTree.splice(index, 1);
    } else {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined') {
        const index = parent.children.indexOf(this);
        parent.children.splice(index, 1);
      }
    }

    if (this.wrenObjectsCreatedCalled) {
      WbLight.lights.splice(this, 1);
      this._applySceneAmbientColorToWren();
    }

    super.delete();
  }

  preFinalize() {
    super.preFinalize();
    WbLight.lights.push(this);
  }

  // Private functions

  _applyLightColorToWren() {}
  _applyLightIntensityToWren() {}
  _applyLightShadowsToWren() {}
  _applyLightVisibilityToWren() {}

  _applySceneAmbientColorToWren() {
    this._computeAmbientLight();
  }

  _computeAmbientLight() {
    const rgb = new WbVector3(0.0, 0.0, 0.0);

    WbLight.lights.forEach(light => {
      if (light.on) {
        rgb.x += light.ambientIntensity * light.color.x;
        rgb.y += light.ambientIntensity * light.color.y;
        rgb.z += light.ambientIntensity * light.color.z;
      }
    });

    _wr_scene_set_ambient_light(_wrjs_array3(rgb.x, rgb.y, rgb.z));
  }
}

WbLight.lights = [];class WbGroup extends WbBaseNode {
  constructor(id, isPropeller) {
    super(id);
    this.children = [];

    this.isPropeller = isPropeller;
    this.currentHelix = -1; // to switch between fast and slow helix
  }

  async clone(customID) {
    const group = new WbGroup(customID, this.isPropeller);
    const length = this.children.length;
    for (let i = 0; i < length; i++) {
      const cloned = await this.children[i].clone(getAnId());
      cloned.parent = customID;
      WbWorld.instance.nodes.set(cloned.id, cloned);
      group.children.push(cloned);
    }

    this.useList.push(customID);
    return group;
  }

  createWrenObjects(isTransform) {
    super.createWrenObjects();

    if (!isTransform) {
      this.children.forEach(child => {
        child.createWrenObjects();
      });
    }
  }

  delete(isBoundingObject) {
    if (typeof this.parent === 'undefined') {
      const index = WbWorld.instance.sceneTree.indexOf(this);
      WbWorld.instance.sceneTree.splice(index, 1);
    } else {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined') {
        if (isBoundingObject)
          parent.isBoundingObject = null;
        else {
          const index = parent.children.indexOf(this);
          parent.children.splice(index, 1);
        }
      }
    }

    let index = this.children.length - 1;
    while (index >= 0) {
      this.children[index].delete();
      --index;
    }

    super.delete();
  }
  preFinalize() {
    super.preFinalize();

    this.children.forEach(child => child.preFinalize());
  }

  postFinalize() {
    super.postFinalize();

    this.children.forEach(child => child.postFinalize());

    if (this.isPropeller === true) {
      if (typeof this.children[1] !== 'undefined')
        this.currentHelix = this.children[1].id;
      else if (typeof this.children[0] !== 'undefined')
        this.currentHelix = this.children[0].id;
      this.switchHelix(this.currentHelix, true);
    }
  }

  switchHelix(id, force) {
    if (id !== this.currentHelix || force) {
      this.currentHelix = id;
      this.children.forEach(child => {
        if (child.id === this.currentHelix)
          _wr_node_set_visible(child.wrenNode, true);
        else
          _wr_node_set_visible(child.wrenNode, false);
      });
    }
  }

  updateBoundingObjectVisibility() {
    this.children.forEach(child => {
      if (!(child instanceof WbLight))
        child.updateBoundingObjectVisibility();
    });
  }
}class WbBillboard extends WbGroup {
  constructor(id) {
    super(id);
    WbWorld.instance.billboards.push(id);
  }
  createWrenObjects() {
    super.createWrenObjects(true);

    const transform = _wr_transform_new();
    _wr_transform_attach_child(this.wrenNode, transform);
    this.wrenNode = transform;

    this.children.forEach(child => {
      child.createWrenObjects();
    });

    this.updatePosition();
  }

  delete() {
    if (this.wrenObjectsCreatedCalled)
      _wr_node_delete(this.wrenNode);

    const index = WbWorld.instance.billboards.indexOf(this.id);
    if (index > -1)
      WbWorld.instance.billboards.splice(index, 1);
  }

  updatePosition() {
    this._applyRotationToWren();
    this._applyTranslationToWren();
  }

  _applyRotationToWren() {
    let orientation = WbWorld.instance.viewpoint.orientation;
    let orientationPointer = _wrjs_array4(orientation.w, orientation.x, orientation.y, orientation.z);
    _wr_transform_set_orientation(this.wrenNode, orientationPointer);
  }

  _applyTranslationToWren() {
    let position = WbWorld.instance.viewpoint.position;
    let positionPointer = _wrjs_array3(position.x, position.y, position.z);
    _wr_transform_set_position(this.wrenNode, positionPointer);
  }
}// Also used to represent a solid
class WbTransform extends WbGroup {
  constructor(id, isSolid, translation, scale, rotation) {
    super(id);
    this.isSolid = isSolid;
    this.translation = translation;
    this.scale = scale;
    this.rotation = rotation;

    this.children = [];
  }

  applyRotationToWren() {
    const rotation = _wrjs_array4(this.rotation.w, this.rotation.x, this.rotation.y, this.rotation.z);
    _wr_transform_set_orientation(this.wrenNode, rotation);
  }

  applyScaleToWren() {
    const scale = _wrjs_array3(this.scale.x, this.scale.y, this.scale.z);
    _wr_transform_set_scale(this.wrenNode, scale);
  }

  applyTranslationToWren() {
    const translation = _wrjs_array3(this.translation.x, this.translation.y, this.translation.z);
    _wr_transform_set_position(this.wrenNode, translation);
  }

  async clone(customID) {
    const transform = new WbTransform(customID, this.isSolid, this.translation, this.scale, this.rotation);

    const length = this.children.length;
    for (let i = 0; i < length; i++) {
      const cloned = await this.children[i].clone(getAnId());
      cloned.parent = customID;
      WbWorld.instance.nodes.set(cloned.id, cloned);
      transform.children.push(cloned);
    }

    this.useList.push(customID);
    return transform;
  }

  createWrenObjects() {
    super.createWrenObjects(true);
    const transform = _wr_transform_new();

    _wr_transform_attach_child(this.wrenNode, transform);
    this.wrenNode = transform;
    this.children.forEach(child => {
      child.createWrenObjects();
    });

    if (typeof this.boundingObject !== 'undefined')
      this.boundingObject.createWrenObjects();

    this.applyTranslationToWren();
    this.applyRotationToWren();
    this.applyScaleToWren();
  }

  delete(isBoundingObject) {
    if (this.wrenObjectsCreatedCalled)
      _wr_node_delete(this.wrenNode);

    if (typeof this.boundingObject !== 'undefined')
      this.boundingObject.delete(true);

    super.delete(isBoundingObject);
  }

  preFinalize() {
    super.preFinalize();

    if (typeof this.boundingObject !== 'undefined')
      this.boundingObject.preFinalize();
  }

  postFinalize() {
    super.postFinalize();

    if (typeof this.boundingObject !== 'undefined')
      this.boundingObject.postFinalize();
  }

  updateBoundingObjectVisibility() {
    super.updateBoundingObjectVisibility();

    if (typeof this.boundingObject !== 'undefined')
      this.boundingObject.updateBoundingObjectVisibility();
  }
}let undefinedID = -1; // Negative IDs are assigned to nodes provided by Webots without IDs.

function array3Pointer(x, y, z) {
  const data = new Float32Array([x, y, z]);
  const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
  const dataPtr = Module._malloc(nDataBytes);
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
  dataHeap.set(new Uint8Array(data.buffer));

  return dataHeap.byteOffset;
}

function arrayXPointer(array) {
  const data = new Uint8ClampedArray(array);
  const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
  const dataPtr = Module._malloc(nDataBytes);
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
  dataHeap.set(new Uint8Array(data.buffer));

  return dataHeap.byteOffset;
}

function arrayXPointerInt(array) {
  const data = new Int32Array(array);
  const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
  const dataPtr = Module._malloc(nDataBytes);
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
  dataHeap.set(new Uint8Array(data.buffer));

  return dataHeap.byteOffset;
}

function arrayXPointerFloat(array) {
  const data = new Float32Array(array);
  const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
  const dataPtr = Module._malloc(nDataBytes);
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
  dataHeap.set(new Uint8Array(data.buffer));

  return dataHeap.byteOffset;
}

function direction(vec4) {
  const c = Math.cos(vec4.w);
  const s = Math.sin(vec4.w);
  const t = 1 - c;
  const tTimesZ = t * vec4.z;
  return new WbVector3(tTimesZ * vec4.x + s * vec4.y, tTimesZ * vec4.y - s * vec4.x, tTimesZ * vec4.z + c);
}

function findUpperTransform(node) {
  if (typeof node === 'undefined')
    return undefined;

  let n = WbWorld.instance.nodes.get(node.parent);
  while (typeof n !== 'undefined') {
    if (n instanceof WbTransform)
      return n;
    else
      n = n.parent;
  }
  return undefined;
}

function fromAxisAngle(x, y, z, angle) {
  const result = new WbVector4();
  let l = x * x + y * y + z * z;
  if (l > 0.0) {
    angle *= 0.5;
    result.w = Math.cos(angle);
    l = Math.sin(angle) / Math.sqrt(l);
    result.x = x * l;
    result.y = y * l;
    result.z = z * l;
  } else {
    result.w = 1.0;
    result.x = 0.0;
    result.y = 0.0;
    result.z = 0.0;
  }
  return result;
}

function getAncestor(node) {
  if (typeof node !== 'undefined' && typeof node.parent !== 'undefined') {
    let parent = WbWorld.instance.nodes.get(node.parent);

    if (typeof parent !== 'undefined')
      return getAncestor(parent);
  }

  return node;
}

function getAnId() {
  return 'n' + undefinedID--;
}

function length(vec3) {
  return Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y + vec3.z * vec3.z);
}

function nodeIsInBoundingObject(node) {
  if (typeof node === 'undefined' || typeof node.parent === 'undefined')
    return false;

  const parent = WbWorld.instance.nodes.get(node.parent);
  if (typeof parent !== 'undefined') {
    if (parent instanceof WbTransform && typeof parent.boundingObject !== 'undefined')
      return parent.boundingObject === node;
    else if (typeof parent.parent !== 'undefined')
      return nodeIsInBoundingObject(parent);
  }

  return false;
}

function isDescendantOfBillboard(node) {
  while (typeof node !== 'undefined') {
    if (node instanceof WbBillboard)
      return true;

    node = WbWorld.instance.nodes.get(node.parent);
  }

  return false;
}

function pointerOnFloat(float) {
  const data = new Float32Array(1);
  data[0] = float;
  const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
  const dataPtr = Module._malloc(nDataBytes);
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
  dataHeap.set(new Uint8Array(data.buffer));

  return dataHeap.byteOffset;
}

function quaternionToVec4(quat) {
  let angle;
  if (quat.w >= 1.0)
    angle = 0.0;
  else if (quat.w <= -1.0)
    angle = 2.0 * Math.PI;
  else
    angle = 2.0 * Math.acos(quat.w);

  // normalise axes
  let div = Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
  if (div === 0)
    div = 1;
  const inv = 1.0 / div;
  const x = quat.x * inv;
  const y = quat.y * inv;
  const z = quat.z * inv;

  return new WbVector4(x, y, z, angle);
}

function right(vec4) {
  const c = Math.cos(vec4.w);
  const s = Math.sin(vec4.w);
  const t = 1 - c;
  const tTimesX = t * vec4.x;
  return new WbVector3(tTimesX * vec4.x + c, tTimesX * vec4.y + s * vec4.z, tTimesX * vec4.z - s * vec4.y);
}

function up(vec4) {
  const c = Math.cos(vec4.w);
  const s = Math.sin(vec4.w);
  const t = 1 - c;
  const tTimesY = t * vec4.y;
  return new WbVector3(tTimesY * vec4.x - s * vec4.z, tTimesY * vec4.y + c, tTimesY * vec4.z + s * vec4.x);
}

function vec4ToQuaternion(vec4) {
  const halfAngle = 0.5 * vec4.w;
  const sinusHalfAngle = Math.sin(halfAngle);
  const cosinusHalfAngle = Math.cos(halfAngle);
  return glm.quat(cosinusHalfAngle, vec4.x * sinusHalfAngle, vec4.y * sinusHalfAngle, vec4.z * sinusHalfAngle);
}class Selector {
  static select(id) {
    Selector.previousId = Selector.selectedId;
    Selector.selectedId = undefined;
    if (typeof WbWorld.instance === 'undefined')
      return;

    const node = WbWorld.instance.nodes.get('n' + id);
    if (typeof node === 'undefined') {
      Selector.preciseId = 'n' + id;
      Selector.previousAncestor = undefined;
      return;
    }

    if (Selector.previousAncestor === Selector.topSolidId(node) && (!Selector.local || Selector.preciseId !== 'n' + id)) {
      Selector.selectedId = Selector.firstSolidId(node);
      Selector.local = true;
    } else {
      Selector.selectedId = Selector.topSolidId(node);
      Selector.previousAncestor = Selector.selectedId;
      Selector.local = false;
    }

    Selector.preciseId = 'n' + id;
  }

  static checkIfParentIsSelected(node) {
    const parent = WbWorld.instance.nodes.get(node.parent);
    if (typeof parent !== 'undefined') {
      if (Selector.selectedId === parent.id)
        return true;
      else if (typeof parent.parent !== 'undefined')
        return Selector.checkIfParentIsSelected(parent);
    }

    return false;
  }

  static firstSolidId(node) {
    if (typeof node !== 'undefined') {
      if (node instanceof WbTransform && node.isSolid)
        return node.id;
      else if (typeof node.parent !== 'undefined' && typeof WbWorld.instance.nodes.get(node.parent) !== 'undefined')
        return Selector.firstSolidId(WbWorld.instance.nodes.get(node.parent));
    }
    return -1;
  }

  static topSolidId(node) {
    let topSolid;
    let currentNode = node;
    while (typeof currentNode !== 'undefined') {
      if (currentNode instanceof WbTransform && currentNode.isSolid)
        topSolid = currentNode.id;

      if (typeof currentNode.parent !== 'undefined')
        currentNode = WbWorld.instance.nodes.get(currentNode.parent);
      else
        break;
    }

    return topSolid;
  }

  static reset() {
    Selector.selectedId = undefined;
    Selector.previousId = undefined;
    Selector.previousAncestor = undefined;
    Selector.local = false;
  }
}

Selector.local = false;class SystemInfo {
  static isMacOS() {
    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery
    return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  }

  static isIOS() {
    // https://stackoverflow.com/questions/9038625/detect-if-device-is-ios
    return !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
  }

  static isMobileDevice() {
    // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }
}class WbWrenShaders {
  static buildShader(shader, vertexShaderPath, fragmentShaderpath) {
    Module.ccall('wr_shader_program_set_vertex_shader_path', null, ['number', 'string'], [shader, vertexShaderPath]);
    Module.ccall('wr_shader_program_set_fragment_shader_path', null, ['number', 'string'], [shader, fragmentShaderpath]);
    _wr_shader_program_setup(shader);

    if (!_wr_shader_program_get_gl_name(shader)) {
      console.error('Shader Error');
      if (_wr_shader_program_has_vertex_shader_compilation_failed(shader))
        console.error('Vertex shader compilation failed');
      else if (_wr_shader_program_has_fragment_shader_compilation_failed(shader))
        console.error('Fragment shader compilation failed');
      else
        console.error('Linkage failed');
    }
  }

  static bloomBlendShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE3);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE4);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE5);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE6);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/blend_bloom.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BLOOM_BLEND];
  }

  static brightPassShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);

      const defaultThresholdPointer = _wrjs_pointerOnFloat(10.0);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS], 'threshold', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_FLOAT, defaultThresholdPointer]);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/bright_pass.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_BRIGHT_PASS];
  }

  static defaultShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0); // main texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1); // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2); // background texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT], '../../../resources/wren/shaders/default.vert', '../../../resources/wren/shaders/default.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEFAULT];
  }

  static depthPixelShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL], '../../../resources/wren/shaders/web_depth.vert', '../../../resources/wren/shaders/web_depth.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_DEPTH_PIXEL];
  }

  static fogShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_FOG);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG], '../../../resources/wren/shaders/fog.vert', '../../../resources/wren/shaders/fog.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_FOG];
  }

  static gaussianBlur13TapShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP], Enum.WR_GLSL_LAYOUT_UNIFORM_ITERATION_NUMBER);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/gaussian_blur_13_tap.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GAUSSIAN_BLUR_13_TAP];
  }

  static gtaoShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], Enum.WR_GLSL_LAYOUT_UNIFORM_VIEWPORT_SIZE);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      const paramsPointer = _wrjs_array4(0, 0, 0, 0);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], 'params', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_VEC4F, paramsPointer]);

      const clipInfoPointer = _wrjs_array4(0.0, 1000000.0, 0.0, 0.0);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], 'clipInfo', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_VEC4F, clipInfoPointer]);

      const radiusPointer = _wrjs_pointerOnFloat(2.0);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], 'radius', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_FLOAT, radiusPointer]);

      const flipNormalYPointer = _wrjs_pointerOnFloat(0.0);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], 'flipNormalY', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_FLOAT, flipNormalYPointer]);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/gtao.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO];
  }

  static gtaoSpatialDenoiseShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/gtao_spatial_denoise.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_SPATIAL_DENOISE];
  }

  static gtaoTemporalDenoiseShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE3);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      const previousInverseViewMatrix = [16].fill(0.0);
      const previousInverseViewMatrixPointer = arrayXPointer(previousInverseViewMatrix);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], 'previousInverseViewMatrix', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_MAT4F, previousInverseViewMatrixPointer]);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/gtao_temporal_denoise.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_TEMPORAL_DENOISE];
  }

  static gtaoCombineShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE], 0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE], 1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE], 2);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/gtao_combine.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_GTAO_COMBINE];
  }

  static hdrClearShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_CLEAR]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_CLEAR] = _wr_shader_program_new();

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_CLEAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_CLEAR], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/hdr_clear.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_CLEAR];
  }

  static hdrResolveShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);

      const defaultExposureValue = 1.0;
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE], 'exposure', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_FLOAT, _wrjs_pointerOnFloat(defaultExposureValue)]);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/hdr_resolve.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_HDR_RESOLVE];
  }

  static iblSpecularIrradianceBakingShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE] = _wr_shader_program_new();

      const projectionAndViewDefaults = [16].fill(0.0);
      const projectionAndViewDefaultsPointer = arrayXPointer(projectionAndViewDefaults);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE], 'projection', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_MAT4F, projectionAndViewDefaultsPointer]);
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE], 'view', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_MAT4F, projectionAndViewDefaultsPointer]);

      const roughness = 0.0;
      Module.ccall('wr_shader_program_create_custom_uniform', null, ['number', 'string', 'number', 'number'], [WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE], 'roughness', Enum.WR_SHADER_PROGRAM_UNIFORM_TYPE_FLOAT, _wrjs_pointerOnFloat(roughness)]);

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_CUBE0);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE], '../../../resources/wren/shaders/bake_cubemap.vert', '../../../resources/wren/shaders/bake_specular_cubemap.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_SPECULAR_IRRADIANCE_BAKE];
  }

  static iblBrdfBakingShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_BRDF_BAKE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_BRDF_BAKE] = _wr_shader_program_new();

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_BRDF_BAKE], '../../../resources/wren/shaders/bake_brdf.vert', '../../../resources/wren/shaders/bake_brdf.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_IBL_BRDF_BAKE];
  }

  static lineSetShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_COLOR_PER_VERTEX);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET], '../../../resources/wren/shaders/line_set.vert', '../../../resources/wren/shaders/line_set.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_LINE_SET];
  }

  static passThroughShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PASS_THROUGH]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PASS_THROUGH] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PASS_THROUGH], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PASS_THROUGH], '../../../resources/wren/shaders/pass_through.vert', '../../../resources/wren/shaders/pass_through.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PASS_THROUGH];
  }

  static pbrShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0); // base color texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1); // roughness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2); // metalness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE3); // occlusion map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE4); // normal map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE5); // BRDF LUT
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE6); // emissive texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE7); // background texture (for displays)
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE8); // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_CUBE0); // irradiance cubemap
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PBR);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_FOG);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR], '../../../resources/wren/shaders/pbr.vert', '../../../resources/wren/shaders/pbr.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR];
  }

  static pbrStencilAmbientEmissiveShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE] = _wr_shader_program_new();

      // base color texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      // roughness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      // metalness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      // occlusion map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE3);
      // normal map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE4);
      // BRDF LUT
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE5);
      // emissive texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE6);
      // background texture (for displays)
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE7);
      // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE8);
      // irradiance cubemap
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_CUBE0);
      // specular cubemap
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PBR);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE], '../../../resources/wren/shaders/pbr_stencil_ambient_emissive.vert', '../../../resources/wren/shaders/pbr_stencil_ambient_emissive.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_AMBIENT_EMISSIVE];
  }

  static pbrStencilDiffuseSpecularShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR] = _wr_shader_program_new();

      // base color texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      // roughness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      // metalness texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      // occlusion map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE3);
      // normal map
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE4);
      // background texture (for displays)
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE7);
      // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE8);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PBR);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHT_RENDERABLE);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR], '../../../resources/wren/shaders/pbr_stencil_diffuse_specular.vert', '../../../resources/wren/shaders/pbr_stencil_diffuse_specular.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PBR_STENCIL_DIFFUSE_SPECULAR];
  }

  static phongShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0); // main texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1); // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2); // background texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_FOG);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG], '../../../resources/wren/shaders/phong.vert', '../../../resources/wren/shaders/phong.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG];
  }

  static phongStencilAmbientEmissiveShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0); // main texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1); // pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2); // background texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE], '../../../resources/wren/shaders/phong_stencil_ambient_emissive.vert', '../../../resources/wren/shaders/phong_stencil_ambient_emissive.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE];
  }

  static phongStencilDiffuseSpecularShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);// main texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);// pen texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);// background texture
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHT_RENDERABLE);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR], '../../../resources/wren/shaders/phong_stencil_diffuse_specular.vert', '../../../resources/wren/shaders/phong_stencil_diffuse_specular.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR];
  }

  static pickingShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING], '../../../resources/wren/shaders/picking.vert', '../../../resources/wren/shaders/picking.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_PICKING];
  }

  static pointSetShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_COLOR_PER_VERTEX);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_POINT_SIZE);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_MATERIAL_PHONG);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET], '../../../resources/wren/shaders/point_set.vert', '../../../resources/wren/shaders/point_set.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_POINT_SET];
  }

  static shadowVolumeShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME], Enum.WR_GLSL_LAYOUT_UNIFORM_MODEL_TRANSFORM);

      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHTS);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_LIGHT_RENDERABLE);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME], '../../../resources/wren/shaders/shadow_volume.vert', '../../../resources/wren/shaders/shadow_volume.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SHADOW_VOLUME];
  }

  static skyboxShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE_CUBE0);
      _wr_shader_program_use_uniform_buffer(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX], Enum.WR_GLSL_LAYOUT_UNIFORM_BUFFER_CAMERA_TRANSFORMS);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX], '../../../resources/wren/shaders/skybox.vert', '../../../resources/wren/shaders/skybox.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SKYBOX];
  }

  static smaaEdgeDetectionShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_VIEWPORT_SIZE);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS], '../../../resources/wren/shaders/smaa_edge_detect.vert', '../../../resources/wren/shaders/smaa_edge_detect.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_EDGE_DETECT_PASS];
  }

  static smaaBlendingWeightCalculationShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE2);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_VIEWPORT_SIZE);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS], '../../../resources/wren/shaders/smaa_blending_weights.vert', '../../../resources/wren/shaders/smaa_blending_weights.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS];
  }

  static smaaFinalBlendShader() {
    if (!WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS]) {
      WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS] = _wr_shader_program_new();

      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE0);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_TEXTURE1);
      _wr_shader_program_use_uniform(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS], Enum.WR_GLSL_LAYOUT_UNIFORM_VIEWPORT_SIZE);

      WbWrenShaders.buildShader(WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS], '../../../resources/wren/shaders/smaa_final_blend.vert', '../../../resources/wren/shaders/smaa_final_blend.frag');
    }

    return WbWrenShaders.gShaders[WbWrenShaders.SHADER.SHADER_SMAA_FINAL_BLEND_PASS];
  }
}

// gShaders static variable
WbWrenShaders.gShaders = {};

WbWrenShaders.SHADER = {
  SHADER_BLOOM_BLEND: 1,
  SHADER_BRIGHT_PASS: 2,
  SHADER_DEFAULT: 3,
  SHADER_DEPTH_PIXEL: 4,
  SHADER_FOG: 5,
  SHADER_GAUSSIAN_BLUR_13_TAP: 6,
  SHADER_GTAO: 7,
  SHADER_GTAO_SPATIAL_DENOISE: 8,
  SHADER_GTAO_TEMPORAL_DENOISE: 9,
  SHADER_GTAO_COMBINE: 10,
  SHADER_HDR_CLEAR: 11,
  SHADER_HDR_RESOLVE: 12,
  SHADER_IBL_SPECULAR_IRRADIANCE_BAKE: 13,
  SHADER_IBL_BRDF_BAKE: 14,
  SHADER_LINE_SET: 15,
  SHADER_PASS_THROUGH: 16,
  SHADER_PBR: 17,
  SHADER_PBR_STENCIL_AMBIENT_EMISSIVE: 18,
  SHADER_PBR_STENCIL_DIFFUSE_SPECULAR: 19,
  SHADER_PHONG: 20,
  SHADER_PHONG_STENCIL_AMBIENT_EMISSIVE: 21,
  SHADER_PHONG_STENCIL_DIFFUSE_SPECULAR: 22,
  SHADER_PICKING: 23,
  SHADER_POINT_SET: 24,
  SHADER_SHADOW_VOLUME: 25,
  SHADER_SKYBOX: 26,
  SHADER_SMAA_EDGE_DETECT_PASS: 27,
  SHADER_SMAA_BLENDING_WEIGHT_CALCULATION_PASS: 28,
  SHADER_SMAA_FINAL_BLEND_PASS: 29
};class WbWrenPicker {
  constructor() {
    this.selectedId = -1;
    this.coordinates = new WbVector3();
    this._width = 0;
    this._height = 0;

    this._viewport = _wr_viewport_new();
    this._viewportDepth = _wr_viewport_new();

    const colorPointer = _wrjs_array4(0.0, 0.0, 0.0, 0.0);
    _wr_viewport_set_clear_color_rgba(this._viewport, colorPointer);

    this._setup();
  }

  pick(x, y) {
    const viewport = _wr_scene_get_viewport(_wr_scene_get_instance());
    // This fix a bug that occurs when switching between different worlds
    _wr_viewport_set_camera(this._viewport, _wr_viewport_get_camera(viewport));
    _wr_viewport_set_camera(this._viewportDepth, _wr_viewport_get_camera(viewport));

    this.coordinates.setXyz(0.0, 0.0, 0.0);
    this.selectedId = -1;

    // Recreate framebuffer and textures if viewport's size has changed
    if (this._hasSizeChanged()) {
      this._cleanup();
      this._setup();
    }

    // Check if object was picked & decode ID
    const scene = _wr_scene_get_instance();
    _wr_viewport_enable_skybox(this._viewport, false);
    _wr_scene_enable_translucence(scene, false);
    _wr_scene_enable_depth_reset(scene, false);
    Module.ccall('wr_scene_render_to_viewports', null, ['number', 'number', 'number', 'string', 'boolean'], [scene, 1, _wrjs_pointerOnInt(this._viewport), 'picking', true]);
    _wr_scene_enable_depth_reset(scene, true);
    _wr_viewport_enable_skybox(this._viewport, true);
    _wr_scene_enable_translucence(scene, true);

    let data = [];
    let dataPointer = arrayXPointerInt(data);
    _wr_frame_buffer_copy_pixel(this._frameBuffer, 0, x, y, dataPointer, true);
    data[0] = Module.getValue(dataPointer, 'i8');
    data[1] = Module.getValue(dataPointer + 1, 'i8');
    data[2] = Module.getValue(dataPointer + 2, 'i8');
    data[3] = Module.getValue(dataPointer + 3, 'i8');

    _free(dataPointer);

    data[0] = data[0] >= 0 ? data[0] : 256 + data[0];
    data[1] = data[1] >= 0 ? data[1] : 256 + data[1];
    data[2] = data[2] >= 0 ? data[2] : 256 + data[2];
    data[3] = data[3] >= 0 ? data[3] : 256 + data[3];

    const id = (data[2] << 24) | (data[1] << 16) | (data[0] << 8) | data[3];
    if (id === 0)
      return false;
    else
      this.selectedId = id - 1;

    _wr_viewport_enable_skybox(this._viewportDepth, false);
    _wr_scene_enable_translucence(scene, false);
    _wr_scene_enable_depth_reset(scene, false);
    Module.ccall('wr_scene_render_to_viewports', null, ['number', 'number', 'number', 'string', 'boolean'], [scene, 1, _wrjs_pointerOnIntBis(this._viewportDepth), 'depth', true]);
    _wr_scene_enable_depth_reset(scene, true);
    _wr_viewport_enable_skybox(this._viewportDepth, true);
    _wr_scene_enable_translucence(scene, true);

    data = [0, 0, 0, 0];
    dataPointer = arrayXPointerFloat(data);
    _wr_frame_buffer_copy_depth_pixel(this._frameBufferDepth, x, y, dataPointer, true);

    data[0] = Module.getValue(dataPointer, 'float');
    _free(dataPointer);

    this.coordinates = new WbVector3(x, this._height - y - 1, data[0]);
    return true;
  }

  // Setup & attach picking material, based on the unique ID
  // ID is encoded in the following way:
  // Most significant word: red and green channels of ambient color
  // Least signigicant word: red and green channels of diffuse color
  // These are combined in RGBA channels in the picking fragment shader
  static setPickable(renderable, uniqueId, pickable) {
    uniqueId = parseFloat(uniqueId.substring(1));

    let material = Module.ccall('wr_renderable_get_material', 'number', ['number', 'string'], [renderable, 'picking']);

    if (!material) {
      material = _wr_phong_material_new();
      _wr_material_set_default_program(material, WbWrenShaders.pickingShader());

      Module.ccall('wr_renderable_set_material', null, ['number', 'number', 'string'], [renderable, material, 'picking']);
    }

    let depthMaterial = Module.ccall('wr_renderable_get_material', 'number', ['number', 'string'], [renderable, 'depth']);

    if (!depthMaterial) {
      depthMaterial = _wr_phong_material_new();
      _wr_material_set_default_program(depthMaterial, WbWrenShaders.depthPixelShader());

      Module.ccall('wr_renderable_set_material', null, ['number', 'number', 'string'], [renderable, depthMaterial, 'depth']);
    }

    const encodedId = [0, 0, 0, 0, 0, 0];

    if (pickable) {
      // ID is incremented since a 0 value would mean that no object was picked
      // (ID = 0 is valid)
      let id = uniqueId + 1;

      for (let i = 4; i >= 0; --i) {
        if (i === 2)
          continue;

        encodedId[i] = (id & 0x000000FF) / 255.0;
        id >>= 8;
      }
    }

    const encodedIdPointer = arrayXPointerFloat(encodedId);
    const encodedIdPointerSecondHalf = arrayXPointerFloat([encodedId[3], encodedId[4], encodedId[5]]);
    _wr_phong_material_set_linear_ambient(material, encodedIdPointer);
    _wr_phong_material_set_linear_diffuse(material, encodedIdPointerSecondHalf);
    _free(encodedIdPointer);
    _free(encodedIdPointerSecondHalf);
  }

  // Private functions

  _cleanup() {
    if (typeof this._outputTexture !== 'undefined')
      _wr_texture_delete(this._outputTexture);
    if (typeof this._frameBuffer !== 'undefined')
      _wr_frame_buffer_delete(this._frameBuffer);
    if (typeof this._outputTextureDepth !== 'undefined')
      _wr_texture_delete(this._outputTextureDepth);
    if (typeof this._frameBufferDepth !== 'undefined')
      _wr_frame_buffer_delete(this._frameBufferDepth);
  }

  _hasSizeChanged() {
    const viewport = _wr_scene_get_viewport(_wr_scene_get_instance());
    const width = _wr_viewport_get_width(viewport);
    const height = _wr_viewport_get_height(viewport);

    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      return true;
    }
    return false;
  }

  _setup() {
    const viewport = _wr_scene_get_viewport(_wr_scene_get_instance());
    this._width = _wr_viewport_get_width(viewport);
    this._height = _wr_viewport_get_height(viewport);
    _wr_viewport_set_size(this._viewport, this._width, this._height);

    this._frameBuffer = _wr_frame_buffer_new();
    this._outputTexture = _wr_texture_rtt_new();

    _wr_frame_buffer_set_size(this._frameBuffer, this._width, this._height);
    _wr_frame_buffer_enable_depth_buffer(this._frameBuffer, true);

    _wr_frame_buffer_append_output_texture(this._frameBuffer, this._outputTexture);
    _wr_frame_buffer_enable_copying(this._frameBuffer, 0, true);
    _wr_frame_buffer_setup(this._frameBuffer);

    _wr_viewport_set_frame_buffer(this._viewport, this._frameBuffer);
    _wr_viewport_set_camera(this._viewport, _wr_viewport_get_camera(viewport));

    // DEPTH
    _wr_viewport_set_size(this._viewportDepth, this._width, this._height);

    this._frameBufferDepth = _wr_frame_buffer_new();
    this._outputTextureDepth = _wr_texture_rtt_new();
    _wr_texture_set_internal_format(this._outputTextureDepth, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA16F);

    _wr_frame_buffer_set_size(this._frameBufferDepth, this._width, this._height);
    _wr_frame_buffer_enable_depth_buffer(this._frameBufferDepth, true);

    _wr_frame_buffer_append_output_texture(this._frameBufferDepth, this._outputTextureDepth);
    _wr_frame_buffer_setup(this._frameBufferDepth);

    _wr_viewport_set_frame_buffer(this._viewportDepth, this._frameBufferDepth);
    _wr_viewport_set_camera(this._viewportDepth, _wr_viewport_get_camera(viewport));
  }
}class MouseEvents {
  constructor(scene, domElement, mobileDevice) {
    this._scene = scene;
    this._domElement = domElement;
    this._mobileDevice = mobileDevice;

    this._state = {
      'initialized': false,
      'mouseDown': 0,
      'moved': false,
      'wheelFocus': false,
      'wheelTimeout': null
    };
    this._moveParams = {};
    this._enableNavigation = true;

    this.onmousemove = (event) => { this._onMouseMove(event); };
    this.onmouseup = (event) => { this._onMouseUp(event); };
    this.ontouchmove = (event) => { this._onTouchMove(event); };
    this.ontouchend = (event) => { this._onTouchEnd(event); };
    this._domElement.addEventListener('mousedown', (event) => { this._onMouseDown(event); }, false);
    this._domElement.addEventListener('mouseover', (event) => { this._onMouseOver(event); }, false);
    this._domElement.addEventListener('mouseleave', (event) => { this.onMouseLeave(event); }, false);
    this._domElement.addEventListener('wheel', (event) => { this._onMouseWheel(event); }, false);
    this._domElement.addEventListener('touchstart', (event) => { this._onTouchStart(event); }, true);
    this._domElement.addEventListener('contextmenu', (event) => { event.preventDefault(); }, false);
    this._domElement.addEventListener('mousemove', () => this._detectImmobility());
    // Prevent '#playerDiv' to raise the context menu of the browser.
    // This bug has been seen on Windows 10 / Firefox only.
    this._domElement.parentNode.addEventListener('contextmenu', (event) => { event.preventDefault(); }, false);
  }

  init() {
    if (typeof this.picker === 'undefined')
      this.picker = new WbWrenPicker();
  }

  _onMouseDown(event) {
    if (typeof WbWorld.instance === 'undefined')
      return;

    this.init();

    this._state.wheelFocus = true;
    this._initMouseMove(event);
    switch (event.button) {
      case MouseEvents.Click.RIGHT_CLICK:
        this._state.mouseDown |= 1;
        break;
      case MouseEvents.Click.LEFT_CLICK:
        this._state.mouseDown |= 4;
        break;
      case MouseEvents.Click.WHEEL_CLICK:
        this._state.mouseDown |= 2;
        break;
    }
    if (SystemInfo.isMacOS() && 'ctrlKey' in event && event['ctrlKey'] && this._state.mouseDown === 1)
      // On macOS, "Ctrl + left click" should be dealt as a right click.
      this._state.mouseDown = 2;

    if (this._state.mouseDown !== 0) {
      this._state.initialX = event.clientX;
      this._state.initialY = event.clientY;
      document.addEventListener('mousemove', this.onmousemove, false);
      document.addEventListener('mouseup', this.onmouseup, false);
    }

    if (typeof webots.currentView.onmousedown === 'function')
      webots.currentView.onmousedown(event);

    let pos = MouseEvents.convertMouseEventPositionToRelativePosition(canvas, this._state.x, this._state.y);
    this.picker.pick(pos.x, pos.y);
  }

  _onMouseMove(event) {
    if (typeof WbWorld.instance === 'undefined')
      return;

    if (!this._enableNavigation && event.button === 0) {
      if (typeof webots.currentView.onmousemove === 'function')
        webots.currentView.onmousemove(event);
      return;
    }

    if (typeof this._state.x === 'undefined')
      // mousedown event has not been called yet.
      // This could happen for example when another application has focus while loading the scene.
      return;
    if ('buttons' in event)
      this._state.mouseDown = event.buttons;
    else if ('which' in event) { // Safari only
      switch (event.which) {
        case 0: this._state.mouseDown = 0; break;
        case 1: this._state.mouseDown = 1; break;
        case 2: this._state.pressedButton = 4; break;
        case 3: this._state.pressedButton = 2; break;
        default: this._state.pressedButton = 0; break;
      }
    }
    if (SystemInfo.isMacOS() && 'ctrlKey' in event && event['ctrlKey'] && this._state.mouseDown === 1)
      // On macOS, "Ctrl + left click" should be dealt as a right click.
      this._state.mouseDown = 2;

    if (this._state.mouseDown === 0)
      return;

    if (this._state.initialTimeStamp === null)
      // Prevent applying mouse move action before drag initialization in mousedrag event.
      return;

    this._moveParams.dx = event.clientX - this._state.x;
    this._moveParams.dy = event.clientY - this._state.y;

    let orientation = WbWorld.instance.viewpoint.orientation;
    let position = WbWorld.instance.viewpoint.position;

    let rotationCenter = new WbVector3((this.picker.coordinates.x / canvas.width) * 2 - 1, (this.picker.coordinates.y / canvas.height) * 2 - 1, this.picker.coordinates.z);
    rotationCenter = WbWorld.instance.viewpoint.toWorld(rotationCenter);
    rotationCenter = glm.vec3(rotationCenter.x, rotationCenter.y, rotationCenter.z);

    if (this._state.mouseDown === 1) { // left mouse button to rotate viewpoint
      let halfPitchAngle = -0.005 * this._moveParams.dy;
      let halfYawAngle = -0.005 * this._moveParams.dx;
      if (this.picker.selectedId === -1) {
        halfPitchAngle /= -8;
        halfYawAngle /= -8;
      }
      let sinusYaw = Math.sin(halfYawAngle);
      let sinusPitch = Math.sin(halfPitchAngle);
      let pitch = right(orientation);
      let pitchRotation = glm.quat(Math.cos(halfPitchAngle), sinusPitch * pitch.x, sinusPitch * pitch.y, sinusPitch * pitch.z);
      let worldUpVector = WbWorld.instance.upVector;
      let yawRotation = glm.quat(Math.cos(halfYawAngle), sinusYaw * worldUpVector.x, sinusYaw * worldUpVector.y, sinusYaw * worldUpVector.z);

      // Updates camera's position and orientation
      let deltaRotation = yawRotation.mul(pitchRotation);
      let currentPosition = deltaRotation.mul(glm.vec3(position.x, position.y, position.z).sub(rotationCenter)).add(rotationCenter);
      let currentOrientation = deltaRotation.mul(vec4ToQuaternion(orientation));
      WbWorld.instance.viewpoint.position = new WbVector3(currentPosition.x, currentPosition.y, currentPosition.z);
      WbWorld.instance.viewpoint.orientation = quaternionToVec4(currentOrientation);
      WbWorld.instance.viewpoint.updatePosition();
      WbWorld.instance.viewpoint.updateOrientation();
      this._scene.render();
    } else {
      let distanceToPickPosition = 0.001;
      if (this.picker.selectedId !== -1)
        distanceToPickPosition = length(position.sub(rotationCenter));
      else
        distanceToPickPosition = length(position);

      if (distanceToPickPosition < 0.001)
        distanceToPickPosition = 0.001;

      let scaleFactor = distanceToPickPosition * 2 * Math.tan(WbWorld.instance.viewpoint.fieldOfView / 2) / Math.max(canvas.width, canvas.height);

      if (this._state.mouseDown === 2) { // right mouse button to translate viewpoint
        let targetRight = -scaleFactor * this._moveParams.dx;
        let targetUp = scaleFactor * this._moveParams.dy;
        let upVec = up(orientation);
        let rightVec = right(orientation);
        let targetR = rightVec.mul(targetRight);
        let targetU = upVec.mul(targetUp);
        let target = targetR.add(targetU);
        WbWorld.instance.viewpoint.position = position.add(target);
        WbWorld.instance.viewpoint.updatePosition();
        this._scene.render();
      } else if (this._state.mouseDown === 3 || this._state.mouseDown === 4) { // both left and right button or middle button to zoom
        let rollVector = direction(orientation);
        let zDisplacement = rollVector.mul(scaleFactor * 5 * this._moveParams.dy);
        let roll2 = fromAxisAngle(rollVector.x, rollVector.y, rollVector.z, 0.01 * this._moveParams.dx);
        let roll3 = glm.quat();
        roll3.w = roll2.w;
        roll3.x = roll2.x;
        roll3.y = roll2.y;
        roll3.z = roll2.z;

        WbWorld.instance.viewpoint.position = position.add(zDisplacement);
        WbWorld.instance.viewpoint.orientation = quaternionToVec4(roll3.mul(vec4ToQuaternion(orientation)));
        WbWorld.instance.viewpoint.updatePosition();
        WbWorld.instance.viewpoint.updateOrientation();

        this._scene.render();
      }
    }
    this._state.moved = event.clientX !== this._state.x || event.clientY !== this._state.y;
    this._state.x = event.clientX;
    this._state.y = event.clientY;

    if (typeof webots.currentView.onmousemove === 'function')
      webots.currentView.onmousemove(event);
    if (typeof webots.currentView.onmousedrag === 'function')
      webots.currentView.onmousedrag(event);
  }

  _onMouseUp(event) {
    this._clearMouseMove();
    this._selectAndHandleClick();

    document.removeEventListener('mousemove', this.onmousemove, false);
    document.removeEventListener('mouseup', this.onmouseup, false);

    if (typeof webots.currentView.onmouseup === 'function')
      webots.currentView.onmouseup(event);
  }

  _onMouseWheel(event) {
    if (typeof WbWorld.instance === 'undefined')
      return;

    this.init();
    this._detectImmobility();

    event.preventDefault(); // do not scroll page

    if (!this._enableNavigation || this._state.wheelFocus === false) {
      let offset = event.deltaY;
      if (event.deltaMode === 1)
        offset *= 40; // standard line height in pixel
      window.scroll(0, window.pageYOffset + offset);
      if (this._state.wheelTimeout) { // you have to rest at least 1.5 seconds over the x3d canvas
        clearTimeout(this._state.wheelTimeout); // so that the wheel focus will get enabled and
        this._state.wheelTimeout = setTimeout((event) => { this._wheelTimeoutCallback(event); }, 1500); // allow you to zoom in/out.
      }
      return;
    }

    let distanceToPickPosition;
    let position = WbWorld.instance.viewpoint.position;

    let rotationCenter = new WbVector3((this.picker.coordinates.x / canvas.width) * 2 - 1, (this.picker.coordinates.y / canvas.height) * 2 - 1, this.picker.coordinates.z);
    rotationCenter = WbWorld.instance.viewpoint.toWorld(rotationCenter);
    rotationCenter = glm.vec3(rotationCenter.x, rotationCenter.y, rotationCenter.z);

    if (this.picker.selectedId !== -1)
      distanceToPickPosition = length(position.sub(rotationCenter));
    else
      distanceToPickPosition = length(position);

    if (distanceToPickPosition < 0.001)
      distanceToPickPosition = 0.001;

    let direct = direction(WbWorld.instance.viewpoint.orientation);
    const scaleFactor = 0.02 * (event.deltaY < 0.0 ? -1 : 1) * distanceToPickPosition;
    const zDisplacement = direct.mul(scaleFactor);
    WbWorld.instance.viewpoint.position = position.add(zDisplacement);
    WbWorld.instance.viewpoint.updatePosition();

    this._scene.render();
  }

  _wheelTimeoutCallback(event) {
    this._state.wheelTimeout = null;
    this._state.wheelFocus = true;
  }

  _onMouseOver(event) {
    this._state.wheelTimeout = setTimeout((event) => { this._wheelTimeoutCallback(event); }, 1500);

    if (typeof this.showPlayBar !== 'undefined')
      this.showPlayBar();
  }

  onMouseLeave(event) {
    clearTimeout(this._moveTimeout);

    if (typeof event !== 'undefined' && event.relatedTarget != null &&
      event.relatedTarget.id === 'time-slider')
      return;

    if (this._state.wheelTimeout != null) {
      clearTimeout(this._state.wheelTimeout);
      this._state.wheelTimeout = null;
    }

    this._state.wheelFocus = false;

    if (typeof webots.currentView.onmouseleave === 'function')
      webots.currentView.onmouseleave(event);

    if (typeof this.hidePlayBar !== 'undefined')
      this.hidePlayBar();
  }

  _onTouchMove(event) {
    if (typeof WbWorld.instance === 'undefined')
      return;

    if (!this._enableNavigation || event.targetTouches.length === 0 || event.targetTouches.length > 2)
      return;
    if (this._state.initialTimeStamp === null)
      // Prevent applying mouse move action before drag initialization in mousedrag event.
      return;
    if ((this._state.mouseDown !== 2) !== (event.targetTouches.length > 1))
      // Gesture single/multi touch changed after initialization.
      return;

    const touch = event.targetTouches['0'];
    const x = Math.round(touch.clientX); // discard decimal values returned on android
    const y = Math.round(touch.clientY);
    let orientation = WbWorld.instance.viewpoint.orientation;
    let position = WbWorld.instance.viewpoint.position;

    let rotationCenter = new WbVector3((this.picker.coordinates.x / canvas.width) * 2 - 1, (this.picker.coordinates.y / canvas.height) * 2 - 1, this.picker.coordinates.z);
    rotationCenter = WbWorld.instance.viewpoint.toWorld(rotationCenter);
    rotationCenter = glm.vec3(rotationCenter.x, rotationCenter.y, rotationCenter.z);
    let distanceToPickPosition = 0.001;
    if (this.picker.selectedId !== -1)
      distanceToPickPosition = length(position.sub(rotationCenter));
    else
      distanceToPickPosition = length(position);

    if (distanceToPickPosition < 0.001)
      distanceToPickPosition = 0.001;

    let scaleFactor = distanceToPickPosition * 2 * Math.tan(WbWorld.instance.viewpoint.fieldOfView / 2) / Math.max(canvas.width, canvas.height);

    if (this._state.mouseDown === 2) { // translation
      this._moveParams.dx = x - this._state.x;
      this._moveParams.dy = y - this._state.y;

      // On small phone screens (Android) this is needed to correctly detect clicks and longClicks.
      if (this._state.initialX == null && this._state.initialY == null) {
        this._state.initialX = Math.round(this._state.x);
        this._state.initialY = Math.round(this._state.y);
      }
      if (Math.abs(this._moveParams.dx) < 2 && Math.abs(this._moveParams.dy) < 2 &&
        Math.abs(this._state.initialX - x) < 5 && Math.abs(this._state.initialY - y) < 5)
        this._state.moved = false;
      else
        this._state.moved = true;

      this._moveParams.dx = x - this._state.initialX;
      this._moveParams.dy = y - this._state.initialY;

      let targetRight = -scaleFactor * this._moveParams.dx;
      let targetUp = scaleFactor * this._moveParams.dy;
      let upVec = up(orientation);
      let rightVec = right(orientation);
      let targetR = rightVec.mul(targetRight);
      let targetU = upVec.mul(targetUp);
      let target = targetR.add(targetU);
      WbWorld.instance.viewpoint.position = position.add(target);
      WbWorld.instance.viewpoint.updatePosition();
      this._scene.render();
    } else {
      const touch1 = event.targetTouches['1'];
      const x1 = Math.round(touch1.clientX);
      const y1 = Math.round(touch1.clientY);
      const distanceX = x - x1;
      const distanceY = y - y1;
      const newTouchDistance = distanceX * distanceX + distanceY * distanceY;
      const pinchSize = this._state.touchDistance - newTouchDistance;

      const moveX1 = x - this._state.x;
      const moveX2 = x1 - this._state.x1;
      const moveY1 = y - this._state.y;
      const moveY2 = y1 - this._state.y1;
      const ratio = 1;

      if (Math.abs(pinchSize) > 500 * ratio) { // zoom and tilt
        let d;
        if (Math.abs(moveX2) < Math.abs(moveX1))
          d = moveX1;
        else
          d = moveX2;
        this._moveParams.tiltAngle = 0.0004 * d;
        this._moveParams.zoomScale = this._moveParams.scaleFactor * 0.015 * pinchSize;
        let rollVector = direction(orientation);
        let zDisplacement = rollVector.mul(scaleFactor * 5 * this._moveParams.dy);
        let roll2 = fromAxisAngle(rollVector.x, rollVector.y, rollVector.z, 0.01 * this._moveParams.dx);
        let roll3 = glm.quat();
        roll3.w = roll2.w;
        roll3.x = roll2.x;
        roll3.y = roll2.y;
        roll3.z = roll2.z;

        WbWorld.instance.viewpoint.position = position.add(zDisplacement);
        WbWorld.instance.viewpoint.orientation = quaternionToVec4(roll3.mul(vec4ToQuaternion(orientation)));
        WbWorld.instance.viewpoint.updatePosition();
        WbWorld.instance.viewpoint.updateOrientation();

        this._scene.render();
      } else if (Math.abs(moveY2 - moveY1) < 3 * ratio && Math.abs(moveX2 - moveX1) < 3 * ratio) { // rotation (pitch and yaw)
        this._moveParams.dx = moveX1 * 0.8;
        this._moveParams.dy = moveY1 * 0.5;

        let halfPitchAngle = -0.005 * this._moveParams.dy;
        let halfYawAngle = -0.005 * this._moveParams.dx;
        if (this.picker.selectedId === -1) {
          halfPitchAngle /= -8;
          halfYawAngle /= -8;
        }
        let sinusYaw = Math.sin(halfYawAngle);
        let sinusPitch = Math.sin(halfPitchAngle);
        let pitch = right(orientation);
        let pitchRotation = glm.quat(Math.cos(halfPitchAngle), sinusPitch * pitch.x, sinusPitch * pitch.y, sinusPitch * pitch.z);
        let worldUpVector = WbWorld.instance.upVector;
        let yawRotation = glm.quat(Math.cos(halfYawAngle), sinusYaw * worldUpVector.x, sinusYaw * worldUpVector.y, sinusYaw * worldUpVector.z);

        // Updates camera's position and orientation
        let deltaRotation = yawRotation.mul(pitchRotation);
        let currentPosition = deltaRotation.mul(glm.vec3(position.x, position.y, position.z).sub(rotationCenter)).add(rotationCenter);
        let currentOrientation = deltaRotation.mul(vec4ToQuaternion(orientation));
        WbWorld.instance.viewpoint.position = new WbVector3(currentPosition.x, currentPosition.y, currentPosition.z);
        WbWorld.instance.viewpoint.orientation = quaternionToVec4(currentOrientation);
        WbWorld.instance.viewpoint.updatePosition();
        WbWorld.instance.viewpoint.updateOrientation();
        this._scene.render();
      }

      this._state.touchDistance = newTouchDistance;
      this._state.moved = true;
    }
    this._state.x = x;
    this._state.y = y;
    this._state.x1 = x1;
    this._state.y1 = y1;

    if (typeof webots.currentView.ontouchmove === 'function')
      webots.currentView.ontouchmove(event);
  }

  _onTouchStart(event) {
    if (typeof WbWorld.instance === 'undefined')
      return;

    this.init();
    this._initMouseMove(event.targetTouches['0']);
    if (event.targetTouches.length === 2) {
      const touch1 = event.targetTouches['1'];
      this._state.x1 = touch1.clientX;
      this._state.y1 = touch1.clientY;
      const distanceX = this._state.x - this._state.x1;
      const distanceY = this._state.y - this._state.y1;
      this._state.touchDistance = distanceX * distanceX + distanceY * distanceY;
      this._state.touchOrientation = Math.atan2(this._state.y1 - this._state.y, this._state.x1 - this._state.x);
      this._state.mouseDown = 3; // two fingers: rotation, tilt, zoom
    } else
      this._state.mouseDown = 2; // 1 finger: translation or single click

    this._domElement.addEventListener('touchend', this.ontouchend, true);
    this._domElement.addEventListener('touchmove', this.ontouchmove, true);

    if (typeof webots.currentView.ontouchstart === 'function')
      webots.currentView.ontouchstart(event);
  }

  _onTouchEnd(event) {
    this._clearMouseMove();
    this._selectAndHandleClick();

    this._domElement.removeEventListener('touchend', this.ontouchend, true);
    this._domElement.removeEventListener('touchmove', this.ontouchmove, true);

    if (typeof webots.currentView.ontouchend === 'function')
      webots.currentView.ontouchend(event);
  }

  _initMouseMove(event) {
    this._state.x = event.clientX;
    this._state.y = event.clientY;
    this._state.initialX = null;
    this._state.initialY = null;
    this._state.moved = false;
    this._state.initialTimeStamp = Date.now();
    this._state.longClick = false;
  }

  _clearMouseMove() {
    const timeDelay = this._mobileDevice ? 100 : 1000;
    this._state.longClick = Date.now() - this._state.initialTimeStamp >= timeDelay;
    this._state.previousMouseDown = this._state.mouseDown;
    this._state.mouseDown = 0;
    this._state.initialTimeStamp = null;
    this._state.initialX = null;
    this._state.initialY = null;
    this._moveParams = {};
  }

  _selectAndHandleClick() {
    if (this._state.moved === false && (!this._state.longClick || this._mobileDevice)) {
      Selector.select(this.picker.selectedId);

      if (typeof WbWorld.instance.nodes.get(Selector.selectedId) !== 'undefined')
        WbWorld.instance.nodes.get(Selector.selectedId).updateBoundingObjectVisibility();

      if (typeof WbWorld.instance.nodes.get(Selector.previousId) !== 'undefined')
        WbWorld.instance.nodes.get(Selector.previousId).updateBoundingObjectVisibility();

      this._scene.render();
    }
  }

  _detectImmobility() {
    clearTimeout(this._moveTimeout);
    if (typeof this.showPlayBar !== 'undefined')
      this.showPlayBar();

    this._moveTimeout = setTimeout(() => {
      if (typeof this.hidePlayBar !== 'undefined')
        this.hidePlayBar();
    }, 3000);
  }
}

MouseEvents.convertMouseEventPositionToRelativePosition = (element, eventX, eventY) => {
  const rect = element.getBoundingClientRect();
  const pos = new glm.vec2();
  pos.x = Math.round(eventX - rect.left);
  pos.y = Math.round(eventY - rect.top);
  return pos;
};

MouseEvents.Click = {
  RIGHT_CLICK: 0,
  LEFT_CLICK: 1,
  WHEEL_CLICK: 2
};class MultimediaClient {
  constructor(view, parentObject) {
    this._view = view;
    this._domElement = document.createElement('img');
    this._domElement.style.background = 'white';
    this._domElement.id = 'remoteScene';
    this._domElement.setAttribute('draggable', false);
    parentObject.appendChild(this._domElement);

    this._viewMode = false;
    this._worldInfo = {title: null};

    this._mouseDown = 0;
    this.onmousemove = (e) => { this._onMouseMove(e); };
    this._lastMousePosition = null;
    this._touchEvent = { move: false };
    this.ontouchmove = (e) => { this._onTouchMove(e); };
    this.ontouchend = (e) => { this._onTouchEnd(e); };
  }

  disconnect() {
    this._domElement.src = '';
  }

  finalize(onready) {
    this._domElement.addEventListener('mousedown', (e) => { this._onMouseDown(e); }, false);
    this._domElement.addEventListener('mouseup', (e) => { this._onMouseUp(e); }, false);
    this._domElement.addEventListener('wheel', (e) => { this._onWheel(e); }, false);
    this._domElement.addEventListener('touchstart', (event) => { this._onTouchStart(event); }, true);
    this._domElement.addEventListener('contextmenu', (event) => { event.preventDefault(); }, false);
    this._view.toolBar.enableToolBarButtons(!this._viewMode);
    if (typeof onready === 'function')
      onready();
  }

  setWorldInfo(title) {
    this._worldInfo = {title: title};
  }

  setFollowed(solidId, mode) {
    const socket = this._view.stream.socket;
    if (!socket || socket.readyState !== 1)
      return;
    socket.send('follow: ' + mode + ',' + solidId);
  }

  requestNewSize() {
    if (this._lastWidth === this._domElement.width && this._lastHeight === this._domElement.height)
      return;
    this._view.stream.socket.send('resize: ' + this._domElement.width + 'x' + this._domElement.height);
    this._lastWidth = this._domElement.width;
    this._lastHeight = this._domElement.height;
  }

  resize(width, height) {
    this.requestNewSize();
  }

  processServerMessage(data) {
    if (data.startsWith('multimedia: ')) {
      const list = data.split(' ');
      const httpUrl = 'http' + this._view.stream.wsServer.slice(2); // replace 'ws' with 'http'
      const url = httpUrl + list[1];
      this._view.toolBar.setMode(list[2]);
      this._domElement.src = url;
      this._viewMode = list.length > 4; // client in view mode
      if (this._viewMode) {
        this._domElement.style.width = list[3] + 'px';
        this._domElement.style.height = list[4] + 'px';
      }
      this._view.toolBar.enableToolBarButtons(!this._viewMode);
      console.log('Multimedia streamed on ' + url);
    } else if (data.startsWith('resize: ')) {
      if (this._viewMode) {
        let list = data.split(' ');
        this._domElement.style.width = list[1] + 'px';
        this._domElement.style.height = list[2] + 'px';
      } // else ignore resize triggered from this instance
    } else if (data.startsWith('world info: ')) {
      let dataString = data.substring(data.indexOf(':') + 1).trim();
      let dataObject = JSON.parse(dataString);
      this.setWorldInfo(dataObject.title, dataObject.window);
    } else
      return false;
    return true;
  }

  _onMouseDown(event) {
    if (this._viewMode)
      return false;

    this._mouseDown = 0;
    switch (event.button) {
      case 0: // MOUSE.LEFT
        this._mouseDown |= 1;
        break;
      case 1: // MOUSE.MIDDLE
        this._mouseDown |= 4;
        break;
      case 2: // MOUSE.RIGHT
        this._mouseDown |= 2;
        break;
    }
    if (SystemInfo.isMacOS() && 'ctrlKey' in event && event['ctrlKey'] && this._mouseDown === 1)
      // On macOS, "Ctrl + left click" should be dealt as a right click.
      this._mouseDown = 2;

    event.target.addEventListener('mousemove', this.onmousemove, false);
    this._sendMouseEvent(-1, this._computeRemoteMouseEvent(event), 0);
    event.preventDefault();
    return false;
  }

  _onMouseMove(event) {
    if (this._mouseDown === 0) {
      event.target.removeEventListener('mousemove', this.onmousemove, false);
      return false;
    } else if (event.buttons === 0) {
      // mouse button released outside the 3D scene
      // send a mouse up event to complete the drag
      let mouseUpEvent = this._computeRemoteMouseEvent(event);
      mouseUpEvent.offsetX = this._lastMousePosition.x;
      mouseUpEvent.offsetY = this._lastMousePosition.y;
      event.target.removeEventListener('mousemove', this.onmousemove, false);
      this._sendMouseEvent(1, mouseUpEvent, 0);
      event.preventDefault();
      return false;
    }
    this._sendMouseEvent(0, this._computeRemoteMouseEvent(event), 0);
    return false;
  }

  _onMouseUp(event) {
    if (this._viewMode)
      return;

    event.target.removeEventListener('mousemove', this.onmousemove, false);
    this._sendMouseEvent(1, this._computeRemoteMouseEvent(event), 0);
    event.preventDefault();
    return false;
  }

  _onWheel(event) {
    if (this._viewMode)
      return false;

    this._sendMouseEvent(2, this._computeRemoteMouseEvent(event), Math.sign(event.deltaY));
    return false;
  }

  _onTouchStart(event) {
    if (this._viewMode)
      return;

    this._mouseDown = 0;
    let touch0 = event.targetTouches['0'];
    this._touchEvent.x = Math.round(touch0.clientX); // discard decimal values returned on android
    this._touchEvent.y = Math.round(touch0.clientY);
    if (event.targetTouches.length === 2) {
      const touch1 = event.targetTouches['1'];
      this._touchEvent.x1 = touch1.clientX;
      this._touchEvent.y1 = touch1.clientY;
      const distanceX = this._touchEvent.x - this._touchEvent.x1;
      const distanceY = this._touchEvent.y - this._touchEvent.y1;
      this._touchEvent.distance = distanceX * distanceX + distanceY * distanceY;
      this._touchEvent.orientation = Math.atan2(this._touchEvent.y1 - this._touchEvent.y, this._touchEvent.x1 - this._touchEvent.x);
      this._mouseDown = 3; // two fingers: rotation, tilt, zoom
    } else
      this._mouseDown = 2; // 1 finger: translation or single click

    event.target.addEventListener('touchend', this.ontouchend, true);
    event.target.addEventListener('touchmove', this.ontouchmove, true);

    if (typeof webots.currentView.ontouchstart === 'function')
      webots.currentView.ontouchstart(event);

    this._touchEvent.initialTimeStamp = Date.now();
    this._touchEvent.moved = false;
    this._touchEvent.initialX = null;
    this._touchEvent.initialY = null;
    this._touchEvent.mode = undefined;
    this._lastTouchEvent = this._computeTouchEvent(event);
    this._sendMouseEvent(-1, this._lastTouchEvent, 2);
    event.preventDefault();
    return false;
  }

  _onTouchMove(event) {
    if (this._viewMode || event.targetTouches.length === 0 || event.targetTouches.length > 2)
      return false;
    if (typeof this._touchEvent.initialTimeStamp === 'undefined')
      // Prevent applying mouse move action before drag initialization in mousedrag event.
      return;
    if ((typeof this._touchEvent.mode !== 'undefined') && (this._mouseDown !== 3))
      // Gesture single/multi touch changed after initialization.
      return false;

    let touch0 = event.targetTouches['0'];
    let x = Math.round(touch0.clientX); // discard decimal values returned on android
    let y = Math.round(touch0.clientY);
    let dx = x - this._touchEvent.x;
    let dy = y - this._touchEvent.y;

    if (this._mouseDown === 2) { // translation
      // On small phone screens (Android) this is needed to correctly detect clicks and longClicks.
      if (this._touchEvent.initialX == null && this._touchEvent.initialY == null) {
        this._touchEvent.initialX = Math.round(this._touchEvent.x);
        this._touchEvent.initialY = Math.round(this._touchEvent.y);
      }
      if (Math.abs(dx) < 2 && Math.abs(dy) < 2 &&
        Math.abs(this._touchEvent.initialX - x) < 5 && Math.abs(this._touchEvent.initialY - y) < 5)
        this._touchEvent.moved = false;

      else
        this._touchEvent.moved = true;

      this._lastTouchEvent = this._computeTouchEvent(event);
      if (this._touchEvent.moved)
        this._sendMouseEvent(0, this._lastTouchEvent, 2);
    } else {
      let touch1 = event.targetTouches['1'];
      let x1 = Math.round(touch1.clientX);
      let y1 = Math.round(touch1.clientY);
      let distanceX = x - x1;
      let distanceY = y - y1;
      let newTouchDistance = distanceX * distanceX + distanceY * distanceY;
      let pinchSize = this._touchEvent.distance - newTouchDistance;

      let moveX1 = x - this._touchEvent.x;
      let moveX2 = x1 - this._touchEvent.x1;
      let moveY1 = y - this._touchEvent.y;
      let moveY2 = y1 - this._touchEvent.y1;
      let ratio = window.devicePixelRatio || 1;

      // Initialize multi-touch gesture.
      if (typeof this._touchEvent.mode === 'undefined') {
        if (Date.now() - this._touchEvent.initialTimeStamp < 100)
          // Wait some ms to be able to detect the gesture.
          return;
        if (Math.abs(pinchSize) > 500 * ratio) { // zoom and tilt
          this._mouseDown = 3;
          this._touchEvent.mode = 2;
        } else if (Math.abs(moveY2 - moveY1) < 3 * ratio && Math.abs(moveX2 - moveX1) < 3 * ratio) { // rotation (pitch and yaw)
          this._mouseDown = 3;
          this._touchEvent.mode = 1;
        } else
          return;

        if (typeof this._touchEvent.mode !== 'undefined')
          // send rotation/zoom picked position
          this._sendMessage('touch -1 ' + this._touchEvent.mode + ' ' + x + ' ' + y);
      } else if (this._touchEvent.mode === 2) {
        let d;
        if (Math.abs(moveX2) < Math.abs(moveX1))
          d = moveX1;
        else
          d = moveX2;
        let tiltAngle = 0.0004 * d;
        let zoomScale = 0.015 * pinchSize;
        this._sendMessage('touch 0 ' + this._touchEvent.mode + ' ' + tiltAngle + ' ' + zoomScale);
      } else { // rotation
        dx = moveX1 * 0.8;
        dy = moveY1 * 0.5;
        this._sendMessage('touch 0 ' + this._touchEvent.mode + ' ' + dx + ' ' + dy);
      }

      this._touchEvent.moved = true;
      this._touchEvent.distance = newTouchDistance;
      this._touchEvent.x1 = x1;
      this._touchEvent.y1 = y1;
    }

    this._touchEvent.x = x;
    this._touchEvent.y = y;

    if (typeof webots.currentView.ontouchmove === 'function')
      webots.currentView.ontouchmove(event);
    event.preventDefault();
    return false;
  }

  _onTouchEnd(event) {
    if (this._viewMode)
      return false;

    this._domElement.removeEventListener('touchend', this.ontouchend, true);
    this._domElement.removeEventListener('touchmove', this.ontouchmove, true);

    if (typeof webots.currentView.ontouchend === 'function')
      webots.currentView.ontouchend(event);

    if (typeof this._lastTouchEvent === 'undefined') {
      this._touchEvent.initialTimeStamp = undefined;
      event.preventDefault();
      return false;
    }

    if (typeof this._touchEvent.mode === 'undefined') {
      let longClick = Date.now() - this._touchEvent.initialTimeStamp >= 100;
      if (this._touchEvent.move === false && !longClick) {
        // A single short click corresponds to left click to select items.
        this._lastTouchEvent.button = 0;
        this._lastTouchEvent.buttons = 1;
        this._sendMouseEvent(-1, this._lastTouchEvent, longClick);
      }
      this._sendMouseEvent(1, this._lastTouchEvent, longClick);
    }
    this._lastTouchEvent = undefined;
    this._touchEvent.initialTimeStamp = undefined;
    this._touchEvent.move = false;
    this._touchEvent.mode = undefined;
    event.preventDefault();
    return false;
  }

  _computeRemoteMouseEvent(event) {
    let remoteEvent = {};
    remoteEvent.button = event.button;
    remoteEvent.buttons = this._mouseDown;
    remoteEvent.modifier = (event.shiftKey ? 1 : 0) + (event.ctrlKey ? 2 : 0) + (event.altKey ? 4 : 0);
    remoteEvent.offsetX = event.offsetX;
    remoteEvent.offsetY = event.offsetY;
    return remoteEvent;
  }

  _computeTouchEvent(event, move) {
    let remoteEvent = {};
    remoteEvent.buttons = this._mouseDown;
    remoteEvent.modifier = 0; // disabled
    const touch = event.targetTouches['0'];
    remoteEvent.offsetX = Math.round(touch.clientX); // discard decimal values returned on android
    remoteEvent.offsetY = Math.round(touch.clientY);

    if (this._touchEvent.mode === 3) // zoom/tilt
      remoteEvent.button = 3;
    else if (this._touchEvent.mode === 1) // rotation
      remoteEvent.button = 1;
    else
      remoteEvent.button = 2; // 1 finger: translation or single click

    // Adjust touch point coordinates so that they are local to the remote scene.
    remoteEvent.offsetX -= this._domElement.x;
    remoteEvent.offsetY -= this._domElement.y;
    return remoteEvent;
  }

  _sendMessage(message) {
    let socket = this._view.stream.socket;
    if (!socket || socket.readyState !== 1)
      return;
    socket.send(message);
  }

  _sendMouseEvent(type, event, wheel) {
    this._sendMessage('mouse ' + type + ' ' + event.button + ' ' + event.buttons + ' ' +
                event.offsetX + ' ' + event.offsetY + ' ' + event.modifier + ' ' + wheel);
    this._lastMousePosition = {x: event.offsetX, y: event.offsetY};
  }
}class Toolbar {
  constructor(parent, view) {
    this._view = view;

    this.domElement = document.createElement('div');
    this.domElement.id = 'toolBar';

    this.domElement.left = document.createElement('div');
    this.domElement.left.className = 'toolBarLeft';

    if (typeof webots.showQuit === 'undefined' || webots.showQuit) { // enabled by default
      this.domElement.left.appendChild(this._createToolBarButton('quit', 'Quit the simulation'));
      this.quitButton.onclick = () => { this._view.quitSimulation(); };
    }

    this._worldSelectionDiv = document.createElement('div');
    this._worldSelectionDiv.id = 'worldSelectionDiv';
    this.domElement.left.appendChild(this._worldSelectionDiv);

    if (webots.showRevert) { // disabled by default
      this.domElement.left.appendChild(this._createToolBarButton('revert', 'Revert the simulation'));
      this.revertButton.addEventListener('click', () => { this.reset(true); });
    }

    this.domElement.left.appendChild(this._createToolBarButton('reset', 'Reset the simulation'));
    this.resetButton.addEventListener('click', () => { this.reset(false); });

    this.domElement.left.appendChild(this._createToolBarButton('step', 'Perform one simulation step'));
    this.stepButton.onclick = () => { this.step(); };

    this.domElement.left.appendChild(this._createToolBarButton('real_time', 'Run the simulation in real time'));
    this.real_timeButton.onclick = () => { this.realTime(); };

    this.domElement.left.appendChild(this._createToolBarButton('pause', 'Pause the simulation'));
    this.pauseButton.onclick = () => { this.pause(); };
    this.pauseButton.style.display = 'none';

    if (webots.showRun) { // disabled by default
      this.domElement.left.appendChild(this._createToolBarButton('run', 'Run the simulation as fast as possible'));
      this.runButton.onclick = () => { this.run(); };
    }

    const div = document.createElement('div');
    div.className = 'webotsTime';
    const clock = document.createElement('span');
    clock.id = 'webotsClock';
    clock.title = 'Current simulation time';
    clock.innerHTML = webots.parseMillisecondsIntoReadableTime(0);
    div.appendChild(clock);
    const timeout = document.createElement('span');
    timeout.id = 'webotsTimeout';
    timeout.title = 'Simulation time out';
    timeout.innerHTML = webots.parseMillisecondsIntoReadableTime(this._view.timeout >= 0 ? this._view.timeout : 0);
    div.appendChild(document.createElement('br'));
    div.appendChild(timeout);
    this.domElement.left.appendChild(div);

    this.domElement.right = document.createElement('div');
    this.domElement.right.className = 'toolBarRight';

    if (this._view.fullscreenEnabled) {
      this.domElement.right.appendChild(this._createToolBarButton('exit_fullscreen', 'Exit fullscreen'));
      this.exit_fullscreenButton.onclick = () => { exitFullscreen(); };
      this.exit_fullscreenButton.style.display = 'none';
      this.domElement.right.appendChild(this._createToolBarButton('fullscreen', 'Enter fullscreen'));
      this.fullscreenButton.onclick = () => { requestFullscreen(this._view); };
    }

    this.domElement.appendChild(this.domElement.left);
    this.domElement.appendChild(this.domElement.right);
    parent.appendChild(this.domElement);

    this.enableToolBarButtons(false);
    if (this._view.broadcast && this.quitButton) {
      this.quitButton.disabled = true;
      this.quitButton.classList.add('toolBarButtonDisabled');
    }

    document.addEventListener('fullscreenchange', () => { onFullscreenChange(this.fullscreenButton, this.exit_fullscreenButton); });
    document.addEventListener('webkitfullscreenchange', () => { onFullscreenChange(this.fullscreenButton, this.exit_fullscreenButton); });
    document.addEventListener('mozfullscreenchange', () => { onFullscreenChange(this.fullscreenButton, this.exit_fullscreenButton); });
    document.addEventListener('MSFullscreenChange', () => { onFullscreenChange(this.fullscreenButton, this.exit_fullscreenButton); });
  }

  reset(revert = false) {
    if (this._view.broadcast)
      return;
    this.time = 0; // reset time to correctly compute the initial deadline
    if (document.getElementById('webotsProgressMessage')) {
      if (revert)
        document.getElementById('webotsProgressMessage').innerHTML = 'Reverting simulation...';
      else
        document.getElementById('webotsProgressMessage').innerHTML = 'Restarting simulation...';
    }
    if (document.getElementById('webotsProgress'))
      document.getElementById('webotsProgress').style.display = 'block';
    this._view.runOnLoad = this.pauseButton.style.display === 'inline';
    this.pause();

    if (this._view.timeout >= 0) {
      this._view.deadline = this._view.timeout;
      document.getElementById('webotsTimeout').innerHTML = webots.parseMillisecondsIntoReadableTime(this._view.timeout);
    } else
      document.getElementById('webotsTimeout').innerHTML = webots.parseMillisecondsIntoReadableTime(0);
    this.enableToolBarButtons(false);
    if (revert)
      this._view.stream.socket.send('revert');
    else
      this._view.stream.socket.send('reset');
  }

  isPaused() {
    return this.real_timeButton.style.display === 'inline';
  }

  pause() {
    if (this._view.broadcast)
      return;
    this._view.stream.socket.send('pause');
  }

  realTime(force) {
    if (this._view.broadcast && !force)
      return;
    this._view.stream.socket.send('real-time:' + this._view.timeout);
    this.pauseButton.style.display = 'inline';
    this.real_timeButton.style.display = 'none';
    if (typeof this.runButton !== 'undefined')
      this.runButton.style.display = 'inline';
  }

  run(force) {
    if (this._view.broadcast && !force)
      return;
    this._view.stream.socket.send('fast:' + this._view.timeout);
    this.pauseButton.style.display = 'inline';
    this.real_timeButton.style.display = 'inline';
    if (typeof this.runButton !== 'undefined')
      this.runButton.style.display = 'none';
  }

  step() {
    if (this._view.broadcast)
      return;
    this.pauseButton.style.display = 'none';
    this.real_timeButton.style.display = 'inline';
    if (typeof this.runButton !== 'undefined')
      this.runButton.style.display = 'inline';
    this._view.stream.socket.send('step');
  }

  enableToolBarButtons(enabled) {
    const buttons = [this.quitButton, this.revertButton, this.resetButton, this.stepButton, this.real_timeButton, this.runButton, this.pauseButton, this.worldSelect];
    for (let i in buttons) {
      if (buttons[i]) {
        if (enabled && (!this._view.broadcast)) {
          buttons[i].disabled = false;
          buttons[i].classList.remove('toolBarButtonDisabled');
        } else {
          buttons[i].disabled = true;
          buttons[i].classList.add('toolBarButtonDisabled');
        }
      }
    }

    if (typeof this.worldSelect !== 'undefined')
      this.worldSelect.disabled = !enabled;
  }

  _createToolBarButton(name, tooltip) {
    const buttonName = name + 'Button';
    this[buttonName] = document.createElement('button');
    this[buttonName].id = buttonName;
    this[buttonName].className = 'toolBarButton';
    this[buttonName].title = tooltip;
    this[buttonName].style.backgroundImage = 'url(' + DefaultUrl.wwiImagesUrl() + name + '.png)';
    return this[buttonName];
  }

  deleteWorldSelect() {
    this._worldSelectionDiv.removeChild(this.worldSelect);
    this.worldSelect = undefined;
  }

  createWorldSelect() {
    this.worldSelect = document.createElement('select');
    this.worldSelect.id = 'worldSelection';
    this.worldSelect.classList.add('select-css');
    this._worldSelectionDiv.appendChild(this.worldSelect);

    // check if toolbar buttons are disabled
    if (this.real_timeButton && this.real_timeButton.disabled)
      this.worldSelect.disabled = true;
  }

  setMode(mode) {
    const runEnabled = typeof this.runButton !== 'undefined';
    if (mode === 'pause') {
      this.pauseButton.style.display = 'none';
      this.real_timeButton.style.display = 'inline';
      if (runEnabled)
        this.runButton.style.display = 'inline';
      return;
    }

    this.pauseButton.style.display = 'inline';
    if (runEnabled && (mode === 'run' || mode === 'fast')) {
      this.runButton.style.display = 'none';
      this.real_timeButton.style.display = 'inline';
    } else {
      if (runEnabled)
        this.runButton.style.display = 'inline';
      this.real_timeButton.style.display = 'none';
    }
  }
}class Stream {
  constructor(wsServer, view, onready) {
    this.wsServer = wsServer + '/';
    this._view = view;
    this._onready = onready;
    this.socket = null;
  }

  connect() {
    this.socket = new WebSocket(this.wsServer);
    if (document.getElementById('webotsProgressMessage'))
      document.getElementById('webotsProgressMessage').innerHTML = 'Connecting to Webots instance...';
    this.socket.onopen = (event) => { this._onSocketOpen(event); };
    this.socket.onmessage = (event) => { this._onSocketMessage(event); };
    this.socket.onclose = (event) => { this._onSocketClose(event); };
    this.socket.onerror = (event) => {
      this._view.destroyWorld();
      this._view.onerror('WebSocket error: ' + event.data);
    };
  }

  close() {
    if (this.socket)
      this.socket.close();
  }

  _onSocketOpen(event) {
    let mode = this._view.mode;
    if (mode === 'mjpeg')
      mode += ': ' + this._view.view3D.offsetWidth + 'x' + (this._view.view3D.offsetHeight - 48); // subtract toolbar height

    else if (this._view.broadcast)
      mode += ';broadcast';
    this.socket.send(mode);
  }

  _onSocketClose(event) {
    this._view.onerror('Disconnected from ' + this.wsServer + ' (' + event.code + ')');
    if ((event.code > 1001 && event.code < 1016) || (event.code === 1001 && this._view.quitting === false)) { // https://tools.ietf.org/html/rfc6455#section-7.4.1
      if (window.confirm(`Streaming server error
      Connection closed abnormally. (Error code:` + event.code + `)
      The simulation is going to be reset`))
        window.open(window.location.href, '_self');
    }
    this._view.destroyWorld();
    if (typeof this._view.onclose === 'function')
      this._view.onclose();
  }

  _onSocketMessage(event) {
    let data = event.data;
    if (data.startsWith('robot:') || data.startsWith('robot window:'))
      return 0; // We need to keep this condition, otherwise the robot window messages will be printed as errors.
    else if (data.startsWith('stdout:')) {
      this._view.onstdout(data.substring('stdout:'.length));
      return 0;
    } else if (data.startsWith('stderr:')) {
      this._view.onstderr(data.substring('stderr:'.length));
      return 0
    } else if (data.startsWith('world:')) {
      data = data.substring(data.indexOf(':') + 1).trim();
      let currentWorld = data.substring(0, data.indexOf(':')).trim();
      data = data.substring(data.indexOf(':') + 1).trim();
      this._view.updateWorldList(currentWorld, data.split(';'));
    } else if (data.startsWith('pause:') || data === 'paused by client') {
      if (this._view.toolBar !== null)
        this._view.toolBar.setMode('pause');
      // Update timeout.
      if (data.startsWith('pause:')) {
        this._view.isAutomaticallyPaused = undefined;
        this._view.time = parseFloat(data.substring(data.indexOf(':') + 1).trim());
      }
      if (this._view.timeout > 0 && !this._view.isAutomaticallyPaused) {
        this._view.deadline = this._view.timeout;
        if (typeof this._view.time !== 'undefined')
          this._view.deadline += this._view.time;

        if (document.getElementById('webotsTimeout'))
          document.getElementById('webotsTimeout').innerHTML = webots.parseMillisecondsIntoReadableTime(this._view.deadline);
      }
    } else if (data === 'real-time' || data === 'run' || data === 'fast') {
      if (this._view.toolBar) {
        this._view.toolBar.setMode(data);
        this._view.runOnLoad = data;
      } else
      if (this._view.timeout >= 0)
        this.socket.send('timeout:' + this._view.timeout);
    } else if (data.startsWith('loading:')) {
      if (document.getElementById('webotsProgress'))
        document.getElementById('webotsProgress').style.display = 'block';
      data = data.substring(data.indexOf(':') + 1).trim();
      let loadingStatus = data.substring(0, data.indexOf(':')).trim();
      data = data.substring(data.indexOf(':') + 1).trim();
      if (document.getElementById('webotsProgressMessage'))
        document.getElementById('webotsProgressMessage').innerHTML = 'Webots: ' + loadingStatus;
      if (document.getElementById('webotsProgressPercent'))
        document.getElementById('webotsProgressPercent').innerHTML = '<progress value="' + data + '" max="100"></progress>';
    } else if (data === 'scene load completed') {
      this._view.time = 0;
      if (document.getElementById('webotsClock'))
        document.getElementById('webotsClock').innerHTML = webots.parseMillisecondsIntoReadableTime(0);
      if (this._view.mode === 'mjpeg') {
        if (document.getElementById('webotsProgress'))
          document.getElementById('webotsProgress').style.display = 'none';
        this._view.multimediaClient.requestNewSize(); // To force the server to render once
      }

      if (typeof this._onready === 'function')
        this._onready();
    } else if (data === 'reset finished') {
      this._view.resetSimulation();
      if (typeof this._view.x3dScene !== 'undefined' && typeof this._view.multimediaClient === 'undefined')
        this._view.x3dScene.resetViewpoint();
      if (webots.currentView.toolBar)
        webots.currentView.toolBar.enableToolBarButtons(true);
      if (typeof this._onready === 'function')
        this._onready();
    } else if (data.startsWith('time: ')) {
      this._view.time = parseFloat(data.substring(data.indexOf(':') + 1).trim());
      if (document.getElementById('webotsClock'))
        document.getElementById('webotsClock').innerHTML = webots.parseMillisecondsIntoReadableTime(this._view.time);
    } else if (data === 'delete world') {
      this._view.destroyWorld();
      webots.currentView.toolBar.enableToolBarButtons(false);
    } else {
      let messagedProcessed = false;
      if (typeof this._view.multimediaClient !== 'undefined')
        messagedProcessed = this._view.multimediaClient.processServerMessage(data);
      else if (typeof this._view.x3dScene !== 'undefined')
        messagedProcessed = this._view.x3dScene.processServerMessage(data, this._view);
      if (!messagedProcessed)
        console.log('WebSocket error: Unknown message received: "' + data + '"');
    }
  }
}class Server {
  constructor(url, view, onready) {
    this._url = url;
    this._view = view;
    this._onready = onready;
    // url has one of the following form:
    // "ws(s)://cyberbotics1.epfl.ch:80/simple/worlds/simple.wbt", or
    // "wss://cyberbotics1.epfl.ch/1999/session
    //  ?url=webots://github.com/cyberbotics/webots/branch/master/projects/languages/python/worlds/example.wbt"
    const n = this._url.indexOf('/session?url=', 6);
    // 6 is for skipping the "ws(s)://domain" part of the URL which smallest form is 6 characters long: "ws://a"
    if (n === -1) {
      const m = url.lastIndexOf('/');
      this._project = url.substring(this._url.indexOf('/', 6) + 1, m - 7); // e.g., "simple"
      this._worldFile = url.substring(m + 1); // e.g., "simple.wbt"
    } else
      this._repository = this._url.substring(n + 13);
  }

  connect() {
    const n = this._url.indexOf('/session?url=', 6);
    const url = 'http' + (n > 0 ? this._url.substring(2, n + 8) : this._url.substring(2, this._url.indexOf('/', 6)) + '/session');
    document.getElementById('webotsProgressMessage').innerHTML = 'Connecting to session server...';
    let self = this;
    fetch(url)
      .then(response => response.text())
      .then(function(data) {
        if (data.startsWith('Error:')) {
          document.getElementById('webotsProgress').style.display = 'none';
          let errorMessage = data.substring(6).trim();
          errorMessage = errorMessage.charAt(0).toUpperCase() + errorMessage.substring(1);
          alert('Session server error: ' + errorMessage);
          return;
        }
        self.socket = new WebSocket(data + '/client');
        self.socket.onopen = (event) => {
          self.onOpen(event);
        };
        self.socket.onmessage = (event) => {
          self.onMessage(event);
        };
        self.socket.onclose = (event) => {
          console.log('Disconnected from the Webots server.');
        };
        self.socket.onerror = (event) => {
          console.error('Cannot connect to the simulation server');
        };
      })
      .catch(error => {
        console.error(error);
        document.getElementById('webotsProgress').style.display = 'none';
        alert('Could not connect to session server');
      });
  }

  onOpen(event) {
    if (this._repository) {
      let message = `{"start":{"url":"` + this._repository + `"`;
      if (this._view.mode === 'mjpeg')
        message += ',"mode":"mjpeg"';
      message += '}}';
      this.socket.send(message);
    } else { // legacy format
      const host = location.protocol + '//' + location.host.replace(/^www./, ''); // remove 'www' prefix
      this.socket.send('{ "init" : [ "' + host + '", "' + this._project + '", "' + this._worldFile + '" ] }');
    }
    document.getElementById('webotsProgressMessage').innerHTML = 'Starting simulation...';
  }

  onMessage(event) {
    const message = event.data;
    if (message.indexOf('webots:ws://') === 0 || message.indexOf('webots:wss://') === 0) {
      console.log('received ' + message);
      const url = message.substring(7);
      this._httpServerUrl = url.replace(/ws/, 'http');
      this._view.x3dScene.prefix = this._httpServerUrl + '/';
      this._view.stream = new Stream(url, this._view, this._onready);
      this._view.stream.connect();
    } else if (message.indexOf('controller:') === 0 || message.indexOf('reset controller:') === 0) ; else if (message.indexOf('queue:') === 0)
      console.log('The server is saturated. Queue to wait: ' + message.substring(6) + ' client(s).');
    else if (message === '.') ; else
      console.log('Received an unknown message from the Webots server socket: "' + message + '"');
  }
}const M_PI_4 = 0.78539816339744830962;
const TAN_M_PI_8 = Math.tan(M_PI_4 / 2.0);class WbAbstractAppearance extends WbBaseNode {
  constructor(id, transform) {
    super(id);
    this.textureTransform = transform;
  }

  createWrenObjects() {
    super.createWrenObjects();
    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.createWrenObjects();
  }

  delete() {
    if (typeof this.parent !== 'undefined') {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined') {
        parent.appearance = undefined;
        parent.wrenMaterial = undefined;
        parent.updateAppearance();
      }
    }

    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.delete();

    super.delete();
  }

  preFinalize() {
    super.preFinalize();
    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.preFinalize();
  }

  postFinalize() {
    super.postFinalize();

    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.postFinalize();
  }
}class WbAppearance extends WbAbstractAppearance {
  constructor(id, material, texture, transform) {
    super(id, transform);
    this.material = material;
    this.texture = texture;
  }

  async clone(customID) {
    let material, texture, transform;
    if (typeof this.material !== 'undefined') {
      material = this.material.clone(getAnId());
      material.parent = customID;
      WbWorld.instance.nodes.set(material.id, material);
    }

    if (typeof this.texture !== 'undefined') {
      texture = await this.texture.clone(getAnId());
      texture.parent = customID;
      WbWorld.instance.nodes.set(texture.id, texture);
    }

    if (typeof this.textureTransform !== 'undefined') {
      transform = this.textureTransform.clone(getAnId());
      transform.parent = customID;
      WbWorld.instance.nodes.set(transform.id, transform);
    }

    this.useList.push(customID);
    return new WbAppearance(customID, material, texture, transform);
  }

  createWrenObjects() {
    super.createWrenObjects();
    if (typeof this.material !== 'undefined')
      this.material.createWrenObjects();

    if (typeof this.texture !== 'undefined')
      this.texture.createWrenObjects();
  }

  delete() {
    if (typeof this.material !== 'undefined')
      this.material.delete();

    if (typeof this.texture !== 'undefined')
      this.texture.delete();

    super.delete();
  }

  modifyWrenMaterial(wrenMaterial) {
    if (typeof this.material !== 'undefined') {
      _wr_material_set_default_program(wrenMaterial, WbWrenShaders.phongShader());
      _wr_material_set_stencil_ambient_emissive_program(wrenMaterial, WbWrenShaders.phongStencilAmbientEmissiveShader());
      _wr_material_set_stencil_diffuse_specular_program(wrenMaterial, WbWrenShaders.phongStencilDiffuseSpecularShader());

      this.material.modifyWrenMaterial(wrenMaterial, this.texture && this.texture._wrenTexture);
    } else
      wrenMaterial = WbAppearance.fillWrenDefaultMaterial(wrenMaterial);

    if (this.texture)
      this.texture.modifyWrenMaterial(wrenMaterial, 0, 2);
    else
      _wr_material_set_texture(wrenMaterial, null, 0);

    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.modifyWrenMaterial(wrenMaterial);
    else
      _wr_material_set_texture_transform(wrenMaterial, null);

    return wrenMaterial;
  }

  preFinalize() {
    super.preFinalize();

    if (typeof this.material !== 'undefined')
      this.material.preFinalize();

    if (typeof this.texture !== 'undefined')
      this.texture.preFinalize();
  }

  postFinalize() {
    super.postFinalize();

    if (typeof this.material !== 'undefined')
      this.material.postFinalize();
    if (typeof this.texture !== 'undefined')
      this.texture.postFinalize();
  }

  // Static functions

  static fillWrenDefaultMaterial(wrenMaterial) {
    if (typeof wrenMaterial === 'undefined') {
      _wr_material_delete(wrenMaterial);
      wrenMaterial = _wr_phong_material_new();
    }

    _wr_material_set_default_program(wrenMaterial, WbWrenShaders.defaultShader());

    return wrenMaterial;
  }
}class WbPBRAppearance extends WbAbstractAppearance {
  constructor(id, baseColor, baseColorMap, transparency, roughness, roughnessMap, metalness, metalnessMap,
    IBLStrength, normalMap, normalMapFactor, occlusionMap, occlusionMapStrength, emissiveColor, emissiveColorMap, emissiveIntensity, textureTransform) {
    super(id, textureTransform);

    this.baseColor = baseColor;
    this.baseColorMap = baseColorMap;
    this.transparency = transparency;
    this.roughness = roughness;
    this.roughnessMap = roughnessMap;
    this.metalness = metalness;
    this.metalnessMap = metalnessMap;
    this.IBLStrength = IBLStrength;
    this.normalMap = normalMap;
    this.normalMapFactor = normalMapFactor;
    this.occlusionMap = occlusionMap;
    this.occlusionMapStrength = occlusionMapStrength;
    this.emissiveColor = emissiveColor;
    this.emissiveColorMap = emissiveColorMap;
    this.emissiveIntensity = emissiveIntensity;
  }

  clone(customID) {
    let baseColorMap, roughnessMap, metalnessMap, normalMap, occlusionMap, emissiveColorMap, textureTransform;
    if (typeof this.baseColorMap !== 'undefined') {
      baseColorMap = this.baseColorMap.clone(getAnId());
      baseColorMap.parent = customID;
      baseColorMap.type = 'baseColorMap';
      WbWorld.instance.nodes.set(baseColorMap.id, baseColorMap);
    }

    if (typeof this.roughnessMap !== 'undefined') {
      roughnessMap = this.roughnessMap.clone(getAnId());
      roughnessMap.type = 'roughnessMap';
      roughnessMap.parent = customID;
      WbWorld.instance.nodes.set(roughnessMap.id, roughnessMap);
    }

    if (typeof this.metalnessMap !== 'undefined') {
      metalnessMap = this.metalnessMap.clone(getAnId());
      metalnessMap.type = 'metalnessMap';
      metalnessMap.parent = customID;
      WbWorld.instance.nodes.set(metalnessMap.id, metalnessMap);
    }

    if (typeof this.normalMap !== 'undefined') {
      normalMap = this.normalMap.clone(getAnId());
      normalMap.type = 'normalMap';
      normalMap.parent = customID;
      WbWorld.instance.nodes.set(normalMap.id, normalMap);
    }

    if (typeof this.occlusionMap !== 'undefined') {
      occlusionMap = this.occlusionMap.clone(getAnId());
      occlusionMap.type = 'occlusionMap';
      occlusionMap.parent = customID;
      WbWorld.instance.nodes.set(occlusionMap.id, occlusionMap);
    }

    if (typeof this.emissiveColorMap !== 'undefined') {
      emissiveColorMap = this.emissiveColorMap.clone(getAnId());
      emissiveColorMap.type = 'emissiveColorMap';
      emissiveColorMap.parent = customID;
      WbWorld.instance.nodes.set(emissiveColorMap.id, emissiveColorMap);
    }

    if (typeof this.textureTransform !== 'undefined') {
      textureTransform = this.textureTransform.clone(getAnId());
      textureTransform.parent = customID;
      WbWorld.instance.nodes.set(textureTransform.id, textureTransform);
    }

    this.useList.push(customID);
    return new WbPBRAppearance(customID, this.baseColor, baseColorMap, this.transparency, this.roughness, roughnessMap, this.metalness, metalnessMap,
      this.IBLStrength, normalMap, this.normalMapFactor, occlusionMap, this.occlusionMapStrength, this.emissiveColor, emissiveColorMap, this.emissiveIntensity, textureTransform);
  }

  createWrenObjects() {
    super.createWrenObjects();
    if (typeof this.baseColorMap !== 'undefined')
      this.baseColorMap.createWrenObjects();

    if (typeof this.roughnessMap !== 'undefined')
      this.roughnessMap.createWrenObjects();

    if (typeof this.metalnessMap !== 'undefined')
      this.metalnessMap.createWrenObjects();

    if (typeof this.normalMap !== 'undefined')
      this.normalMap.createWrenObjects();

    if (typeof this.occlusionMap !== 'undefined')
      this.occlusionMap.createWrenObjects();

    if (typeof this.emissiveColorMap !== 'undefined')
      this.emissiveColorMap.createWrenObjects();
  }

  delete() {
    if (this.isPostFinalizeCalled)
      WbPBRAppearance.cInstanceCounter--;

    if (WbPBRAppearance.cInstanceCounter === 0) {
      _wr_texture_delete(WbPBRAppearance.cBrdfTexture);
      WbPBRAppearance.cBrdfTexture = undefined;
    }

    if (typeof this.baseColorMap !== 'undefined')
      this.baseColorMap.delete();

    if (typeof this.roughnessMap !== 'undefined')
      this.roughnessMap.delete();

    if (typeof this.metalnessMap !== 'undefined')
      this.metalnessMap.delete();

    if (typeof this.normalMap !== 'undefined')
      this.normalMap.delete();

    if (typeof this.occlusionMap !== 'undefined')
      this.occlusionMap.delete();

    if (typeof this.emissiveColorMap !== 'undefined')
      this.emissiveColorMap.delete();

    super.delete();
  }

  modifyWrenMaterial(wrenMaterial) {
    if (!wrenMaterial) {
      _wr_material_delete(wrenMaterial);
      wrenMaterial = _wr_pbr_material_new();
    }

    // set up shaders
    _wr_material_set_default_program(wrenMaterial, WbWrenShaders.pbrShader());
    _wr_material_set_stencil_ambient_emissive_program(wrenMaterial, WbWrenShaders.pbrStencilAmbientEmissiveShader());
    _wr_material_set_stencil_diffuse_specular_program(wrenMaterial, WbWrenShaders.pbrStencilDiffuseSpecularShader());

    // apply textures
    if (typeof this.baseColorMap !== 'undefined')
      this.baseColorMap.modifyWrenMaterial(wrenMaterial, 0, 7);

    if (typeof this.roughnessMap !== 'undefined')
      this.roughnessMap.modifyWrenMaterial(wrenMaterial, 1, 7);

    if (typeof this.metalnessMap !== 'undefined')
      this.metalnessMap.modifyWrenMaterial(wrenMaterial, 2, 7);

    const background = WbBackground.instance;
    let backgroundLuminosity = 1.0;
    if (typeof background !== 'undefined') {
      backgroundLuminosity = background.luminosity;

      // irradiance map
      const irradianceCubeTexture = background.irradianceCubeTexture;
      if (typeof irradianceCubeTexture !== 'undefined') {
        _wr_material_set_texture_cubemap(wrenMaterial, irradianceCubeTexture, 0);
        _wr_material_set_texture_cubemap_wrap_r(wrenMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
        _wr_material_set_texture_cubemap_wrap_s(wrenMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
        _wr_material_set_texture_cubemap_wrap_t(wrenMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
        _wr_material_set_texture_cubemap_anisotropy(wrenMaterial, 8, 0);
        _wr_material_set_texture_cubemap_enable_interpolation(wrenMaterial, true, 0);
        _wr_material_set_texture_cubemap_enable_mip_maps(wrenMaterial, true, 0);
      } else
        _wr_material_set_texture_cubemap(wrenMaterial, null, 0);
    } else
      _wr_material_set_texture_cubemap(wrenMaterial, null, 0);

    if (typeof this.normalMap !== 'undefined')
      this.normalMap.modifyWrenMaterial(wrenMaterial, 4, 7);

    if (typeof this.occlusionMap !== 'undefined')
      this.occlusionMap.modifyWrenMaterial(wrenMaterial, 3, 7);

    if (typeof this.emissiveColorMap !== 'undefined')
      this.emissiveColorMap.modifyWrenMaterial(wrenMaterial, 6, 7);

    if (typeof this.textureTransform !== 'undefined')
      this.textureTransform.modifyWrenMaterial(wrenMaterial);
    else
      _wr_material_set_texture_transform(wrenMaterial, null);

    _wr_material_set_texture(wrenMaterial, WbPBRAppearance.cBrdfTexture, 5);
    _wr_material_set_texture_enable_mip_maps(wrenMaterial, false, 5);
    _wr_material_set_texture_enable_interpolation(wrenMaterial, false, 5);

    const baseColorPointer = array3Pointer(this.baseColor.x, this.baseColor.y, this.baseColor.z);
    const emissiveColorPointer = array3Pointer(this.emissiveColor.x, this.emissiveColor.y, this.emissiveColor.z);

    const backgroundColor = new WbVector3(0.0, 0.0, 0.0);

    if (typeof background !== 'undefined') {
      backgroundColor.x = background.skyColor.x;
      backgroundColor.y = background.skyColor.y;
      backgroundColor.z = background.skyColor.z;
    }

    const backgroundColorPointer = array3Pointer(backgroundColor.x, backgroundColor.y, backgroundColor.z);
    // set material properties
    _wr_pbr_material_set_all_parameters(wrenMaterial, backgroundColorPointer, baseColorPointer,
      this.transparency, this.roughness, this.metalness, backgroundLuminosity * this.IBLStrength, this.normalMapFactor,
      this.occlusionMapStrength, emissiveColorPointer, this.emissiveIntensity);

    _free(baseColorPointer);
    _free(emissiveColorPointer);
    _free(backgroundColorPointer);

    return wrenMaterial;
  }

  preFinalize() {
    super.preFinalize();

    if (typeof this.baseColorMap !== 'undefined')
      this.baseColorMap.preFinalize();

    if (typeof this.roughnessMap !== 'undefined')
      this.roughnessMap.preFinalize();

    if (typeof this.metalnessMap !== 'undefined')
      this.metalnessMap.preFinalize();

    if (typeof this.normalMap !== 'undefined')
      this.normalMap.preFinalize();

    if (typeof this.occlusionMap !== 'undefined')
      this.occlusionMap.preFinalize();

    if (typeof this.emissiveColorMap !== 'undefined')
      this.emissiveColorMap.preFinalize();

    if (WbPBRAppearance.cInstanceCounter === 0) {
      const quality = textureQuality;
      const resolution = Math.pow(2, 6 + quality); // 0: 64, 1: 128, 2: 256
      WbPBRAppearance.cBrdfTexture = _wr_texture_cubemap_bake_brdf(WbWrenShaders.iblBrdfBakingShader(), resolution);
    }
    ++WbPBRAppearance.cInstanceCounter;
  }

  postFinalize() {
    super.postFinalize();

    if (typeof this.baseColorMap !== 'undefined')
      this.baseColorMap.postFinalize();

    if (typeof this.roughnessMap !== 'undefined')
      this.roughnessMap.postFinalize();

    if (typeof this.metalnessMap !== 'undefined')
      this.metalnessMap.postFinalize();

    if (typeof this.normalMap !== 'undefined')
      this.normalMap.postFinalize();

    if (typeof this.occlusionMap !== 'undefined')
      this.occlusionMap.postFinalize();

    if (typeof this.emissiveColorMap !== 'undefined')
      this.emissiveColorMap.postFinalize();
  }
}

WbPBRAppearance.cInstanceCounter = 0;class WbBackground extends WbBaseNode {
  constructor(id, skyColor, luminosity, cubeArray, irradianceCubeArray) {
    super(id);
    this.skyColor = skyColor;
    this.luminosity = luminosity;
    this._cubeArray = cubeArray;
    this._irradianceCubeArray = irradianceCubeArray;
  }

  createWrenObjects() {
    super.createWrenObjects();

    let skyboxShaderProgram = WbWrenShaders.skyboxShader();
    this._skyboxMaterial = _wr_phong_material_new();
    this._skyboxRenderable = _wr_renderable_new();
    this._skyboxMesh = _wr_static_mesh_unit_box_new(false);

    _wr_material_set_default_program(this._skyboxMaterial, skyboxShaderProgram);
    _wr_renderable_set_cast_shadows(this._skyboxRenderable, false);
    _wr_renderable_set_receive_shadows(this._skyboxRenderable, false);
    _wr_renderable_set_mesh(this._skyboxRenderable, this._skyboxMesh);
    _wr_renderable_set_material(this._skyboxRenderable, this._skyboxMaterial, null);
    _wr_renderable_set_drawing_mode(this._skyboxRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_TRIANGLES);
    _wr_renderable_set_face_culling(this._skyboxRenderable, false);

    this._skyboxTransform = _wr_transform_new();
    _wr_transform_attach_child(this._skyboxTransform, this._skyboxRenderable);

    let hdrClearShaderProgram = WbWrenShaders.hdrClearShader();
    this._hdrClearMaterial = _wr_phong_material_new();
    this._hdrClearRenderable = _wr_renderable_new();
    this._hdrClearMesh = _wr_static_mesh_quad_new();

    _wr_material_set_default_program(this._hdrClearMaterial, hdrClearShaderProgram);
    _wr_renderable_set_cast_shadows(this._hdrClearRenderable, false);
    _wr_renderable_set_receive_shadows(this._hdrClearRenderable, false);
    _wr_renderable_set_mesh(this._hdrClearRenderable, this._hdrClearMesh);
    _wr_renderable_set_material(this._hdrClearRenderable, this._hdrClearMaterial, null);
    _wr_renderable_set_drawing_mode(this._hdrClearRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_TRIANGLES);

    this._hdrClearTransform = _wr_transform_new();
    _wr_transform_attach_child(this._hdrClearTransform, this._hdrClearRenderable);

    this._applyColourToWren();
  }

  delete() {
    if (typeof this.parent === 'undefined') {
      const index = WbWorld.instance.sceneTree.indexOf(this);
      WbWorld.instance.sceneTree.splice(index, 1);
    }

    this._destroySkyBox();

    this.skyColor = new WbVector3(0, 0, 0);
    this._applyColourToWren();

    _wr_scene_set_hdr_clear_quad(_wr_scene_get_instance(), null);
    // Delete skybox
    // Shader program is not deleted, a singleton instance is kept in WbWrenShaders
    _wr_node_delete(this._skyboxRenderable);

    if (typeof this._skyboxMaterial !== 'undefined')
      _wr_material_delete(this._skyboxMaterial);

    _wr_node_delete(this._skyboxTransform);
    _wr_static_mesh_delete(this._skyboxMesh);

    _wr_node_delete(this._hdrClearRenderable);
    this._hdrClearRenderable = null;
    _wr_scene_set_hdr_clear_quad(_wr_scene_get_instance(), this._hdrClearRenderable);

    if (typeof this._hdrClearMaterial !== 'undefined')
      _wr_material_delete(this._hdrClearMaterial);

    _wr_node_delete(this._hdrClearTransform);
    _wr_static_mesh_delete(this._hdrClearMesh);

    WbBackground.instance = undefined;

    this._updatePBRs();

    super.delete();
  }

  postFinalize() {
    super.postFinalize();

    this._applySkyBoxToWren();
    this._updatePBRs();
  }

  // Private functions
  _applyColourToWren() {
    const colorPointer = _wrjs_array3(this.skyColor.x, this.skyColor.y, this.skyColor.z);

    _wr_viewport_set_clear_color_rgb(_wr_scene_get_viewport(_wr_scene_get_instance()), colorPointer);
    if (typeof this.wrenObjectsCreatedCalled !== 'undefined') {
      // use wren's set_diffuse to transform to linear color space
      _wr_phong_material_set_diffuse(this._hdrClearMaterial, colorPointer);

      // de-gamma correct
      const hdrColor = [Math.pow(this.skyColor.x, 2.2), Math.pow(this.skyColor.y, 2.2), Math.pow(this.skyColor.z, 2.2)];
      // reverse tone map
      const exposure = WbWorld.instance.viewpoint.exposure;
      for (let i = 0; i < 3; ++i)
        hdrColor[i] = -Math.log(1.000000001 - hdrColor[i]) / exposure;

      const hdrColorPointer = _wrjs_array3(hdrColor[0], hdrColor[1], hdrColor[2]);
      _wr_phong_material_set_linear_diffuse(this._hdrClearMaterial, hdrColorPointer);
      _wr_scene_set_hdr_clear_quad(_wr_scene_get_instance(), this._hdrClearRenderable);
    }
  }

  _applySkyBoxToWren() {
    this._destroySkyBox();

    // 1. Load the background.
    if (typeof this._cubeArray !== 'undefined' && this._cubeArray.length === 6) {
      this._cubeMapTexture = _wr_texture_cubemap_new();
      _wr_texture_set_internal_format(this._cubeMapTexture, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA8);

      const bitsPointers = [];
      for (let i = 0; i < 6; ++i) {
        bitsPointers[i] = arrayXPointer(this._cubeArray[i].bits);
        _wr_texture_cubemap_set_data(this._cubeMapTexture, bitsPointers[i], i);
      }

      _wr_texture_set_size(this._cubeMapTexture, this._cubeArray[0].width, this._cubeArray[0].height);
      _wr_texture_setup(this._cubeMapTexture);
      _wr_material_set_texture_cubemap(this._skyboxMaterial, this._cubeMapTexture, 0);
      _wr_material_set_texture_cubemap_wrap_r(this._skyboxMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
      _wr_material_set_texture_cubemap_wrap_s(this._skyboxMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
      _wr_material_set_texture_cubemap_wrap_t(this._skyboxMaterial, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, 0);
      _wr_scene_set_skybox(_wr_scene_get_instance(), this._skyboxRenderable);

      for (let i = 0; i < 6; ++i)
        _free(bitsPointers[i]);
    }

    // 2. Load the irradiance map.
    const cubeMap = _wr_texture_cubemap_new();
    const hdrImageData = [];
    if (typeof this._cubeArray !== 'undefined' && this._irradianceCubeArray.length === 6) {
      _wr_texture_set_internal_format(cubeMap, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGB32F);

      for (let i = 0; i < 6; ++i) {
        hdrImageData[i] = arrayXPointerFloat(this._irradianceCubeArray[i].bits);
        _wr_texture_cubemap_set_data(cubeMap, hdrImageData[i], i);
      }

      _wr_texture_set_size(cubeMap, this._irradianceCubeArray[0].width, this._irradianceCubeArray[0].height);
      _wr_texture_set_texture_unit(cubeMap, 13);
      _wr_texture_setup(cubeMap);

      this.irradianceCubeTexture = _wr_texture_cubemap_bake_specular_irradiance(cubeMap, WbWrenShaders.iblSpecularIrradianceBakingShader(), this._irradianceCubeArray[0].width);
      _wr_texture_cubemap_disable_automatic_mip_map_generation(this.irradianceCubeTexture);
    } else {
      if (typeof this.irradianceCubeTexture !== 'undefined') {
        _wr_texture_delete(this.irradianceCubeTexture);
        this.irradianceCubeTexture = null;
      }
      // Fallback: a cubemap is found but no irradiance map: bake a small irradiance map to have right colors.
      // Reflections won't be good in such case.
      if (typeof this._cubeMapTexture !== 'undefined') {
        this.irradianceCubeTexture = _wr_texture_cubemap_bake_specular_irradiance(this._cubeMapTexture, WbWrenShaders.iblSpecularIrradianceBakingShader(), 64);
        _wr_texture_cubemap_disable_automatic_mip_map_generation(this.irradianceCubeTexture);
      }
    }

    _wr_texture_delete(cubeMap);

    for (let i = 0; i < hdrImageData.length; ++i)
      _free(hdrImageData[i]);
  }

  _destroySkyBox() {
    _wr_scene_set_skybox(_wr_scene_get_instance(), null);

    if (typeof this._skyboxMaterial !== 'undefined')
      _wr_material_set_texture_cubemap(this._skyboxMaterial, null, 0);

    if (typeof this._cubeMapTexture !== 'undefined') {
      _wr_texture_delete(this._cubeMapTexture);
      this._cubeMapTexture = undefined;
    }

    if (typeof this.irradianceCubeTexture !== 'undefined') {
      _wr_texture_delete(this.irradianceCubeTexture);
      this.irradianceCubeTexture = undefined;
    }
  }

  _updatePBRs() {
    WbWorld.instance.nodes.forEach((value, key, map) => {
      if (value instanceof WbPBRAppearance && typeof value.parent !== 'undefined') {
        const parent = WbWorld.instance.nodes.get(value.parent);
        if (typeof parent !== 'undefined')
          parent.applyMaterialToGeometry();
      }
    });
  }
}class WbWrenMeshBuffers {
  constructor(verticesCount, indicesCount, texCoordSetsCount) {
    this.vertexIndex = 0;
    this.index = 0;

    this.resetAll(verticesCount, indicesCount, texCoordSetsCount);
  }

  clear() {
    this.vertexBuffer = undefined;
    this.normalBuffer = undefined;
    this.texCoordBuffer = undefined;
    this.unwrappedTexCoordsBuffer = undefined;
    this.indexBuffer = undefined;

    this.vertexIndex = 0;
    this.index = 0;
  }

  resetAll(verticesCount, indicesCount, texCoordSetsCount) {
    this.clear();

    this.verticesCount = verticesCount;
    this.indicesCount = indicesCount;
    this.texCoordSetsCount = texCoordSetsCount;
    this.vertexBuffer = [];
    this.normalBuffer = [];
    if (texCoordSetsCount > 0) {
      this.texCoordBuffer = [];
      this.unwrappedTexCoordsBuffer = [];
    }
    this.indexBuffer = [];
  }

  // Static functions

  static writeCoordinates(x, y, z, m, buffer, index) {
    const result = m.mulByVec4(new WbVector4(x, y, z, 1.0));
    buffer[index] = result.x;
    buffer[index + 1] = result.y;
    buffer[index + 2] = result.z;
  }

  static writeNormal(x, y, z, m, buffer, index) {
    const result = m.mulByVec3(new WbVector3(x, y, z));
    buffer[index] = result.x;
    buffer[index + 1] = result.y;
    buffer[index + 2] = result.z;
  }
}class WbWrenRenderingContext {}

WbWrenRenderingContext.VF_INVISIBLE_FROM_CAMERA = 0x00000002; // flag for selected outlines
WbWrenRenderingContext.VF_NORMALS = 0x00040000; // Display mesh normals
WbWrenRenderingContext.VM_REGULAR = 0xFFF00000; // no special renderings, i.e. no outlines and no optional renderings from menu selection

WbWrenRenderingContext.PP_GTAO = 0;
WbWrenRenderingContext.PP_BLOOM = 1;
WbWrenRenderingContext.PP_HDR = 2;
WbWrenRenderingContext.PP_SMAA = 3;class WbGeometry extends WbBaseNode {
  constructor(id) {
    super(id);

    this.pickable = false;
    this._isShadedGeometryPickable = true;
  }

  computeCastShadows(enabled) {
    if (typeof this._wrenRenderable === 'undefined')
      return;

    if (super.isInBoundingObject() || isDescendantOfBillboard(this)) {
      _wr_renderable_set_cast_shadows(this._wrenRenderable, false);
      _wr_renderable_set_receive_shadows(this._wrenRenderable, false);
    } else
      _wr_renderable_set_cast_shadows(this._wrenRenderable, enabled);
  }

  delete() {
    if (typeof this.parent !== 'undefined') {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined')
        parent.geometry = undefined;
    }

    if (this.wrenObjectsCreatedCalled)
      this._deleteWrenRenderable();

    super.delete();
  }

  setPickable(pickable) {
    if (typeof this._wrenRenderable === 'undefined'|| super.isInBoundingObject())
      return;

    this.pickable = pickable && this._isShadedGeometryPickable;

    WbWrenPicker.setPickable(this._wrenRenderable, this.id, pickable);
  }

  setWrenMaterial(material, castShadows) {
    if (typeof this._wrenRenderable !== 'undefined') {
      _wr_renderable_set_material(this._wrenRenderable, material, null);
      this.computeCastShadows(castShadows);
    }
  }

  updateBoundingObjectVisibility() {
    this._applyVisibilityFlagToWren(this._isSelected());
  }

  // Private functions

  _applyVisibilityFlagToWren(selected) {
    if (typeof this._wrenScaleTransform === 'undefined')
      return;

    if (super.isInBoundingObject()) {
      if (selected) {
        _wr_renderable_set_visibility_flags(this._wrenRenderable, WbWrenRenderingContext.VF_INVISIBLE_FROM_CAMERA);
        _wr_node_set_visible(this._wrenScaleTransform, true);
      } else if (_wr_node_get_parent(this._wrenScaleTransform))
        _wr_node_set_visible(this._wrenScaleTransform, false);
    } else if (isDescendantOfBillboard(this)) {
      _wr_renderable_set_visibility_flags(this._wrenRenderable, WbWrenRenderingContext.VF_INVISIBLE_FROM_CAMERA);
      _wr_node_set_visible(this._wrenScaleTransform, true);
    } else {
      _wr_renderable_set_visibility_flags(this._wrenRenderable, WbWrenRenderingContext.VM_REGULAR);
      _wr_node_set_visible(this._wrenScaleTransform, true);
    }
  }

  _computeWrenRenderable() {
    if (!this.wrenObjectsCreatedCalled)
      super.createWrenObjects();

    this._wrenScaleTransform = _wr_transform_new();
    _wr_transform_attach_child(this.wrenNode, this._wrenScaleTransform);
    this.wrenNode = this._wrenScaleTransform;

    this._wrenRenderable = _wr_renderable_new();
    if (super.isInBoundingObject()) {
      _wr_renderable_set_cast_shadows(this._wrenRenderable, false);
      _wr_renderable_set_receive_shadows(this._wrenRenderable, false);
      _wr_renderable_set_drawing_mode(this._wrenRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_LINES);
    } else if (this.isMarker) {
      _wr_renderable_set_drawing_order(this._wrenRenderable, Enum.WR_RENDERABLE_DRAWING_ORDER_AFTER_1);
      _wr_renderable_set_receive_shadows(this._wrenRenderable, false);
    }

    _wr_transform_attach_child(this._wrenScaleTransform, this._wrenRenderable);

    this.updateBoundingObjectVisibility();

    this.computeCastShadows(true);
  }

  _createMeshBuffers(verticesCount, indicesCount) {
    if (verticesCount <= 0 || indicesCount <= 0)
      return undefined;

    return new WbWrenMeshBuffers(verticesCount, indicesCount, super.isInBoundingObject() ? 0 : 2, 0);
  }

  _deleteWrenRenderable() {
    if (typeof this._wrenRenderable !== 'undefined') {
      // Delete picking material
      _wr_material_delete(Module.ccall('wr_renderable_get_material', 'number', ['number', 'string'], [this._wrenRenderable, 'picking']));
      _wr_material_delete(Module.ccall('wr_renderable_get_material', 'number', ['number', 'string'], [this._wrenRenderable, 'depth']));

      _wr_node_delete(this._wrenRenderable);
      this._wrenRenderable = undefined;

      this.wrenNode = _wr_node_get_parent(this._wrenScaleTransform);
      _wr_node_delete(this._wrenScaleTransform);
      this._wrenScaleTransform = undefined;
    }
  }

  _isAValidBoundingObject() {
    if (!super.isInBoundingObject())
      return false;

    const upperTransform = super.upperTransform();
    if (typeof upperTransform !== 'undefined' && upperTransform.isInBoundingObject() && upperTransform.geometry !== this)
      return false;

    return true;
  }

  _isSelected() {
    if (Selector.selectedId === this.id)
      return true;
    else if (typeof this.parent !== 'undefined')
      return Selector.checkIfParentIsSelected(this);

    return false;
  }
}

WbGeometry.LINE_SCALE_FACTOR = 250.0;class WbBox extends WbGeometry {
  constructor(id, size) {
    super(id);
    this.size = size;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbBox(customID, this.size);
  }

  createWrenObjects() {
    super.createWrenObjects();
    super._computeWrenRenderable();

    const createOutlineMesh = super.isInBoundingObject();
    this._wrenMesh = _wr_static_mesh_unit_box_new(createOutlineMesh);

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);

    this.updateSize();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  updateLineScale() {
    if (!this._isAValidBoundingObject())
      return;

    const offset = Math.min(this.size.x, Math.min(this.size.y, this.size.z)) * _wr_config_get_line_scale() / WbGeometry.LINE_SCALE_FACTOR;
    _wr_transform_set_scale(this.wrenNode, _wrjs_array3(this.size.x + offset, this.size.y + offset, this.size.z + offset));
  }

  updateSize() {
    if (super.isInBoundingObject())
      this.updateLineScale();
    else
      _wr_transform_set_scale(this.wrenNode, _wrjs_array3(this.size.x, this.size.y, this.size.z));
  }
}

WbBox.IntersectedFace = {
  FRONT_FACE: 0,
  BACK_FACE: 1,
  LEFT_FACE: 2,
  RIGHT_FACE: 3,
  TOP_FACE: 4,
  BOTTOM_FACE: 5
};class WbCapsule extends WbGeometry {
  constructor(id, radius, height, subdivision, bottom, side, top) {
    super(id);
    this.radius = radius;
    this.height = height;
    this.subdivision = subdivision;
    this.bottom = bottom;
    this.side = side;
    this.top = top;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbCapsule(customID, this.radius, this.height, this.subdivision, this.bottom, this.side, this.top);
  }

  createWrenObjects() {
    super.createWrenObjects();

    this._buildWrenMesh();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  // Private functions

  _buildWrenMesh() {
    super._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    if (!this.bottom && !this.side && !this.top)
      return;

    super._computeWrenRenderable();

    // Restore pickable state
    super.setPickable(this.isPickable);

    this._wrenMesh = _wr_static_mesh_capsule_new(this.subdivision, this.radius, this.height, this.side, this.top, this.bottom, false);

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);
  }
}class WbCone extends WbGeometry {
  constructor(id, bottomRadius, height, subdivision, side, bottom) {
    super(id);
    this.bottomRadius = bottomRadius;
    this.height = height;
    this.subdivision = subdivision;
    this.side = side;
    this.bottom = bottom;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbCone(customID, this.bottomRadius, this.height, this.subdivision, this.side, this.bottom);
  }

  createWrenObjects() {
    super.createWrenObjects();

    if (!this.bottom && !this.side)
      return;

    this._computeWrenRenderable();

    this._wrenMesh = _wr_static_mesh_unit_cone_new(this.subdivision, this.side, this.bottom);

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);

    const scale = _wrjs_array3(this.bottomRadius, this.height, this.bottomRadius);
    _wr_transform_set_scale(this.wrenNode, scale);
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }
}class WbCylinder extends WbGeometry {
  constructor(id, radius, height, subdivision, bottom, side, top) {
    super(id);
    this.radius = radius;
    this.height = height;
    this.subdivision = subdivision;
    this.bottom = bottom;
    this.side = side;
    this.top = top;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbCylinder(customID, this.radius, this.height, this.subdivision, this.bottom, this.side, this.top);
  }

  createWrenObjects() {
    super.createWrenObjects();

    if (this.subdivision < 3)
      this.subdivision = 3;

    if (!this.bottom && !this.side && !this.top)
      return;

    this._computeWrenRenderable();

    this._wrenMesh = _wr_static_mesh_unit_cylinder_new(this.subdivision, this.side, this.top, this.bottom, false);

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);

    const scale = _wrjs_array3(this.radius, this.height, this.radius);
    _wr_transform_set_scale(this.wrenNode, scale);
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }
}class WbDirectionalLight extends WbLight {
  constructor(id, on, color, direction, intensity, castShadows, ambientIntensity) {
    super(id, on, color, intensity, castShadows, ambientIntensity);

    this.direction = direction;
  }

  createWrenObjects() {
    this._wrenLight = _wr_directional_light_new();
    super.createWrenObjects();

    this._applyLightDirectionToWren();
  }

  delete() {
    if (this.wrenObjectsCreatedCalled)
      _wr_node_delete(this._wrenLight);

    super.delete();
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbDirectionalLight(customID, this.on, this.color, this.direction, this.intensity, this.castShadows, this.ambientIntensity);
  }

  // Private functions

  _applyLightColorToWren() {
    const pointer = _wrjs_array3(this.color.x, this.color.y, this.color.z);

    _wr_directional_light_set_color(this._wrenLight, pointer);
  }

  _applyLightDirectionToWren() {
    const pointer = _wrjs_array3(this.direction.x, this.direction.y, this.direction.z);
    _wr_directional_light_set_direction(this._wrenLight, pointer);
  }

  _applyLightIntensityToWren() {
    _wr_directional_light_set_intensity(this._wrenLight, this.intensity);
  }

  _applyLightShadowsToWren() {
    _wr_directional_light_set_cast_shadows(this._wrenLight, this.castShadows);
  }

  _applyLightVisibilityToWren() {
    _wr_directional_light_set_on(this._wrenLight, this.on);

    const maxCount = _wr_config_get_max_active_directional_light_count();
    const activeCount = _wr_scene_get_active_directional_light_count(_wr_scene_get_instance());
    if (activeCount === maxCount)
      console.log('Maximum number of directional lights ' + maxCount + " has been reached, newly added lights won't be rendered.");
  }
}class WbElevationGrid extends WbGeometry {
  constructor(id, height, xDimension, xSpacing, zDimension, zSpacing, thickness) {
    super(id);
    this.height = height;
    this.xDimension = xDimension;
    this.xSpacing = xSpacing;
    this.zDimension = zDimension;
    this.zSpacing = zSpacing;
    this.thickness = thickness;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbElevationGrid(customID, this.height, this.xDimension, this.xSpacing, this.zDimension, this.zSpacing, this.thickness);
  }

  createWrenObjects() {
    super.createWrenObjects();
    this._buildWrenMesh();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  updateLineScale() {
    if (this._isAValidBoundingObject())
      return;

    const offset = _wr_config_get_line_scale() / WbGeometry.LINE_SCALE_FACTOR;

    const scalePointer = _wrjs_array3(this.xSpacing, 1.0 + offset, this.zSpacing);

    _wr_transform_set_scale(this.wrenNode, scalePointer);
  }

  updateScale() {
    const scalePointer = _wrjs_array3(this.xSpacing, 1.0, this.zSpacing);
    _wr_transform_set_scale(this.wrenNode, scalePointer);
  }

  // Private functions

  _buildWrenMesh() {
    super._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    if (this.xDimension < 2 || this.zDimension < 2)
      return;

    if (this.xSpacing === 0.0 || this.zSpacing === 0.0)
      return;

    super._computeWrenRenderable();

    // Restore pickable state
    super.setPickable(this.pickable);

    // convert height values to float, pad with zeroes if necessary
    const numValues = this.xDimension * this.zDimension;
    const heightData = [];

    const availableValues = Math.min(numValues, this.height.length);
    for (let i = 0; i < availableValues; ++i)
      heightData[i] = this.height[i];

    const createOutlineMesh = super.isInBoundingObject();

    const heightDataPointer = arrayXPointerFloat(heightData);
    this._wrenMesh = _wr_static_mesh_unit_elevation_grid_new(this.xDimension, this.zDimension, heightDataPointer, this.thickness, createOutlineMesh);

    _free(heightDataPointer);

    if (createOutlineMesh)
      this.updateLineScale();
    else
      this.updateScale();

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);
  }

  _isAValidBoundingObject() {
    return this._isSuitableForInsertionInBoundingObject() && super._isAValidBoundingObject();
  }

  _isSuitableForInsertionInBoundingObject() {
    const invalidDimensions = this.xDimension < 2 || this.zDimension < 2;
    const invalidSpacings = this.xSpacing <= 0.0 || this.zSpacing < 0.0;
    const invalid = invalidDimensions || invalidSpacings;

    return !invalid;
  }
}class WbFog extends WbBaseNode {
  constructor(id, color, visibilityRange, fogType) {
    super(id);
    this.color = color;
    this.visibilityRange = visibilityRange;
    this.fogType = fogType;
  }

  createWrenObjects() {
    super.createWrenObjects();

    this._applyChangesToWren();
  }

  delete() {
    if (typeof this.parent === 'undefined') {
      const index = WbWorld.instance.sceneTree.indexOf(this);
      WbWorld.instance.sceneTree.splice(index, 1);
    }

    if (this.wrenObjectsCreatedCalled)
      _wr_scene_set_fog(_wr_scene_get_instance(), Enum.WR_SCENE_FOG_TYPE_NONE, Enum.WR_SCENE_FOG_DEPTH_TYPE_PLANE, null, 1.0, 0.0, 1.0);

    WbWorld.instance.hasFog = false;

    super.delete();
  }

  preFinalize() {
    super.preFinalize();

    this.updateFogType();
  }

  updateFogType() {
    if (this.fogType === 'EXPONENTIAL')
      this._wrenFogType = Enum.WR_SCENE_FOG_TYPE_EXPONENTIAL;
    else if (this.fogType === 'EXPONENTIAL2')
      this._wrenFogType = Enum.WR_SCENE_FOG_TYPE_EXPONENTIAL2;
    else
      this._wrenFogType = Enum.WR_SCENE_FOG_TYPE_LINEAR;

    if (this._wrenFogType === Enum.WR_SCENE_FOG_TYPE_LINEAR && this.fogType !== 'LINEAR')
      console.warn("Unknown 'fogType': " + this.fogType + ' Set to "LINEAR"');

    if (this.wrenObjectsCreatedCalled)
      this._applyChangesToWren();
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbFog(customID, this.color, this.visibilityRange, this.fogType);
  }

  // Private functions

  _applyChangesToWren() {
    let density = 0.0;
    if (this.visibilityRange > 0.0)
      density = 1.0 / this.visibilityRange;
    else
      this._wrenFogType = Enum.WR_SCENE_FOG_TYPE_NONE;

    const colorPointer = _wrjs_array3(this.color.x, this.color.y, this.color.z);
    _wr_scene_set_fog(_wr_scene_get_instance(), this._wrenFogType, Enum.WR_SCENE_FOG_DEPTH_TYPE_POINT, colorPointer, density, 0.0, this.visibilityRange);
  }
}class WbImage {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.isTranslucent = false;
  }
}class WbImageTexture extends WbBaseNode {
  constructor(id, prefix, url, isTransparent, s, t, filtering) {
    super(id);
    this.prefix = prefix;
    this.url = url;

    this.isTransparent = isTransparent;
    this.repeatS = s;
    this.repeatT = t;
    this.filtering = filtering;

    this._wrenTextureIndex = 0;
    this.usedFiltering = 0;
  }

  clone(customID) {
    const imageTexture = new WbImageTexture(customID, this.prefix, this.url, this.isTransparent, this.repeatS, this.repeatT, this.filtering);
    imageTexture.updateUrl();
    this.useList.push(customID);
    return imageTexture;
  }

  delete() {
    this._destroyWrenTexture();

    if (typeof this.parent !== 'undefined') {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined') {
        if (parent instanceof WbAppearance)
          parent.texture = undefined;
        else {
          switch (this.type) {
            case 'baseColorMap':
              parent.baseColorMap = undefined;
              break;
            case 'roughnessMap':
              parent.roughnessMap = undefined;
              break;
            case 'metalnessMap':
              parent.metalnessMap = undefined;
              break;
            case 'normalMap':
              parent.normalMap = undefined;
              break;
            case 'occlusionMap':
              parent.occlusionMap = undefined;
              break;
            case 'emissiveColorMap':
              parent.emissiveColorMap = undefined;
              break;
            default:
              console.error('unknow imageTexture: ' + this.id);
          }
        }
      }
    }
    super.delete();
  }

  modifyWrenMaterial(wrenMaterial, mainTextureIndex, backgroundTextureIndex) {
    if (!wrenMaterial)
      return;
    this._wrenTextureIndex = mainTextureIndex;
    _wr_material_set_texture(wrenMaterial, this._wrenTexture, this._wrenTextureIndex);
    if (this._wrenTexture) {
      _wr_texture_set_translucent(this._wrenTexture, this.isTransparent);
      _wr_material_set_texture_wrap_s(wrenMaterial, this.repeatS ? Enum.WR_TEXTURE_WRAP_MODE_REPEAT : Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, this._wrenTextureIndex);
      _wr_material_set_texture_wrap_t(wrenMaterial, this.repeatT ? Enum.WR_TEXTURE_WRAP_MODE_REPEAT : Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE, this._wrenTextureIndex);
      _wr_material_set_texture_anisotropy(wrenMaterial, 1 << (this.usedFiltering - 1), this._wrenTextureIndex);
      _wr_material_set_texture_enable_interpolation(wrenMaterial, this.usedFiltering, this._wrenTextureIndex);
      _wr_material_set_texture_enable_mip_maps(wrenMaterial, this.usedFiltering, this._wrenTextureIndex);
    }

    _wr_material_set_texture(wrenMaterial, null, backgroundTextureIndex);
  }

  preFinalize() {
    super.preFinalize();
    this._updateFiltering();
  }

  async updateUrl() {
    // we want to replace the windows backslash path separators (if any) with cross-platform forward slashes
    this.url = this.url.replaceAll('\\', '/');

    await this._updateWrenTexture();
  }

  // Private fonctions

  _destroyWrenTexture() {
    _wr_texture_delete(this._wrenTexture);

    _wr_texture_transform_delete(this._wrenTextureTransform);

    this._wrenTexture = undefined;
    this._wrenTextureTransform = undefined;
  }

  _updateFiltering() {
    // The filtering level has an upper bound defined by the maximum supported anisotropy level.
    // A warning is not produced here because the maximum anisotropy level is not up to the user
    // and may be repeatedly shown even though a minimum requirement warning was already given.
    this.usedFiltering = Math.min(this.filtering, textureFiltering);
  }

  async _updateWrenTexture() {
    this._destroyWrenTexture();
    // Only load the image from disk if the texture isn't already in the cache
    let texture = Module.ccall('wr_texture_2d_copy_from_cache', 'number', ['string'], [this.url]);
    if (texture === 0) {
      const image = await Parser.loadTextureData(this.prefix, this.url);
      texture = _wr_texture_2d_new();
      _wr_texture_set_size(texture, image.width, image.height);
      _wr_texture_set_translucent(texture, this.isTransparent);
      const bitsPointer = arrayXPointer(image.bits);
      _wr_texture_2d_set_data(texture, bitsPointer);
      Module.ccall('wr_texture_2d_set_file_path', null, ['number', 'string'], [texture, this.url]);
      _wr_texture_setup(texture);
      _free(bitsPointer);
    } else
      this.isTransparent = _wr_texture_is_translucent(texture);

    this._wrenTexture = texture;
  }
}class WbMatrix3 {
  constructor(m0 = 1.0, m1 = 0, m2 = 0, m3 = 0, m4 = 1.0, m5 = 0, m6 = 0, m7 = 0, m8 = 1.0) {
    this.m = [9];
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
    this.m[6] = m6;
    this.m[7] = m7;
    this.m[8] = m8;
  }

  mulByVec3(vector) {
    return new WbVector3(this.m[0] * vector.x + this.m[1] * vector.y + this.m[2] * vector.z,
      this.m[3] * vector.x + this.m[4] * vector.y + this.m[5] * vector.z,
      this.m[6] * vector.x + this.m[7] * vector.y + this.m[8] * vector.z);
  }
}class WbMatrix4 {
  constructor() {
    this.m = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
  }

  extracted3x3Matrix() {
    return new WbMatrix3(this.m[0], this.m[1], this.m[2], this.m[4], this.m[5], this.m[6], this.m[8], this.m[9], this.m[10]);
  }

  inverse() {
    const inv = new Array(16);

    inv[0] = this.m[5] * this.m[10] * this.m[15] - this.m[5] * this.m[11] * this.m[14] - this.m[9] * this.m[6] * this.m[15] + this.m[9] * this.m[7] * this.m[14] +
            this.m[13] * this.m[6] * this.m[11] - this.m[13] * this.m[7] * this.m[10];

    inv[4] = -this.m[4] * this.m[10] * this.m[15] + this.m[4] * this.m[11] * this.m[14] + this.m[8] * this.m[6] * this.m[15] - this.m[8] * this.m[7] * this.m[14] -
            this.m[12] * this.m[6] * this.m[11] + this.m[12] * this.m[7] * this.m[10];

    inv[8] = this.m[4] * this.m[9] * this.m[15] - this.m[4] * this.m[11] * this.m[13] - this.m[8] * this.m[5] * this.m[15] + this.m[8] * this.m[7] * this.m[13] +
            this.m[12] * this.m[5] * this.m[11] - this.m[12] * this.m[7] * this.m[9];

    inv[12] = -this.m[4] * this.m[9] * this.m[14] + this.m[4] * this.m[10] * this.m[13] + this.m[8] * this.m[5] * this.m[14] - this.m[8] * this.m[6] * this.m[13] -
             this.m[12] * this.m[5] * this.m[10] + this.m[12] * this.m[6] * this.m[9];

    inv[1] = -this.m[1] * this.m[10] * this.m[15] + this.m[1] * this.m[11] * this.m[14] + this.m[9] * this.m[2] * this.m[15] - this.m[9] * this.m[3] * this.m[14] -
            this.m[13] * this.m[2] * this.m[11] + this.m[13] * this.m[3] * this.m[10];

    inv[5] = this.m[0] * this.m[10] * this.m[15] - this.m[0] * this.m[11] * this.m[14] - this.m[8] * this.m[2] * this.m[15] + this.m[8] * this.m[3] * this.m[14] +
            this.m[12] * this.m[2] * this.m[11] - this.m[12] * this.m[3] * this.m[10];

    inv[9] = -this.m[0] * this.m[9] * this.m[15] + this.m[0] * this.m[11] * this.m[13] + this.m[8] * this.m[1] * this.m[15] - this.m[8] * this.m[3] * this.m[13] -
            this.m[12] * this.m[1] * this.m[11] + this.m[12] * this.m[3] * this.m[9];

    inv[13] = this.m[0] * this.m[9] * this.m[14] - this.m[0] * this.m[10] * this.m[13] - this.m[8] * this.m[1] * this.m[14] + this.m[8] * this.m[2] * this.m[13] +
             this.m[12] * this.m[1] * this.m[10] - this.m[12] * this.m[2] * this.m[9];

    inv[2] = this.m[1] * this.m[6] * this.m[15] - this.m[1] * this.m[7] * this.m[14] - this.m[5] * this.m[2] * this.m[15] + this.m[5] * this.m[3] * this.m[14] +
            this.m[13] * this.m[2] * this.m[7] - this.m[13] * this.m[3] * this.m[6];

    inv[6] = -this.m[0] * this.m[6] * this.m[15] + this.m[0] * this.m[7] * this.m[14] + this.m[4] * this.m[2] * this.m[15] - this.m[4] * this.m[3] * this.m[14] -
            this.m[12] * this.m[2] * this.m[7] + this.m[12] * this.m[3] * this.m[6];

    inv[10] = this.m[0] * this.m[5] * this.m[15] - this.m[0] * this.m[7] * this.m[13] - this.m[4] * this.m[1] * this.m[15] + this.m[4] * this.m[3] * this.m[13] +
             this.m[12] * this.m[1] * this.m[7] - this.m[12] * this.m[3] * this.m[5];

    inv[14] = -this.m[0] * this.m[5] * this.m[14] + this.m[0] * this.m[6] * this.m[13] + this.m[4] * this.m[1] * this.m[14] - this.m[4] * this.m[2] * this.m[13] -
             this.m[12] * this.m[1] * this.m[6] + this.m[12] * this.m[2] * this.m[5];

    inv[3] = -this.m[1] * this.m[6] * this.m[11] + this.m[1] * this.m[7] * this.m[10] + this.m[5] * this.m[2] * this.m[11] - this.m[5] * this.m[3] * this.m[10] -
            this.m[9] * this.m[2] * this.m[7] + this.m[9] * this.m[3] * this.m[6];

    inv[7] = this.m[0] * this.m[6] * this.m[11] - this.m[0] * this.m[7] * this.m[10] - this.m[4] * this.m[2] * this.m[11] + this.m[4] * this.m[3] * this.m[10] +
            this.m[8] * this.m[2] * this.m[7] - this.m[8] * this.m[3] * this.m[6];

    inv[11] = -this.m[0] * this.m[5] * this.m[11] + this.m[0] * this.m[7] * this.m[9] + this.m[4] * this.m[1] * this.m[11] - this.m[4] * this.m[3] * this.m[9] -
             this.m[8] * this.m[1] * this.m[7] + this.m[8] * this.m[3] * this.m[5];

    inv[15] = this.m[0] * this.m[5] * this.m[10] - this.m[0] * this.m[6] * this.m[9] - this.m[4] * this.m[1] * this.m[10] + this.m[4] * this.m[2] * this.m[9] +
             this.m[8] * this.m[1] * this.m[6] - this.m[8] * this.m[2] * this.m[5];

    let det = this.m[0] * inv[0] + this.m[1] * inv[4] + this.m[2] * inv[8] + this.m[3] * inv[12];

    if (det === 0)
      return false;

    det = 1.0 / det;

    for (let i = 0; i < 16; ++i)
      this.m[i] = inv[i] * det;

    return true;
  }

  mul(matrix) {
    const mat = new WbMatrix4();
    mat.set(this.m[0] * matrix.m[0] + this.m[1] * matrix.m[4] + this.m[2] * matrix.m[8] + this.m[3] * matrix.m[12],
      this.m[0] * matrix.m[1] + this.m[1] * matrix.m[5] + this.m[2] * matrix.m[9] + this.m[3] * matrix.m[13],
      this.m[0] * matrix.m[2] + this.m[1] * matrix.m[6] + this.m[2] * matrix.m[10] + this.m[3] * matrix.m[14],
      this.m[0] * matrix.m[3] + this.m[1] * matrix.m[7] + this.m[2] * matrix.m[11] + this.m[3] * matrix.m[15],

      this.m[4] * matrix.m[0] + this.m[5] * matrix.m[4] + this.m[6] * matrix.m[8] + this.m[7] * matrix.m[12],
      this.m[4] * matrix.m[1] + this.m[5] * matrix.m[5] + this.m[6] * matrix.m[9] + this.m[7] * matrix.m[13],
      this.m[4] * matrix.m[2] + this.m[5] * matrix.m[6] + this.m[6] * matrix.m[10] + this.m[7] * matrix.m[14],
      this.m[4] * matrix.m[3] + this.m[5] * matrix.m[7] + this.m[6] * matrix.m[11] + this.m[7] * matrix.m[15],

      this.m[8] * matrix.m[0] + this.m[9] * matrix.m[4] + this.m[10] * matrix.m[8] + this.m[11] * matrix.m[12],
      this.m[8] * matrix.m[1] + this.m[9] * matrix.m[5] + this.m[10] * matrix.m[9] + this.m[11] * matrix.m[13],
      this.m[8] * matrix.m[2] + this.m[9] * matrix.m[6] + this.m[10] * matrix.m[10] + this.m[11] * matrix.m[14],
      this.m[8] * matrix.m[3] + this.m[9] * matrix.m[7] + this.m[10] * matrix.m[11] + this.m[11] * matrix.m[15],

      this.m[12] * matrix.m[0] + this.m[13] * matrix.m[4] + this.m[14] * matrix.m[8] + this.m[15] * matrix.m[12],
      this.m[12] * matrix.m[1] + this.m[13] * matrix.m[5] + this.m[14] * matrix.m[9] + this.m[15] * matrix.m[13],
      this.m[12] * matrix.m[2] + this.m[13] * matrix.m[6] + this.m[14] * matrix.m[10] + this.m[15] * matrix.m[14],
      this.m[12] * matrix.m[3] + this.m[13] * matrix.m[7] + this.m[14] * matrix.m[11] + this.m[15] * matrix.m[15]);
    return mat;
  }

  mulByVec4(vector) {
    return new WbVector4(this.m[0] * vector.x + this.m[1] * vector.y + this.m[2] * vector.z + this.m[3] * vector.w,
      this.m[4] * vector.x + this.m[5] * vector.y + this.m[6] * vector.z + this.m[7] * vector.w,
      this.m[8] * vector.x + this.m[9] * vector.y + this.m[10] * vector.z + this.m[11] * vector.w,
      this.m[12] * vector.x + this.m[13] * vector.y + this.m[14] * vector.z + this.m[15] * vector.w);
  }

  set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.m = [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33];
  }
}class WbTriangleMesh {
  constructor() {
    this.isValid = false;

    this._coordinates = [];
    this._coordIndices = [];
    this._tmpNormalIndices = [];
    this._tmpTexIndices = [];
    this._normals = [];
    this._textureCoordinates = [];
  }

  coordinateIndex(triangle, vertex, component) {
    return 3 * this._coordIndices[this.index(triangle, vertex)] + component;
  }

  index(triangle, vertex) {
    return 3 * triangle + vertex;
  }

  init(coord, coordIndex, normal, normalIndex, texCoord, texCoordIndex, counterClockwise) {
    this._coordIndices = coordIndex;
    this._tmpTexIndices = texCoordIndex;
    this._tmpNormalIndices = normalIndex;
    this.numberOfTriangles = this._coordIndices.length / 3;

    if (!counterClockwise)
      this._reverseIndexOrder();

    this._finalPass(coord, normal, texCoord);

    // validity switch
    this.isValid = true;
  }

  normal(triangle, vertex, component) {
    return this._normals[3 * this.index(triangle, vertex) + component];
  }

  textureCoordinate(triangle, vertex, component) {
    return this._textureCoordinates[2 * this.index(triangle, vertex) + component];
  }

  vertex(triangle, vertex, component) {
    return this._coordinates[this.coordinateIndex(triangle, vertex, component)];
  }

  // Private functions

  // populate this._coordinates, this._textureCoordinates and this._normals
  _finalPass(coord, normal, texCoord) {
    const texCoordSize = typeof texCoord !== 'undefined' ? texCoord.length : 0;
    const normalSize = typeof normal !== 'undefined' ? normal.length : 0;

    for (let i = 0; i < coord.length; ++i) {
      let vertex = coord[i];

      this._coordinates.push(vertex.x);
      this._coordinates.push(vertex.y);
      this._coordinates.push(vertex.z);
    }

    for (let t = 0; t < this.numberOfTriangles; ++t) { // foreach triangle
      const k = 3 * t;
      for (let v = 0; v < 3; ++v) { // foreach vertex
        const index = k + v;

        const indexNormal = this._tmpNormalIndices[index];
        if (indexNormal >= 0 && indexNormal < normalSize) {
          const nor = normal[indexNormal];
          this._normals.push(nor.x);
          this._normals.push(nor.y);
          this._normals.push(nor.z);
        }

        const indexTex = this._tmpTexIndices[index];
        if (indexTex >= 0 && indexTex < texCoordSize) {
          const tex = texCoord[indexTex];
          this._textureCoordinates.push(tex.x);
          this._textureCoordinates.push(1.0 - tex.y);
        } else {
          // foreach texture coordinate component
          this._textureCoordinates.push(0.5);
          this._textureCoordinates.push(0.5);
        }
      }
    }
  }

  // reverse the order of the second and third element
  // of each triplet of the this._coordIndices and this._tmpTexIndices arrays
  _reverseIndexOrder() {
    const coordIndicesSize = this._coordIndices.length;
    if (coordIndicesSize % 3 !== 0)
      return;
    if (coordIndicesSize !== this._tmpTexIndices.length && this._tmpTexIndices.length !== 0)
      return;

    for (let i = 0; i < coordIndicesSize; i += 3) {
      const i1 = i + 1;
      const i2 = i + 2;
      const third = this._coordIndices[i2];
      this._coordIndices[i2] = this._coordIndices[i1];
      this._coordIndices[i1] = third;

      const thirdIndex = this._tmpTexIndices[i2];
      this._tmpTexIndices[i2] = this._tmpTexIndices[i1];
      this._tmpTexIndices[i1] = thirdIndex;
    }
  }
}class WbTriangleMeshGeometry extends WbGeometry {
  createWrenObjects() {
    super.createWrenObjects();

    this._buildWrenMesh(false);
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    this._deleteWrenRenderable();

    super.delete();
  }

  preFinalize() {
    if (this.isPreFinalizeCalled)
      return;

    super.preFinalize();

    this._createTriangleMesh();
  }

  // Private functions

  _buildGeomIntoBuffers(buffers, m) {
    if (!this._triangleMesh.isValid)
      return;

    const rm = m.extracted3x3Matrix();
    const n = this._triangleMesh.numberOfTriangles;

    let start = buffers.vertexIndex / 3;
    const vBuf = buffers.vertexBuffer;
    if (typeof vBuf !== 'undefined') {
      let i = buffers.vertexIndex;
      for (let t = 0; t < n; ++t) { // foreach triangle
        for (let v = 0; v < 3; ++v) { // foreach vertex
          WbWrenMeshBuffers.writeCoordinates(this._triangleMesh.vertex(t, v, 0), this._triangleMesh.vertex(t, v, 1), this._triangleMesh.vertex(t, v, 2), m, vBuf, i);
          i += 3;
        }
      }
    }

    const nBuf = buffers.normalBuffer;
    if (typeof nBuf !== 'undefined') {
      let i = buffers.vertexIndex;
      for (let t = 0; t < n; ++t) { // foreach triangle
        for (let v = 0; v < 3; ++v) { // foreach vertex
          WbWrenMeshBuffers.writeNormal(this._triangleMesh.normal(t, v, 0), this._triangleMesh.normal(t, v, 1), this._triangleMesh.normal(t, v, 2), rm, nBuf, i);
          i += 3;
        }
      }
    }

    const tBuf = buffers.texCoordBuffer;
    const utBuf = buffers.unwrappedTexCoordsBuffer;
    if (typeof tBuf !== 'undefined') {
      let i = start * buffers.texCoordSetsCount * 2;
      for (let t = 0; t < n; ++t) { // foreach triangle
        for (let v = 0; v < 3; ++v) { // foreach vertex
          tBuf[i] = this._triangleMesh.textureCoordinate(t, v, 0);
          tBuf[i + 1] = this._triangleMesh.textureCoordinate(t, v, 1);

          utBuf[i] = this._triangleMesh.textureCoordinate(t, v, 0);
          utBuf[i + 1] = this._triangleMesh.textureCoordinate(t, v, 1);

          i += 2;
        }
      }
    }

    const iBuf = buffers.indexBuffer;
    if (typeof iBuf !== 'undefined') {
      start = buffers.vertexIndex / 3;
      let i = buffers.index;
      for (let t = 0; t < n; ++t) { // foreach triangle
        for (let v = 0; v < 3; ++v) // foreach vertex
          iBuf[i++] = start + this._triangleMesh.index(t, v);
      }
      buffers.index = i;
    }

    buffers.vertexIndex = buffers.vertexIndex + this._estimateVertexCount() * 3;
  }

  _buildWrenMesh(updateCache) {
    this._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    if (!this._triangleMesh.isValid)
      return;

    const createOutlineMesh = super.isInBoundingObject();

    this._computeWrenRenderable();

    // normals representation
    this._normalsMaterial = _wr_phong_material_new();
    _wr_material_set_default_program(this._normalsMaterial, WbWrenShaders.lineSetShader());
    _wr_phong_material_set_color_per_vertex(this._normalsMaterial, true);
    _wr_phong_material_set_transparency(this._normalsMaterial, 0.4);

    this._normalsRenderable = _wr_renderable_new();
    _wr_renderable_set_cast_shadows(this._normalsRenderable, false);
    _wr_renderable_set_receive_shadows(this._normalsRenderable, false);
    _wr_renderable_set_material(this._normalsRenderable, this._normalsMaterial, null);
    _wr_renderable_set_visibility_flags(this._normalsRenderable, WbWrenRenderingContext.VF_NORMALS);
    _wr_renderable_set_drawing_mode(this._normalsRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_LINES);
    _wr_transform_attach_child(this.wrenNode, this._normalsRenderable);

    // Restore pickable state
    super.setPickable(this.isPickable);

    const buffers = super._createMeshBuffers(this._estimateVertexCount(), this._estimateIndexCount());
    this._buildGeomIntoBuffers(buffers, new WbMatrix4());
    const vertexBufferPointer = arrayXPointerFloat(buffers.vertexBuffer);
    const normalBufferPointer = arrayXPointerFloat(buffers.normalBuffer);
    const texCoordBufferPointer = arrayXPointerFloat(buffers.texCoordBuffer);
    const unwrappedTexCoordsBufferPointer = arrayXPointerFloat(buffers.unwrappedTexCoordsBuffer);
    const indexBufferPointer = arrayXPointerInt(buffers.indexBuffer);
    this._wrenMesh = _wr_static_mesh_new(buffers.verticesCount, buffers.indicesCount, vertexBufferPointer, normalBufferPointer, texCoordBufferPointer,
      unwrappedTexCoordsBufferPointer, indexBufferPointer, createOutlineMesh);

    _free(vertexBufferPointer);
    _free(normalBufferPointer);
    _free(texCoordBufferPointer);
    _free(unwrappedTexCoordsBufferPointer);
    _free(indexBufferPointer);

    buffers.clear();

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);
  }

  _createTriangleMesh() {
    this._triangleMesh = new WbTriangleMesh();
    this._updateTriangleMesh();
  }

  _deleteWrenRenderable() {
    if (typeof this._normalsMaterial !== 'undefined') {
      _wr_material_delete(this._normalsMaterial);
      this._normalsMaterial = undefined;
    }

    if (typeof this._normalsRenderable !== 'undefined') {
      _wr_node_delete(this._normalsRenderable);
      this._normalsRenderable = undefined;
    }

    super._deleteWrenRenderable();
  }

  _estimateIndexCount() {
    if (!this._triangleMesh.isValid)
      return;

    return 3 * this._triangleMesh.numberOfTriangles;
  }

  _estimateVertexCount() {
    if (!this._triangleMesh.isValid)
      return;

    return 3 * this._triangleMesh.numberOfTriangles;
  }

  _updateTriangleMesh() {}
}class WbIndexedFaceSet extends WbTriangleMeshGeometry {
  constructor(id, coordIndex, normalIndex, texCoordIndex, coord, texCoord, normal, ccw) {
    super(id);

    this.coordIndex = coordIndex;
    this.normalIndex = normalIndex;
    this.texCoordIndex = texCoordIndex;

    this.coord = coord;
    this.texCoord = texCoord;
    this.normal = normal;

    this.ccw = ccw;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbIndexedFaceSet(customID, this.coordIndex, this.normalIndex, this.texCoordIndex, this.coord, this.texCoord, this.normal, this.ccw, this.normalPerVertex);
  }

  _updateTriangleMesh() {
    this._triangleMesh.init(this.coord, this.coordIndex, this.normal, this.normalIndex, this.texCoord, this.texCoordIndex, this.ccw);
  }
}class WbIndexedLineSet extends WbGeometry {
  constructor(id, coord, coordIndex) {
    super(id);
    this.coord = coord;
    this.coordIndex = coordIndex;

    this._isShadedGeometryPickable = false;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbIndexedLineSet(customID, this.coord, this.coordIndex);
  }

  createWrenObjects() {
    super.createWrenObjects();
    this._updateCoord();
    this._buildWrenMesh();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  // Private functions
  _buildWrenMesh() {
    super._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    super._computeWrenRenderable();

    _wr_renderable_set_drawing_mode(this._wrenRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_LINES);

    const coordsData = [];
    const coordsCount = this._computeCoordsData(coordsData);

    if (coordsCount > 0) {
      const coordsDataPointer = arrayXPointerFloat(coordsData);
      this._wrenMesh = _wr_static_mesh_line_set_new(coordsCount, coordsDataPointer, null);
      _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);
      _free(coordsDataPointer);
    }
  }

  _computeCoordsData(data) {
    let count = 0;
    const size = this.coord.length;
    const invalidIndices = [];

    for (let i = 0; i < this.coordIndex.length - 1; i++) {
      let j = i + 1;
      if (this.coordIndex[i] >= 0 && this.coordIndex[j] >= 0 && this.coordIndex[i] < size && this.coordIndex[j] < size) {
        let v = this.coord[this.coordIndex[i] ];
        data[3 * count] = v.x;
        data[3 * count + 1] = v.y;
        data[3 * count + 2] = v.z;
        ++count;

        v = this.coord[this.coordIndex[j]];
        data[3 * count] = v.x;
        data[3 * count + 1] = v.y;
        data[3 * count + 2] = v.z;
        ++count;
      } else {
        if (this.coordIndex[i] < -1 || this.coordIndex[i] >= size)
          invalidIndices.push(this.coordIndex[i]);
        if (this.coordIndex[j] < -1 || this.coordIndex[j] >= size)
          invalidIndices.push(this.coordIndex[j]);
      }
    }

    if (invalidIndices.length > 0) {
      console.warn("The following indices are out of the range of coordinates specified in the 'IndexedLineSet.coord' field:");
      console.warn(invalidIndices);
    }

    return count;
  }

  _updateCoord() {
    if (this.wrenObjectsCreatedCalled)
      this._buildWrenMesh();
  }
}class WbMaterial extends WbBaseNode {
  constructor(id, ambientIntensity, diffuseColor, specularColor, emissiveColor, shininess, transparency) {
    super(id);
    this.ambientIntensity = ambientIntensity;
    this.diffuseColor = diffuseColor;
    this.specularColor = specularColor;
    this.emissiveColor = emissiveColor;
    this.shininess = shininess;
    this.transparency = transparency;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbMaterial(customID, this.ambientIntensity, this.diffuseColor, this.specularColor, this.emissiveColor, this.shininess, this.transparency);
  }

  delete() {
    const parent = WbWorld.instance.nodes.get(this.parent);

    if (typeof parent !== 'undefined') {
      const shape = WbWorld.instance.nodes.get(parent.parent);
      if (typeof shape !== 'undefined') {
        parent.material = undefined;
        shape.updateAppearance();
      }
    }
    super.delete();
  }

  modifyWrenMaterial(wrenMaterial, textured) {
    let ambient, diffuse, specular, shininess;

    if (textured) {
      ambient = new WbVector3(this.ambientIntensity, this.ambientIntensity, this.ambientIntensity);
      diffuse = new WbVector3(1.0, 1.0, 1.0);
      specular = new WbVector3(1.0, 1.0, 1.0);
      shininess = 0.0;
    } else {
      ambient = new WbVector3(this.ambientIntensity * this.diffuseColor.x, this.ambientIntensity * this.diffuseColor.y,
        this.ambientIntensity * this.diffuseColor.z);
      diffuse = new WbVector3(this.diffuseColor.x, this.diffuseColor.y, this.diffuseColor.z);
      specular = new WbVector3(this.specularColor.x, this.specularColor.y, this.specularColor.z);
      shininess = this.shininess;
    }

    const ambientColorPointer = array3Pointer(ambient.x, ambient.y, ambient.z);
    const diffuseColorPointer = array3Pointer(diffuse.x, diffuse.y, diffuse.z);
    const specularColorPointer = array3Pointer(specular.x, specular.y, specular.z);
    const emissiveColorPointer = array3Pointer(this.emissiveColor.x, this.emissiveColor.y, this.emissiveColor.z);

    _wr_phong_material_set_all_parameters(wrenMaterial, ambientColorPointer, diffuseColorPointer, specularColorPointer, emissiveColorPointer, shininess, this.transparency);

    _free(ambientColorPointer);
    _free(diffuseColorPointer);
    _free(specularColorPointer);
    _free(emissiveColorPointer);
  }
}class WbPlane extends WbGeometry {
  constructor(id, size) {
    super(id);
    this.size = size;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbPlane(customID, this.size);
  }

  createWrenObjects() {
    super.createWrenObjects();

    this._computeWrenRenderable();

    const createOutlineMesh = super.isInBoundingObject();
    const wrenMesh = _wr_static_mesh_unit_rectangle_new(createOutlineMesh);

    _wr_renderable_set_mesh(this._wrenRenderable, wrenMesh);

    this.updateSize();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  updateLineScale() {
    if (!this._isAValidBoundingObject())
      return;

    const offset = _wr_config_get_line_scale() / WbGeometry.LINE_SCALE_FACTOR;

    // allow the bounding sphere to scale down
    const scaleY = 0.1 * Math.min(this.size.x, this.size.y);
    wr_transform_set_scale(this.wrenNode, _wrjs_array3(this.size.x * (1.0 + offset), scaleY, this.size.y * (1.0 + offset)));
  }

  updateScale() {
    // allow the bounding sphere to scale down
    const scaleY = 0.1 * Math.min(this.size.x, this.size.y);

    const scale = _wrjs_array3(this.size.x, scaleY, this.size.y);
    _wr_transform_set_scale(this.wrenNode, scale);
  }

  updateSize() {
    if (super.isInBoundingObject())
      this.updateLineScale();
    else
      this.updateScale();
  }

  // Private functions

  _isSuitableForInsertionInBoundingObject() {
    return super._isSuitableForInsertionInBoundingObject() && !(this.size.x <= 0.0 || this.size.y <= 0.0);
  }
}class WbPointLight extends WbLight {
  constructor(id, on, attenuation, color, intensity, location, radius, ambientIntensity, castShadows, parent) {
    super(id, on, color, intensity, castShadows, ambientIntensity);
    this.attenuation = attenuation;
    this.location = location;
    this.radius = radius;

    if (typeof parent !== 'undefined')
      this.parent = parent.id;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbPointLight(customID, this.on, this.attenuation, this.color, this.intensity, this.location, this.radius, this.ambientIntensity, this.castShadows);
  }

  createWrenObjects() {
    this._wrenLight = _wr_point_light_new();
    this._attachToUpperTransform();
    super.createWrenObjects();

    this._applyLightAttenuationToWren();
    this._applyNodeLocationToWren();
  }

  delete() {
    if (this.wrenObjectsCreatedCalled) {
      this._detachFromUpperTransform();
      _wr_node_delete(this._wrenLight);
    }

    super.delete();
  }

  // Private functions

  _attachToUpperTransform() {
    const upperTransform = findUpperTransform(this);

    if (typeof upperTransform !== 'undefined')
      _wr_transform_attach_child(upperTransform.wrenNode, this._wrenLight);
  }

  _applyLightAttenuationToWren() {
    _wr_point_light_set_radius(this._wrenLight, this.radius);
    _wr_point_light_set_attenuation(this._wrenLight, this.attenuation.x, this.attenuation.y, this.attenuation.z);
  }

  _applyLightColorToWren() {
    const pointer = _wrjs_array3(this.color.x, this.color.y, this.color.z);

    _wr_point_light_set_color(this._wrenLight, pointer);
  }

  _applyLightIntensityToWren() {
    _wr_point_light_set_intensity(this._wrenLight, this.intensity);
  }

  _applyLightShadowsToWren() {
    _wr_point_light_set_cast_shadows(this._wrenLight, this.castShadows);
  }

  _applyLightVisibilityToWren() {
    _wr_point_light_set_on(this._wrenLight, this.on);

    const maxCount = _wr_config_get_max_active_point_light_count();
    const activeCount = _wr_scene_get_active_point_light_count(_wr_scene_get_instance());
    if (activeCount === maxCount)
      console.log("Maximum number of active point lights has been reached, newly added lights won't be rendered.");
  }

  _applyNodeLocationToWren() {
    const position = _wrjs_array3(this.location.x, this.location.y, this.location.z);
    _wr_point_light_set_position_relative(this._wrenLight, position);
  }

  _detachFromUpperTransform() {
    const node = this._wrenLight;
    const parent = _wr_node_get_parent(node);
    if (typeof parent !== 'undefined')
      _wr_transform_detach_child(parent, node);
  }
}class WbPointSet extends WbGeometry {
  constructor(id, coord, color) {
    super(id);
    this.coord = coord;
    this.color = color;

    this._isShadedGeometryPickable = false;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbPointSet(customID, this.coord, this.color);
  }

  createWrenObjects() {
    super.createWrenObjects();
    _wr_config_enable_point_size(true);
    this._updateCoord();
    this._buildWrenMesh();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  setWrenMaterial(material, castShadows) {
    super.setWrenMaterial(material, castShadows);

    if (typeof material !== 'undefined') {
      _wr_material_set_default_program(material, WbWrenShaders.pointSetShader());
      if (typeof this.color !== 'undefined')
        _wr_phong_material_set_color_per_vertex(material, true);
      else
        _wr_phong_material_set_color_per_vertex(material, false);
    }
  }

  // Private functions

  _buildWrenMesh() {
    super._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    if (typeof this.coord === 'undefined' || this.coord.length === 0)
      return;

    super._computeWrenRenderable();

    const coordsData = [];
    let colorData;
    if (typeof this.color !== 'undefined')
      colorData = [];

    const coordsCount = this._computeCoordsAndColorData(coordsData, colorData);

    const coordsDataPointer = arrayXPointerFloat(coordsData);
    const colorDataPointer = arrayXPointerFloat(colorData);
    this._wrenMesh = _wr_static_mesh_point_set_new(coordsCount, coordsDataPointer, colorDataPointer);

    _free(coordsDataPointer);
    _free(colorDataPointer);

    _wr_renderable_set_cast_shadows(this._wrenRenderable, false);
    _wr_renderable_set_receive_shadows(this._wrenRenderable, false);
    _wr_renderable_set_drawing_mode(this._wrenRenderable, Enum.WR_RENDERABLE_DRAWING_MODE_POINTS);
    _wr_renderable_set_point_size(this._wrenRenderable, 4.0);
    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);
  }

  _computeCoordsAndColorData(coordsData, colorData) {
    if (typeof this.coord === 'undefined')
      return 0;

    let count = 0;
    if (typeof colorData !== 'undefined') {
      const size = Math.min(this.coord.length, this.color.length);
      for (let i = 0; i < size; i++) {
        coordsData[3 * count] = this.coord[i].x;
        coordsData[3 * count + 1] = this.coord[i].y;
        coordsData[3 * count + 2] = this.coord[i].z;
        colorData[3 * count] = this.color[i].x;
        colorData[3 * count + 1] = this.color[i].y;
        colorData[3 * count + 2] = this.color[i].z;
        count++;
      }
    } else {
      for (let i = 0; i < this.coord.length; i++) {
        coordsData[3 * count] = this.coord[i].x;
        coordsData[3 * count + 1] = this.coord[i].y;
        coordsData[3 * count + 2] = this.coord[i].z;
        count++;
      }
    }
    return count;
  }

  _updateCoord() {
    if (this.wrenObjectsCreatedCalled)
      this._buildWrenMesh();
  }
}class WbWrenPostProcessingEffects {
  static bloom(width, height, textureFormat) {
    const bloomEffect = _wr_post_processing_effect_new();
    _wr_post_processing_effect_set_drawing_index(bloomEffect, WbWrenRenderingContext.PP_BLOOM);

    const colorPassThrough = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [colorPassThrough, 'colorPassThrough']);
    _wr_post_processing_effect_pass_set_program(colorPassThrough, WbWrenShaders.passThroughShader());
    _wr_post_processing_effect_pass_set_output_size(colorPassThrough, width, height);
    _wr_post_processing_effect_pass_set_alpha_blending(colorPassThrough, false);
    _wr_post_processing_effect_pass_set_input_texture_count(colorPassThrough, 1);
    _wr_post_processing_effect_pass_set_output_texture_count(colorPassThrough, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(colorPassThrough, 0, textureFormat);
    _wr_post_processing_effect_append_pass(bloomEffect, colorPassThrough);

    const brightPass = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [brightPass, 'brightPassFilter']);
    _wr_post_processing_effect_pass_set_program(brightPass, WbWrenShaders.brightPassShader());
    _wr_post_processing_effect_pass_set_output_size(brightPass, width, height);
    _wr_post_processing_effect_pass_set_alpha_blending(brightPass, false);
    _wr_post_processing_effect_pass_set_input_texture_count(brightPass, 1);
    _wr_post_processing_effect_pass_set_output_texture_count(brightPass, 1);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(brightPass, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_output_texture_format(brightPass, 0, textureFormat);
    _wr_post_processing_effect_append_pass(bloomEffect, brightPass);

    const blurPasses = [];
    const downsamplePasses = [];

    for (let i = 0; i < 6; ++i) {
      const blurPass = _wr_post_processing_effect_pass_new();
      Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [blurPass, 'blurPass' + i]);
      _wr_post_processing_effect_pass_set_program(blurPass, WbWrenShaders.gaussianBlur13TapShader());
      _wr_post_processing_effect_pass_set_output_size(blurPass, width / (1 << i), height / (1 << i));
      _wr_post_processing_effect_pass_set_input_texture_count(blurPass, 2);
      _wr_post_processing_effect_pass_set_alpha_blending(blurPass, false);
      _wr_post_processing_effect_pass_set_input_texture_interpolation(blurPass, 0, true);
      _wr_post_processing_effect_pass_set_input_texture_interpolation(blurPass, 1, true);
      _wr_post_processing_effect_pass_set_input_texture_wrap_mode(blurPass, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
      _wr_post_processing_effect_pass_set_input_texture_wrap_mode(blurPass, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
      _wr_post_processing_effect_pass_set_output_texture_count(blurPass, 1);
      _wr_post_processing_effect_pass_set_output_texture_format(blurPass, 0, textureFormat);
      _wr_post_processing_effect_pass_set_iteration_count(blurPass, 2);
      _wr_post_processing_effect_append_pass(bloomEffect, blurPass);
      blurPasses[i] = blurPass;

      const downsamplePass = _wr_post_processing_effect_pass_new();
      Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [downsamplePass, 'downsamplePass' + i]);
      _wr_post_processing_effect_pass_set_program(downsamplePass, WbWrenShaders.passThroughShader());
      _wr_post_processing_effect_pass_set_output_size(downsamplePass, width / (2 << i), height / (2 << i));
      _wr_post_processing_effect_pass_set_input_texture_count(downsamplePass, 1);
      _wr_post_processing_effect_pass_set_alpha_blending(downsamplePass, false);
      _wr_post_processing_effect_pass_set_input_texture_interpolation(downsamplePass, 0, true);
      _wr_post_processing_effect_pass_set_input_texture_wrap_mode(downsamplePass, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
      _wr_post_processing_effect_pass_set_output_texture_count(downsamplePass, 1);
      _wr_post_processing_effect_pass_set_output_texture_format(downsamplePass, 0, textureFormat);
      _wr_post_processing_effect_append_pass(bloomEffect, downsamplePass);
      downsamplePasses[i] = downsamplePass;
    }

    const blendPass = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [blendPass, 'blendBloom']);
    _wr_post_processing_effect_pass_set_alpha_blending(blendPass, false);
    _wr_post_processing_effect_pass_set_program(blendPass, WbWrenShaders.bloomBlendShader());
    _wr_post_processing_effect_pass_set_output_size(blendPass, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(blendPass, 7);

    for (let i = 0; i < 7; ++i)
      _wr_post_processing_effect_pass_set_input_texture_wrap_mode(blendPass, i, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);

    _wr_post_processing_effect_pass_set_output_texture_count(blendPass, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(blendPass, 0, textureFormat);
    _wr_post_processing_effect_append_pass(bloomEffect, blendPass);

    _wr_post_processing_effect_connect(bloomEffect, colorPassThrough, 0, blendPass, 0);
    _wr_post_processing_effect_connect(bloomEffect, brightPass, 0, blurPasses[0], 0);
    for (let i = 0; i < 5; ++i) {
      _wr_post_processing_effect_connect(bloomEffect, blurPasses[i], 0, downsamplePasses[i], 0);
      _wr_post_processing_effect_connect(bloomEffect, blurPasses[i], 0, blurPasses[i], 1);
      _wr_post_processing_effect_connect(bloomEffect, downsamplePasses[i], 0, blurPasses[i + 1], 0);
      _wr_post_processing_effect_connect(bloomEffect, blurPasses[i], 0, blendPass, i + 1);
    }

    _wr_post_processing_effect_set_result_program(bloomEffect, WbWrenShaders.passThroughShader());
    return bloomEffect;
  }

  static clearResources() {
    if (WbWrenPostProcessingEffects.smaaAreaTexture !== 'undefined')
      _wr_texture_delete(WbWrenPostProcessingEffects.smaaAreaTexture);

    if (WbWrenPostProcessingEffects.smaaSearchTexture !== 'undefined')
      _wr_texture_delete(WbWrenPostProcessingEffects.smaaSearchTexture);

    if (WbWrenPostProcessingEffects.gtaoNoiseTexture !== 'undefined')
      _wr_texture_delete(WbWrenPostProcessingEffects.gtaoNoiseTexture);

    WbWrenPostProcessingEffects.smaaAreaTexture = undefined;
    WbWrenPostProcessingEffects.smaaSearchTexture = undefined;
    WbWrenPostProcessingEffects.gtaoNoiseTexture = undefined;
  }

  static gtao(width, height, textureFormat, depthTexture, normalTexture, halfRes) {
    const gtaoEffect = _wr_post_processing_effect_new();
    _wr_post_processing_effect_set_drawing_index(gtaoEffect, WbWrenRenderingContext.PP_GTAO);

    const colorPassThrough = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [colorPassThrough, 'colorPassThrough']);
    _wr_post_processing_effect_pass_set_program(colorPassThrough, WbWrenShaders.passThroughShader());
    _wr_post_processing_effect_pass_set_output_size(colorPassThrough, width, height);
    _wr_post_processing_effect_pass_set_alpha_blending(colorPassThrough, false);
    _wr_post_processing_effect_pass_set_input_texture_count(colorPassThrough, 1);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(colorPassThrough, 0, false);
    _wr_post_processing_effect_pass_set_output_texture_count(colorPassThrough, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(colorPassThrough, 0, textureFormat);
    _wr_post_processing_effect_append_pass(gtaoEffect, colorPassThrough);

    let depthDownsamplePassThrough, normalDownsamplePassThrough;

    if (halfRes) {
      depthDownsamplePassThrough = _wr_post_processing_effect_pass_new();
      Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [depthDownsamplePassThrough, 'depthDownsamplePassThrough']);
      _wr_post_processing_effect_pass_set_program(depthDownsamplePassThrough, WbWrenShaders.passThroughShader());
      _wr_post_processing_effect_pass_set_output_size(depthDownsamplePassThrough, width / 2, height / 2);
      _wr_post_processing_effect_pass_set_input_texture_count(depthDownsamplePassThrough, 1);
      _wr_post_processing_effect_pass_set_alpha_blending(depthDownsamplePassThrough, false);
      _wr_post_processing_effect_pass_set_input_texture(depthDownsamplePassThrough, 0, depthTexture);
      _wr_post_processing_effect_pass_set_input_texture_interpolation(depthDownsamplePassThrough, 0, false);
      _wr_post_processing_effect_pass_set_output_texture_count(depthDownsamplePassThrough, 1);
      _wr_post_processing_effect_pass_set_output_texture_format(depthDownsamplePassThrough, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_R32F);
      _wr_post_processing_effect_append_pass(gtaoEffect, depthDownsamplePassThrough);

      normalDownsamplePassThrough = _wr_post_processing_effect_pass_new();
      Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [normalDownsamplePassThrough, 'normalDownsamplePassThrough']);
      _wr_post_processing_effect_pass_set_program(normalDownsamplePassThrough, WbWrenShaders.passThroughShader());
      _wr_post_processing_effect_pass_set_alpha_blending(normalDownsamplePassThrough, false);
      _wr_post_processing_effect_pass_set_output_size(normalDownsamplePassThrough, width / 2, height / 2);
      _wr_post_processing_effect_pass_set_input_texture_count(normalDownsamplePassThrough, 1);
      _wr_post_processing_effect_pass_set_input_texture(normalDownsamplePassThrough, 0, normalTexture);
      _wr_post_processing_effect_pass_set_input_texture_interpolation(normalDownsamplePassThrough, 0, false);
      _wr_post_processing_effect_pass_set_output_texture_count(normalDownsamplePassThrough, 1);
      _wr_post_processing_effect_pass_set_output_texture_format(normalDownsamplePassThrough, 0, textureFormat);
      _wr_post_processing_effect_append_pass(gtaoEffect, normalDownsamplePassThrough);
    }

    const gtaoForwardPass = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [gtaoForwardPass, 'gtaoForwardPass']);
    _wr_post_processing_effect_pass_set_program(gtaoForwardPass, WbWrenShaders.gtaoShader());
    _wr_post_processing_effect_pass_set_input_texture_count(gtaoForwardPass, 3);

    if (halfRes)
      _wr_post_processing_effect_pass_set_output_size(gtaoForwardPass, width / 2, height / 2);
    else {
      _wr_post_processing_effect_pass_set_output_size(gtaoForwardPass, width, height);
      _wr_post_processing_effect_pass_set_input_texture(gtaoForwardPass, 0, depthTexture);
      _wr_post_processing_effect_pass_set_input_texture(gtaoForwardPass, 1, normalTexture);
    }

    _wr_post_processing_effect_pass_set_input_texture(gtaoForwardPass, 2, WbWrenPostProcessingEffects.gtaoNoiseTexture);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(gtaoForwardPass, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(gtaoForwardPass, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(gtaoForwardPass, 2, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(gtaoForwardPass, 0, false);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(gtaoForwardPass, 1, false);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(gtaoForwardPass, 2, false);
    _wr_post_processing_effect_pass_set_clear_before_draw(gtaoForwardPass, true);
    _wr_post_processing_effect_pass_set_alpha_blending(gtaoForwardPass, false);
    _wr_post_processing_effect_pass_set_output_texture_count(gtaoForwardPass, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(gtaoForwardPass, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RED);
    _wr_post_processing_effect_append_pass(gtaoEffect, gtaoForwardPass);

    const spatialDenoise = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [spatialDenoise, 'spatialDenoise']);
    _wr_post_processing_effect_pass_set_program(spatialDenoise, WbWrenShaders.gtaoSpatialDenoiseShader());

    if (halfRes)
      _wr_post_processing_effect_pass_set_output_size(spatialDenoise, width / 2, height / 2);
    else
      _wr_post_processing_effect_pass_set_output_size(spatialDenoise, width, height);

    _wr_post_processing_effect_pass_set_input_texture_count(spatialDenoise, 2);
    _wr_post_processing_effect_pass_set_input_texture(spatialDenoise, 1, depthTexture);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(spatialDenoise, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(spatialDenoise, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(spatialDenoise, 0, true);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(spatialDenoise, 1, false);
    _wr_post_processing_effect_pass_set_alpha_blending(spatialDenoise, false);
    _wr_post_processing_effect_pass_set_clear_before_draw(spatialDenoise, true);
    _wr_post_processing_effect_pass_set_output_texture_count(spatialDenoise, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(spatialDenoise, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RED);
    _wr_post_processing_effect_append_pass(gtaoEffect, spatialDenoise);

    const temporalDenoise = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [temporalDenoise, 'temporalDenoise']);
    _wr_post_processing_effect_pass_set_program(temporalDenoise, WbWrenShaders.gtaoTemporalDenoiseShader());
    _wr_post_processing_effect_pass_set_output_size(temporalDenoise, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(temporalDenoise, 4);
    _wr_post_processing_effect_pass_set_input_texture(temporalDenoise, 3, depthTexture);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(temporalDenoise, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(temporalDenoise, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(temporalDenoise, 2, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(temporalDenoise, 3, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(temporalDenoise, 0, true);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(temporalDenoise, 1, true);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(temporalDenoise, 2, false);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(temporalDenoise, 3, false);
    _wr_post_processing_effect_pass_set_alpha_blending(temporalDenoise, false);
    _wr_post_processing_effect_pass_set_clear_before_draw(temporalDenoise, true);
    _wr_post_processing_effect_pass_set_output_texture_count(temporalDenoise, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(temporalDenoise, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RED);
    _wr_post_processing_effect_append_pass(gtaoEffect, temporalDenoise);

    const finalBlend = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [finalBlend, 'FinalBlend']);
    _wr_post_processing_effect_pass_set_program(finalBlend, WbWrenShaders.gtaoCombineShader());
    _wr_post_processing_effect_pass_set_output_size(finalBlend, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(finalBlend, 3);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(finalBlend, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(finalBlend, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(finalBlend, 2, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(finalBlend, 0, false);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(finalBlend, 1, false);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(finalBlend, 2, false);
    _wr_post_processing_effect_pass_set_clear_before_draw(finalBlend, true);
    _wr_post_processing_effect_pass_set_input_texture(finalBlend, 2, depthTexture);
    _wr_post_processing_effect_pass_set_output_texture_count(finalBlend, 3);
    _wr_post_processing_effect_pass_set_output_texture_format(finalBlend, 0, textureFormat);
    _wr_post_processing_effect_pass_set_output_texture_format(finalBlend, 1, Enum.WR_TEXTURE_INTERNAL_FORMAT_RED);
    _wr_post_processing_effect_pass_set_output_texture_format(finalBlend, 2, Enum.WR_TEXTURE_INTERNAL_FORMAT_R32F);
    _wr_post_processing_effect_append_pass(gtaoEffect, finalBlend);

    // color texture for blending at the end
    _wr_post_processing_effect_connect(gtaoEffect, colorPassThrough, 0, finalBlend, 0);

    // downsampled textures for half-res AO
    if (halfRes) {
      _wr_post_processing_effect_connect(gtaoEffect, depthDownsamplePassThrough, 0, gtaoForwardPass, 0);
      _wr_post_processing_effect_connect(gtaoEffect, normalDownsamplePassThrough, 0, gtaoForwardPass, 1);
    }

    // denoising
    _wr_post_processing_effect_connect(gtaoEffect, gtaoForwardPass, 0, spatialDenoise, 0);
    _wr_post_processing_effect_connect(gtaoEffect, spatialDenoise, 0, temporalDenoise, 1);
    _wr_post_processing_effect_connect(gtaoEffect, temporalDenoise, 0, finalBlend, 1);

    // loopbacks for temporal
    _wr_post_processing_effect_connect(gtaoEffect, finalBlend, 1, temporalDenoise, 0);
    _wr_post_processing_effect_connect(gtaoEffect, finalBlend, 2, temporalDenoise, 2);

    _wr_post_processing_effect_set_result_program(gtaoEffect, WbWrenShaders.passThroughShader());

    return gtaoEffect;
  }

  static loadResources(smaaAreaTexture, smaaSearchTexture, gtaoNoiseTexture) {
    WbWrenPostProcessingEffects.smaaAreaTexture = WbWrenPostProcessingEffects.loadImage(smaaAreaTexture);
    WbWrenPostProcessingEffects.smaaSearchTexture = WbWrenPostProcessingEffects.loadImage(smaaSearchTexture);
    WbWrenPostProcessingEffects.gtaoNoiseTexture = WbWrenPostProcessingEffects.loadImage(gtaoNoiseTexture);
  }

  static loadImage(image) {
    const targetTexture = _wr_texture_2d_new();
    _wr_texture_set_translucent(targetTexture, true);
    _wr_texture_set_size(targetTexture, image.width, image.height);

    const bitsPointer = arrayXPointer(image.bits);
    _wr_texture_2d_set_data(targetTexture, bitsPointer);
    Module.ccall('wr_texture_2d_set_file_path', null, ['number', 'string'], [targetTexture, image.url]);
    _wr_texture_2d_set_cache_persistency(targetTexture, true);
    _wr_texture_set_translucent(targetTexture, image.isTranslucent);
    _wr_texture_setup(targetTexture);
    _free(bitsPointer);
    return targetTexture;
  }

  static smaa(width, height, textureFormat) {
    const smaaEffect = _wr_post_processing_effect_new();
    _wr_post_processing_effect_set_drawing_index(smaaEffect, WbWrenRenderingContext.PP_SMAA);

    const passThrough = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [passThrough, 'LensFlarePassToBlend']);
    _wr_post_processing_effect_pass_set_program(passThrough, WbWrenShaders.passThroughShader());
    _wr_post_processing_effect_pass_set_output_size(passThrough, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(passThrough, 1);
    _wr_post_processing_effect_pass_set_alpha_blending(passThrough, false);
    _wr_post_processing_effect_pass_set_output_texture_count(passThrough, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(passThrough, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA8);
    _wr_post_processing_effect_append_pass(smaaEffect, passThrough);

    const edgeDetection = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [edgeDetection, 'EdgeDetect']);
    _wr_post_processing_effect_pass_set_program(edgeDetection, WbWrenShaders.smaaEdgeDetectionShader());
    _wr_post_processing_effect_pass_set_output_size(edgeDetection, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(edgeDetection, 1);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(edgeDetection, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_clear_before_draw(edgeDetection, true);
    _wr_post_processing_effect_pass_set_output_texture_count(edgeDetection, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(edgeDetection, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RG8);
    _wr_post_processing_effect_append_pass(smaaEffect, edgeDetection);

    const weightCalculation = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [weightCalculation, 'WeightCalculation']);
    _wr_post_processing_effect_pass_set_program(weightCalculation, WbWrenShaders.smaaBlendingWeightCalculationShader());
    _wr_post_processing_effect_pass_set_output_size(weightCalculation, width, height);
    _wr_post_processing_effect_pass_set_input_texture_count(weightCalculation, 3);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(weightCalculation, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(weightCalculation, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(weightCalculation, 2, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture(weightCalculation, 1, WbWrenPostProcessingEffects.smaaAreaTexture);
    _wr_post_processing_effect_pass_set_input_texture(weightCalculation, 2, WbWrenPostProcessingEffects.smaaSearchTexture);
    _wr_post_processing_effect_pass_set_input_texture_interpolation(weightCalculation, 2, false);
    _wr_post_processing_effect_pass_set_clear_before_draw(weightCalculation, true);
    _wr_post_processing_effect_pass_set_alpha_blending(weightCalculation, false);
    _wr_post_processing_effect_pass_set_output_texture_count(weightCalculation, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(weightCalculation, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA8);
    _wr_post_processing_effect_append_pass(smaaEffect, weightCalculation);

    const finalBlend = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [finalBlend, 'FinalBlend']);
    _wr_post_processing_effect_pass_set_program(finalBlend, WbWrenShaders.smaaFinalBlendShader());
    _wr_post_processing_effect_pass_set_output_size(finalBlend, width, height);
    _wr_post_processing_effect_pass_set_alpha_blending(finalBlend, false);
    _wr_post_processing_effect_pass_set_input_texture_count(finalBlend, 2);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(finalBlend, 0, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_input_texture_wrap_mode(finalBlend, 1, Enum.WR_TEXTURE_WRAP_MODE_CLAMP_TO_EDGE);
    _wr_post_processing_effect_pass_set_output_texture_count(finalBlend, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(finalBlend, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGB8);
    _wr_post_processing_effect_append_pass(smaaEffect, finalBlend);

    _wr_post_processing_effect_connect(smaaEffect, passThrough, 0, finalBlend, 0);
    _wr_post_processing_effect_connect(smaaEffect, edgeDetection, 0, weightCalculation, 0);
    _wr_post_processing_effect_connect(smaaEffect, weightCalculation, 0, finalBlend, 1);

    _wr_post_processing_effect_set_result_program(smaaEffect, WbWrenShaders.passThroughShader());

    return smaaEffect;
  }
}class WbScene {
  constructor(smaaAreaTexture, smaaSearchTexture, gtaoNoiseTexture) {
    _wrjs_init_context(canvas.clientWidth, canvas.clientHeight);

    _wr_scene_init(_wr_scene_get_instance());

    _wr_gl_state_set_context_active(true);

    this.updateFrameBuffer();

    _wr_scene_set_fog_program(_wr_scene_get_instance(), WbWrenShaders.fogShader());
    _wr_scene_set_shadow_volume_program(_wr_scene_get_instance(), WbWrenShaders.shadowVolumeShader());

    WbWrenPostProcessingEffects.loadResources(smaaAreaTexture, smaaSearchTexture, gtaoNoiseTexture);
    this._updateWrenViewportDimensions();
  }

  destroy() {
    WbWrenPostProcessingEffects.clearResources();

    if (typeof this._wrenMainFrameBuffer !== 'undefined')
      _wr_frame_buffer_delete(this._wrenMainFrameBuffer);

    if (typeof this._wrenMainFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenMainFrameBufferTexture);

    if (typeof this._wrenNormalFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenNormalFrameBufferTexture);

    if (typeof this._wrenDepthFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenDepthFrameBufferTexture);

    this._wrenMainFrameBuffer = undefined;
    this._wrenMainFrameBufferTexture = undefined;
    this._wrenNormalFrameBufferTexture = undefined;
    this._wrenDepthFrameBufferTexture = undefined;

    WbWorld.instance.scene = undefined;
  }

  updateFrameBuffer() {
    if (typeof this._wrenMainFrameBuffer !== 'undefined')
      _wr_frame_buffer_delete(this._wrenMainFrameBuffer);

    if (typeof this._wrenMainFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenMainFrameBufferTexture);

    if (typeof this._wrenNormalFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenNormalFrameBufferTexture);

    if (typeof this._wrenDepthFrameBufferTexture !== 'undefined')
      _wr_texture_delete(this._wrenDepthFrameBufferTexture);

    this._wrenMainFrameBuffer = _wr_frame_buffer_new();
    _wr_frame_buffer_set_size(this._wrenMainFrameBuffer, canvas.width, canvas.height);

    this._wrenMainFrameBufferTexture = _wr_texture_rtt_new();
    _wr_texture_set_internal_format(this._wrenMainFrameBufferTexture, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA16F);

    this._wrenNormalFrameBufferTexture = _wr_texture_rtt_new();

    _wr_texture_set_internal_format(this._wrenNormalFrameBufferTexture, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA8);
    _wr_frame_buffer_append_output_texture(this._wrenMainFrameBuffer, this._wrenMainFrameBufferTexture);
    if (GtaoLevel < 1)
      _wr_frame_buffer_append_output_texture_disable(this._wrenMainFrameBuffer, this._wrenNormalFrameBufferTexture);
    else
      _wr_frame_buffer_append_output_texture(this._wrenMainFrameBuffer, this._wrenNormalFrameBufferTexture);
    _wr_frame_buffer_enable_depth_buffer(this._wrenMainFrameBuffer, true);

    this._wrenDepthFrameBufferTexture = _wr_texture_rtt_new();
    _wr_texture_set_internal_format(this._wrenDepthFrameBufferTexture, Enum.WR_TEXTURE_INTERNAL_FORMAT_DEPTH24_STENCIL8);
    _wr_frame_buffer_set_depth_texture(this._wrenMainFrameBuffer, this._wrenDepthFrameBufferTexture);

    _wr_frame_buffer_setup(this._wrenMainFrameBuffer);
    _wr_viewport_set_frame_buffer(_wr_scene_get_viewport(_wr_scene_get_instance()), this._wrenMainFrameBuffer);

    _wr_viewport_set_size(_wr_scene_get_viewport(_wr_scene_get_instance()), canvas.width, canvas.height);
  }

  // Private functions
  _updateWrenViewportDimensions() {
    _wr_viewport_set_pixel_ratio(_wr_scene_get_viewport(_wr_scene_get_instance()), 1);
  }
}class WbShape extends WbBaseNode {
  constructor(id, castShadow, isPickable, geometry, appearance) {
    super(id);
    this.castShadow = castShadow;
    this.isPickable = isPickable;

    this.appearance = appearance;
    this.geometry = geometry;
  }

  applyMaterialToGeometry() {
    if (!this.wrenMaterial)
      this._createWrenMaterial(Enum.WR_MATERIAL_PHONG);
    if (this.geometry) {
      if (this.appearance instanceof WbAppearance) {
        if (this.appearance.wrenObjectsCreatedCalled)
          this.wrenMaterial = this.appearance.modifyWrenMaterial(this.wrenMaterial);
        else
          this.wrenMaterial = WbAppearance.fillWrenDefaultMaterial(this.wrenMaterial);
      } else if ((this.appearance instanceof WbPBRAppearance) && !(this.geometry instanceof WbPointSet)) {
        this._createWrenMaterial();
        if (this.appearance.wrenObjectsCreatedCalled)
          this.wrenMaterial = this.appearance.modifyWrenMaterial(this.wrenMaterial);
      } else
        this.wrenMaterial = WbAppearance.fillWrenDefaultMaterial(this.wrenMaterial);
      this.geometry.setWrenMaterial(this.wrenMaterial, this.castShadow);
    }
  }

  async clone(customID) {
    let geometry, appearance;
    if (typeof this.geometry !== 'undefined') {
      geometry = this.geometry.clone(getAnId());
      geometry.parent = customID;
      WbWorld.instance.nodes.set(geometry.id, geometry);
    }

    if (typeof this.appearance !== 'undefined') {
      appearance = await this.appearance.clone(getAnId());
      appearance.parent = customID;
      WbWorld.instance.nodes.set(appearance.id, appearance);
    }

    this.useList.push(customID);
    return new WbShape(customID, this.castShadow, this.isPickable, geometry, appearance);
  }

  createWrenObjects() {
    super.createWrenObjects();
    if (typeof this.appearance !== 'undefined')
      this.appearance.createWrenObjects();

    if (typeof this.geometry !== 'undefined') {
      this.geometry.createWrenObjects();

      this.applyMaterialToGeometry();
    }
  }

  delete(isBoundingObject) {
    if (typeof this.parent === 'undefined') {
      const index = WbWorld.instance.sceneTree.indexOf(this);
      WbWorld.instance.sceneTree.splice(index, 1);
    } else {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined') {
        if (isBoundingObject)
          parent.isBoundingObject = null;
        else {
          const index = parent.children.indexOf(this);
          parent.children.splice(index, 1);
        }
      }
    }

    if (typeof this.wrenMaterial !== 'undefined') {
      _wr_material_delete(this.wrenMaterial);
      this.wrenMaterial = undefined;
    }

    if (typeof this.appearance !== 'undefined')
      this.appearance.delete();

    if (typeof this.geometry !== 'undefined')
      this.geometry.delete();

    super.delete();
  }

  updateAppearance() {
    if (this.wrenObjectsCreatedCalled)
      this.applyMaterialToGeometry();
  }

  updateBoundingObjectVisibility() {
    if (typeof this.geometry !== 'undefined')
      this.geometry.updateBoundingObjectVisibility();
  }

  updateCastShadows() {
    if (super.isInBoundingObject())
      return;

    if (typeof this.geometry !== 'undefined')
      this.geometry.computeCastShadows(this.castShadow);
  }

  updateIsPickable() {
    if (super.isInBoundingObject())
      return;

    if (typeof this.geometry !== 'undefined')
      this.geometry.setPickable(this.isPickable);
  }

  preFinalize() {
    super.preFinalize();

    if (typeof this.appearance !== 'undefined')
      this.appearance.preFinalize();

    if (typeof this.geometry !== 'undefined')
      this.geometry.preFinalize();

    this.updateAppearance();
  }

  postFinalize() {
    super.postFinalize();

    if (typeof this.appearance !== 'undefined')
      this.appearance.postFinalize();

    if (typeof this.geometry !== 'undefined')
      this.geometry.postFinalize();

    if (!super.isInBoundingObject()) {
      this.updateCastShadows();
      this.updateIsPickable();
    }
  }

  // Private functions

  _createWrenMaterial(type) {
    const defaultColor = _wrjs_array3(1.0, 1.0, 1.0);
    if (typeof this.wrenMaterial !== 'undefined')
      _wr_material_delete(this.wrenMaterial);

    if (type === Enum.WR_MATERIAL_PHONG) {
      this.wrenMaterial = _wr_phong_material_new();
      _wr_phong_material_set_color(this.wrenMaterial, defaultColor);
      _wr_material_set_default_program(this.wrenMaterial, WbWrenShaders.phongShader());
    } else {
      this.wrenMaterial = _wr_pbr_material_new();
      _wr_pbr_material_set_base_color(this.wrenMaterial, defaultColor);
      _wr_material_set_default_program(this.wrenMaterial, WbWrenShaders.pbrShader());
    }
  }
}class WbSphere extends WbGeometry {
  constructor(id, radius, ico, subdivision) {
    super(id);
    this.radius = radius;
    this.ico = ico;
    this.subdivision = subdivision;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbSphere(customID, this.radius, this.ico, this.subdivision);
  }

  createWrenObjects() {
    super.createWrenObjects();
    this._buildWrenMesh();
  }

  delete() {
    _wr_static_mesh_delete(this._wrenMesh);

    super.delete();
  }

  updateLineScale() {
    if (!this._isAValidBoundingObject())
      return;

    const offset = _wr_config_get_line_scale() / WbGeometry.LINE_SCALE_FACTOR;
    const scaledRadius = this.radius * (1.0 + offset);
    _wr_transform_set_scale(this.wrenNode, _wrjs_array3(scaledRadius, scaledRadius, scaledRadius));
  }

  updateScale() {
    const scaledRadius = this.radius;

    _wr_transform_set_scale(this.wrenNode, _wrjs_array3(scaledRadius, scaledRadius, scaledRadius));
  }

  // Private functions

  _isAValidBoundingObject() {
    return super._isAValidBoundingObject() && this.radius > 0;
  }

  _buildWrenMesh() {
    super._deleteWrenRenderable();

    if (typeof this._wrenMesh !== 'undefined') {
      _wr_static_mesh_delete(this._wrenMesh);
      this._wrenMesh = undefined;
    }

    super._computeWrenRenderable();

    const createOutlineMesh = super.isInBoundingObject();
    this._wrenMesh = _wr_static_mesh_unit_sphere_new(this.subdivision, this.ico, false);

    // Restore pickable state
    super.setPickable(this.isPickable);

    _wr_renderable_set_mesh(this._wrenRenderable, this._wrenMesh);

    if (createOutlineMesh)
      this.updateLineScale();
    else
      this.updateScale();
  }
}class WbSpotLight extends WbLight {
  constructor(id, on, attenuation, beamWidth, color, cutOffAngle, direction, intensity, location, radius, ambientIntensity, castShadows, parent) {
    super(id, on, color, intensity, castShadows, ambientIntensity);
    this.attenuation = attenuation;
    this.beamWidth = beamWidth;
    this.cutOffAngle = cutOffAngle;
    this.direction = direction;
    this.location = location;
    this.radius = radius;

    if (typeof parent !== 'undefined')
      this.parent = parent.id;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbSpotLight(customID, this.on, this.attenuation, this.beamWidth, this.color, this.cutOffAngle, this.direction, this.intensity, this.location, this.radius, this.ambientIntensity, this.castShadows);
  }

  createWrenObjects() {
    this._wrenLight = _wr_spot_light_new();
    super.createWrenObjects();
    this._attachToUpperTransform();

    this._applyLightDirectionToWren();
    this.applyLightBeamWidthAndCutOffAngleToWren();
    this._applyLightAttenuationToWren();
    this._applyNodeLocationToWren();
  }

  delete() {
    if (this.wrenObjectsCreatedCalled) {
      this._detachFromUpperTransform();
      _wr_node_delete(this._wrenLight);
    }

    super.delete();
  }

  // Private functions
  _applyLightAttenuationToWren() {
    _wr_spot_light_set_radius(this._wrenLight, this.radius);
    _wr_spot_light_set_attenuation(this._wrenLight, this.attenuation.x, this.attenuation.y, this.attenuation.z);
  }

  applyLightBeamWidthAndCutOffAngleToWren() {
    _wr_spot_light_set_beam_width(this._wrenLight, this.beamWidth);
    _wr_spot_light_set_cutoff_angle(this._wrenLight, this.cutOffAngle);
  }

  _applyLightColorToWren() {
    const pointer = _wrjs_array3(this.color.x, this.color.y, this.color.z);
    _wr_spot_light_set_color(this._wrenLight, pointer);
  }

  _applyLightDirectionToWren() {
    const pointer = _wrjs_array3(this.direction.x, this.direction.y, this.direction.z);
    _wr_spot_light_set_direction(this._wrenLight, pointer);
  }

  _applyLightIntensityToWren() {
    _wr_spot_light_set_intensity(this._wrenLight, this.intensity);
  }

  _applyLightShadowsToWren() {
    _wr_spot_light_set_cast_shadows(this._wrenLight, this.castShadows);
  }

  _applyLightVisibilityToWren() {
    _wr_spot_light_set_on(this._wrenLight, this.on);

    const maxCount = _wr_config_get_max_active_spot_light_count();
    const activeCount = _wr_scene_get_active_spot_light_count(_wr_scene_get_instance());
    if (activeCount === maxCount)
      console.log("Maximum number of active spotlights has been reached, newly added lights won't be rendered.");
  }

  _applyNodeLocationToWren() {
    const pointer = _wrjs_array3(this.location.x, this.location.y, this.location.z);
    _wr_spot_light_set_position_relative(this._wrenLight, pointer);
  }

  _attachToUpperTransform() {
    const upperTransform = findUpperTransform(this);

    if (typeof upperTransform !== 'undefined')
      _wr_transform_attach_child(upperTransform.wrenNode, this._wrenLight);
  }

  _detachFromUpperTransform() {
    const node = this._wrenLight;
    const parent = _wr_node_get_parent(node);
    if (typeof parent !== 'undefined')
      _wr_transform_detach_child(parent, node);
  }
}class WbTextureTransform extends WbBaseNode {
  constructor(id, center, rotation, scale, translation) {
    super(id);
    this.center = center;
    this.rotation = rotation;
    this.scale = scale;
    this.translation = translation;
  }

  clone(customID) {
    this.useList.push(customID);
    return new WbTextureTransform(customID, this.center, this.rotation, this.scale, this.translation);
  }

  delete() {
    if (typeof this.parent !== 'undefined') {
      const parent = WbWorld.instance.nodes.get(this.parent);
      if (typeof parent !== 'undefined')
        parent.textureTransform = undefined;
    }

    this._destroyWrenObjects();

    super.delete();
  }

  modifyWrenMaterial(wrenMaterial) {
    this._destroyWrenObjects();

    // apply translation before rotation
    this._wrenTextureTransform = _wr_texture_transform_new();
    _wr_texture_transform_set_scale(this._wrenTextureTransform, this.scale.x, this.scale.y);
    _wr_texture_transform_set_position(this._wrenTextureTransform, this.translation.x, this.translation.y);
    _wr_texture_transform_set_center(this._wrenTextureTransform, this.center.x, this.center.y);
    _wr_texture_transform_set_rotation(this._wrenTextureTransform, this.rotation);

    _wr_material_set_texture_transform(wrenMaterial, this._wrenTextureTransform);
  }

  // Private functions

  _destroyWrenObjects() {
    if (typeof this._wrenTextureTransform !== 'undefined')
      _wr_texture_transform_delete(this._wrenTextureTransform);
  }
}class WbVector2 {
  constructor(x = 0.0, y = 0.0) {
    this.x = x;
    this.y = y;
  }

  add(vector) {
    return new WbVector2(this.x + vector.x, this.y + vector.y);
  }

  // angle between two vectors (in radians)
  angle(vector) {
    const s = this.dot(vector) / Math.sqrt(this.length2() * vector.length2());
    return (s >= 1.0) ? 0 : (s <= -1.0) ? Math.PI : Math.acos(s);
  }

  div(number) {
    return new WbVector2(this.x / number, this.y / number);
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  equal(vector) {
    return this.x === vector.x && this.y === vector.y;
  }

  get(index) {
    if (index === 0)
      return this.x;
    else if (index === 1)
      return this.y;
  }

  isNull() {
    return this.x === 0.0 && this.y === 0.0;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  length2() {
    return this.x * this.x + this.y * this.y;
  }

  mul(number) {
    return new WbVector2(this.x * number, this.y * number);
  }

  normalize() {
    const result = this.div(this.length());
    this.x = result.x;
    this.y = result.y;
  }

  normalized() {
    return this.div(this.length());
  }

  sub(vector) {
    return new WbVector2(this.x - vector.x, this.y - vector.y);
  }
}class WbWrenAbstractPostProcessingEffect {
  constructor() {
    this.hasBeenSetup = false;
  }

  delete() {
    if (typeof this._wrenViewport !== 'undefined')
      _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);

    _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
  }

  detachFromViewport() {
    if (this._wrenViewport) {
      _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);
      _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
      this._wrenPostProcessingEffect = undefined;
      this._wrenViewport = undefined;
      this.hasBeenSetup = false;
    }
  }
}class WbWrenHdr extends WbWrenAbstractPostProcessingEffect {
  constructor() {
    super();
    this.exposure = 1.0;
  }

  setExposure(exposure) {
    this.exposure = exposure;

    this._applyParametersToWren();
  }

  setup(viewport) {
    if (typeof this._wrenPostProcessingEffect !== 'undefined') {
      // In case we want to update the viewport, the old postProcessingEffect has to be removed first
      if (this._wrenViewport === viewport)
        _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);

      _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
    }

    this._wrenViewport = viewport;

    const width = _wr_viewport_get_width(this._wrenViewport);
    const height = _wr_viewport_get_height(this._wrenViewport);

    this._wrenPostProcessingEffect = this._hdrResolve(width, height);

    this._applyParametersToWren();

    _wr_viewport_add_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);
    _wr_post_processing_effect_setup(this._wrenPostProcessingEffect);

    this.hasBeenSetup = true;
  }

  // Private functions

  _applyParametersToWren() {
    if (!this._wrenPostProcessingEffect)
      return;

    const firstPass = _wr_post_processing_effect_get_first_pass(this._wrenPostProcessingEffect);
    if (typeof this._exposurePointer !== 'undefined')
      _free(this._exposurePointer);
    this._exposurePointer = pointerOnFloat(this.exposure);
    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [firstPass, 'exposure', this._exposurePointer]);
  }

  _hdrResolve(width, height) {
    const hdrResolveEffect = _wr_post_processing_effect_new();
    _wr_post_processing_effect_set_drawing_index(hdrResolveEffect, WbWrenRenderingContext.PP_HDR);

    const hdrPass = _wr_post_processing_effect_pass_new();
    Module.ccall('wr_post_processing_effect_pass_set_name', null, ['number', 'string'], [hdrPass, 'hdrResolve']);
    _wr_post_processing_effect_pass_set_program(hdrPass, WbWrenShaders.hdrResolveShader());
    _wr_post_processing_effect_pass_set_output_size(hdrPass, width, height);
    _wr_post_processing_effect_pass_set_alpha_blending(hdrPass, false);
    _wr_post_processing_effect_pass_set_input_texture_count(hdrPass, 1);
    _wr_post_processing_effect_pass_set_output_texture_count(hdrPass, 1);
    _wr_post_processing_effect_pass_set_output_texture_format(hdrPass, 0, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGB8);
    _wr_post_processing_effect_append_pass(hdrResolveEffect, hdrPass);

    _wr_post_processing_effect_set_result_program(hdrResolveEffect, WbWrenShaders.passThroughShader());

    return hdrResolveEffect;
  }
}class WbWrenGtao extends WbWrenAbstractPostProcessingEffect {
  constructor() {
    super();
    this._halfResolution = false;

    this._near = 0.0;
    this._far = 0.0;
    this._fov = 0.78;
    this._radius = 2.0;
    this._flipNormalY = 0.0;
    this._frameCounter = 0;

    this._clipInfo = [0, 0, 0, 0];
    this._params = [0.0, 0.0, 0.0, 0.0];
    this._rotations = [60.0, 300.0, 180.0, 240.0, 120.0, 0.0];
    this._offsets = [0.0, 0.5, 0.25, 0.75];
    this._previousInverseViewMatrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    this._previousAllocation = false;
  }

  applyOldInverseViewMatrixToWren() {
    if (typeof this._wrenPostProcessingEffect === 'undefined')
      return;

    if (this._previousAllocation)
      _free(this._previousInverseViewMatrixPointer);

    if (typeof this._previousInverseViewMatrix !== 'number') {
      this._previousInverseViewMatrixPointer = arrayXPointerFloat(this._previousInverseViewMatrix);
      this._previousAllocation = true;
    } else {
      this._previousInverseViewMatrixPointer = this._previousInverseViewMatrix;
      this._previousAllocation = false;
    }

    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [this._temporalPass, 'previousInverseViewMatrix', this._previousInverseViewMatrixPointer]);
  }

  copyNewInverseViewMatrix(inverseViewMatrix) {
    this._previousInverseViewMatrix = inverseViewMatrix;
  }

  setFov(fov) {
    this._fov = fov;
    this._applyParametersToWren();
  }

  setHalfResolution(halfResolution) {
    this._halfResolution = halfResolution;
  }

  setQualityLevel(qualityLevel) {
    this._params[2] = 2 << (qualityLevel - 1);
    this._applyParametersToWren();
  }

  setRadius(radius) {
    this._radius = radius;
    this._applyParametersToWren();
  }

  setup(viewport) {
    if (typeof this._wrenPostProcessingEffect !== 'undefined') {
      // In case we want to update the viewport, the old postProcessingEffect has to be removed first
      if (this._wrenViewport === viewport)
        _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);

      _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
    }

    this._wrenViewport = viewport;

    let width = _wr_viewport_get_width(this._wrenViewport);
    let height = _wr_viewport_get_height(this._wrenViewport);

    if (this._halfResolution) {
      width = width <= 1.0 ? 2.0 : width;
      height = height <= 1.0 ? 2.0 : height;
    }

    const viewportFramebuffer = _wr_viewport_get_frame_buffer(this._wrenViewport);

    const depthTexture = _wr_frame_buffer_get_depth_texture(viewportFramebuffer);
    const normalTexture = _wr_frame_buffer_get_output_texture(viewportFramebuffer, 1);

    this._wrenPostProcessingEffect = WbWrenPostProcessingEffects.gtao(width, height, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA16F, depthTexture, normalTexture, this._halfResolution);

    this._gtaoPass = Module.ccall('wr_post_processing_effect_get_pass', 'number', ['number', 'string'], [this._wrenPostProcessingEffect, 'gtaoForwardPass']);
    this._temporalPass = Module.ccall('wr_post_processing_effect_get_pass', 'number', ['number', 'string'], [this._wrenPostProcessingEffect, 'temporalDenoise']);
    this._applyParametersToWren();

    _wr_viewport_set_ambient_occlusion_effect(this._wrenViewport, this._wrenPostProcessingEffect);
    _wr_post_processing_effect_setup(this._wrenPostProcessingEffect);

    this.hasBeenSetup = true;
  }

  // Private functions

  _applyParametersToWren() {
    if (!this._wrenPostProcessingEffect)
      return;

    this._clipInfo[0] = this._near;
    this._clipInfo[1] = this._far ? this._far : 1000000.0;
    this._clipInfo[2] = 0.5 * (_wr_viewport_get_height(this._wrenViewport) / (2.0 * Math.tan(this._fov * 0.5)));

    if (typeof this._clipInfoPointer !== 'undefined')
      _free(this._clipInfoPointer);
    this._clipInfoPointer = arrayXPointerFloat(this._clipInfo);

    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [this._gtaoPass, 'clipInfo', this._clipInfoPointer]);

    this._params[0] = this._rotations[this._frameCounter % 6] / 360.0;
    this._params[1] = this._offsets[Math.floor(this._frameCounter / 6) % 4];

    if (typeof this._paramsPointer !== 'undefined')
      _free(this._paramsPointer);
    this._paramsPointer = arrayXPointerFloat(this._params);
    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [this._gtaoPass, 'params', this._paramsPointer]);

    if (typeof this._radiusPointer !== 'undefined')
      _free(this._radiusPointer);
    this._radiusPointer = pointerOnFloat(this._radius);
    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [this._gtaoPass, 'radius', this._radiusPointer]);

    if (typeof this._flipNormalYPointer !== 'undefined')
      _free(this._flipNormalYPointer);
    this._flipNormalYPointer = pointerOnFloat(this._flipNormalY);
    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [this._gtaoPass, 'flipNormalY', this._flipNormalYPointer]);
    ++this._frameCounter;
  }
}class WbWrenBloom extends WbWrenAbstractPostProcessingEffect {
  constructor() {
    super();
    this.threshold = 10.0;
  }

  setThreshold(threshold) {
    this.threshold = threshold;

    this._applyParametersToWren();
  }

  setup(viewport) {
    if (typeof this._wrenPostProcessingEffect !== 'undefined') {
      // In case we want to update the viewport, the old postProcessingEffect has to be removed first
      if (this._wrenViewport === viewport)
        _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);

      _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
      this._wrenPostProcessingEffect = undefined;
    }

    this._wrenViewport = viewport;

    const width = _wr_viewport_get_width(this._wrenViewport);
    const height = _wr_viewport_get_height(this._wrenViewport);

    // can't use the effect on resolutions smaller than this, it requires 6 passes dividing the viewport each time, so resolutions
    // smaller than 2^6 in width or height preculde the use of this effect
    if (Math.min(width, height) <= 64.0)
      return;

    this._wrenPostProcessingEffect = WbWrenPostProcessingEffects.bloom(width, height, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA16F);

    this._applyParametersToWren();

    _wr_viewport_add_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);
    _wr_post_processing_effect_setup(this._wrenPostProcessingEffect);

    this.hasBeenSetup = true;
  }

  // Private functions

  _applyParametersToWren() {
    if (!this._wrenPostProcessingEffect)
      return;
    const pass = Module.ccall('wr_post_processing_effect_get_pass', 'number', ['number', 'string'], [this._wrenPostProcessingEffect, 'brightPassFilter']);
    if (this._thresholdPointer !== 'undefined')
      _free(this._thresholdPointer);
    this._thresholdPointer = pointerOnFloat(this.threshold);
    Module.ccall('wr_post_processing_effect_pass_set_program_parameter', null, ['number', 'string', 'number'], [pass, 'threshold', this._thresholdPointer]);
  }
}class WbWrenSmaa extends WbWrenAbstractPostProcessingEffect {
  setup(viewport) {
    if (typeof this._wrenPostProcessingEffect === 'undefined') {
      // In case we want to update the viewport, the old postProcessingEffect has to be removed first
      if (this._wrenViewport === viewport)
        _wr_viewport_remove_post_processing_effect(this._wrenViewport, this._wrenPostProcessingEffect);

      _wr_post_processing_effect_delete(this._wrenPostProcessingEffect);
    }

    this._wrenViewport = viewport;

    const width = _wr_viewport_get_width(this._wrenViewport);
    const height = _wr_viewport_get_height(this._wrenViewport);

    this._wrenPostProcessingEffect = WbWrenPostProcessingEffects.smaa(width, height, Enum.WR_TEXTURE_INTERNAL_FORMAT_RGBA8);

    _wr_viewport_set_anti_aliasing_effect(this._wrenViewport, this._wrenPostProcessingEffect);
    _wr_post_processing_effect_setup(this._wrenPostProcessingEffect);

    this.hasBeenSetup = true;
  }
}class WbViewpoint extends WbBaseNode {
  constructor(id, fieldOfView, orientation, position, exposure, bloomThreshold, near, far, followSmoothness, followedId, ambientOcclusionRadius) {
    super(id);

    // the default orientation and position record the initial viewpoint and the modifications due to the follow
    // of an object to allow a smooth reset of the viewpoint
    this.orientation = this._defaultOrientation = orientation;
    this.position = this._defaultPosition = position;

    this.exposure = exposure;
    this.bloomThreshold = bloomThreshold;
    this.near = near;
    this.far = far;
    this.aspectRatio = canvas.width / canvas.height;
    this.fieldOfView = fieldOfView;
    this._fieldOfViewY = M_PI_4;
    this._tanHalfFieldOfViewY = TAN_M_PI_8;
    this.ambientOcclusionRadius = ambientOcclusionRadius;

    this.followSmoothness = followSmoothness;
    this.followedId = followedId;
    this._viewpointForce = new WbVector3();
    this._viewpointVelocity = new WbVector3();

    this._wrenHdr = new WbWrenHdr();
    this._wrenGtao = new WbWrenGtao();
    this._wrenBloom = new WbWrenBloom();
    this._wrenSmaa = new WbWrenSmaa();
  }

  createWrenObjects() {
    super.createWrenObjects();

    this._wrenViewport = _wr_scene_get_viewport(_wr_scene_get_instance());

    _wr_viewport_set_clear_color_rgb(this._wrenViewport, _wrjs_array3(0.0, 0.0, 0.0));
    this._wrenCamera = _wr_viewport_get_camera(this._wrenViewport);
    this._applyPositionToWren();
    this._applyOrientationToWren();
    this._applyNearToWren();
    this._applyFarToWren();
    this._applyFieldOfViewToWren();
    this.updatePostProcessingEffects();
    this._inverseViewMatrix = _wr_transform_get_matrix(this._wrenCamera);
  }

  delete() {
    if (typeof this._wrenSmaa !== 'undefined')
      this._wrenSmaa.delete();

    if (typeof this._wrenHdr !== 'undefined')
      this._wrenHdr.delete();

    if (typeof this._wrenGtao !== 'undefined')
      this._wrenGtao.delete();

    if (typeof this._wrenBloom !== 'undefined')
      this._wrenBloom.delete();
  }

  preFinalize() {
    super.preFinalize();

    this.updateFieldOfView();
    this.updateNear();
    this.updateFar();
  }

  postFinalize() {
    super.postFinalize();

    this.updatePostProcessingEffects();
  }

  resetViewpoint() {
    this.position = this._defaultPosition;
    this.orientation = this._defaultOrientation;
    this.updatePosition();
    this.updateOrientation();
  }

  // Converts screen coordinates to world coordinates
  toWorld(pos) {
    let zFar = this.far;
    if (zFar === 0)
      zFar = WbViewpoint.DEFAULT_FAR;

    const projection = new WbMatrix4();
    projection.set(1.0 / (this.aspectRatio * this._tanHalfFieldOfViewY), 0, 0, 0, 0, 1.0 / this._tanHalfFieldOfViewY, 0, 0, 0, 0, zFar / (this.near - zFar), -(zFar * this.near) / (zFar - this.near), 0, 0, -1, 0);
    const eye = new WbVector3(this.position.x, this.position.y, this.position.z);
    const center = eye.add(direction(this.orientation));
    const upVec = up(this.orientation);

    const f = (center.sub(eye)).normalized();
    const s = f.cross(upVec).normalized();
    const u = s.cross(f);

    const view = new WbMatrix4();
    view.set(-s.x, -s.y, -s.z, s.dot(eye), u.x, u.y, u.z, -u.dot(eye), f.x, f.y, f.z, -f.dot(eye), 0, 0, 0, 1);

    const inverse = projection.mul(view);
    if (!inverse.inverse())
      return;

    let screenCoord = new WbVector4(pos.x, pos.y, pos.z, 1.0);
    screenCoord = inverse.mulByVec4(screenCoord);
    return screenCoord.div(screenCoord.w);
  }

  updateAspectRatio(renderWindowAspectRatio) {
    if (!this.wrenObjectsCreatedCalled)
      return;

    this.aspectRatio = renderWindowAspectRatio;
    _wr_camera_set_aspect_ratio(this._wrenCamera, this.aspectRatio);

    this._updateFieldOfViewY();

    this._applyFieldOfViewToWren();
  }

  updateExposure() {
    if (this.wrenObjectsCreatedCalled && this._wrenHdr)
      this._wrenHdr.setExposure(this.exposure);
  }

  updateFar() {
    if (this.far > 0.0 && this.far < this.near)
      this.far = this.near + 1.0;

    if (this.wrenObjectsCreatedCalled)
      this._applyFarToWren();
  }

  updateFieldOfView() {
    this._updateFieldOfViewY();

    if (this.wrenObjectsCreatedCalled)
      this._applyFieldOfViewToWren();
  }

  updateFollowUp(time, forcePosition) {
    if (typeof this.followedId === 'undefined' || typeof WbWorld.instance.nodes.get(this.followedId) === 'undefined')
      return;

    if (typeof this._viewpointLastUpdate === 'undefined')
      this._viewpointLastUpdate = time;

    const timeInterval = Math.abs(time - this._viewpointLastUpdate) / 1000;
    const mass = ((this.followSmoothness < 0.05) ? 0.0 : ((this.followSmoothness > 1.0) ? 1.0 : this.followSmoothness));

    if (timeInterval > 0) {
      this._viewpointLastUpdate = time;
      let deltaPosition;

      if (typeof this._followedObjectDeltaPosition !== 'undefined')
        this._viewpointForce = this._viewpointForce.add(this._followedObjectDeltaPosition);

      if (forcePosition || mass === 0 || (timeInterval > 0.1 && typeof webots.animation === 'undefined')) {
        deltaPosition = new WbVector3(this._viewpointForce.x, this._viewpointForce.y, this._viewpointForce.z);
        this._viewpointVelocity = new WbVector3();
      } else {
        let acceleration = new WbVector3(this._viewpointForce.x, this._viewpointForce.y, this._viewpointForce.z);
        acceleration = acceleration.mul(timeInterval / mass);
        this._viewpointVelocity = this._viewpointVelocity.add(acceleration);
        const scalarVelocity = this._viewpointVelocity.length();

        let scalarObjectVelocityProjection;
        if (typeof this._followedObjectDeltaPosition !== 'undefined') {
          let objectVelocity = new WbVector3(this._followedObjectDeltaPosition.x, this._followedObjectDeltaPosition.y, this._followedObjectDeltaPosition.z);
          objectVelocity = objectVelocity.div(timeInterval);
          scalarObjectVelocityProjection = objectVelocity.dot(this._viewpointVelocity) / scalarVelocity;
        } else
          scalarObjectVelocityProjection = 0;

        let viewpointFriction = 0.05 / mass;
        if (viewpointFriction > 0 && scalarVelocity > scalarObjectVelocityProjection) {
          const velocityFactor = (scalarVelocity - (scalarVelocity - scalarObjectVelocityProjection) * viewpointFriction) / scalarVelocity;
          this._viewpointVelocity = this._viewpointVelocity.mul(velocityFactor);
        }

        deltaPosition = this._viewpointVelocity.mul(timeInterval);
      }
      this._viewpointForce = this._viewpointForce.sub(deltaPosition);
      this.position = this.position.add(deltaPosition);
      this._defaultPosition = this._defaultPosition.add(deltaPosition);
      this._followedObjectDeltaPosition = undefined;
      this.updatePosition();
    }
  }

  setFollowedObjectDeltaPosition(newPosition, previousPosition) {
    this._followedObjectDeltaPosition = newPosition.sub(previousPosition);
  }

  updateNear() {
    if (this.far > 0.0 && this.far < this.near)
      this.near = this.far;

    if (this.wrenObjectsCreatedCalled)
      this._applyNearToWren();
  }

  updatePosition() {
    if (this.wrenObjectsCreatedCalled)
      this._applyPositionToWren();

    WbWorld.instance.billboards.forEach(id => {
      let billboard = WbWorld.instance.nodes.get(id);
      if (typeof billboard !== 'undefined')
        billboard.updatePosition();
    });
  }

  updatePostProcessingEffects() {
    if (!this.wrenObjectsCreatedCalled)
      return;

    if (this._wrenSmaa) {
      this._wrenSmaa.setup(this._wrenViewport);
    }

    if (this._wrenHdr) {
      this._wrenHdr.setup(this._wrenViewport);
      this.updateExposure();
    }

    if (this._wrenGtao) {
      const qualityLevel = GtaoLevel;
      if (qualityLevel === 0)
        this._wrenGtao.detachFromViewport();
      else {
        this._wrenGtao.setHalfResolution(qualityLevel <= 2);
        this._wrenGtao.setup(this._wrenViewport);
        this.updateNear();
        this.updateFar();
        this._updateFieldOfViewY();
      }
    }

    if (this._wrenBloom) {
      if (this.bloomThreshold === -1.0)
        this._wrenBloom.detachFromViewport();
      else
        this._wrenBloom.setup(this._wrenViewport);

      this._wrenBloom.setThreshold(this.bloomThreshold);
    }

    this.updateAspectRatio(canvas.width / canvas.height);
  }

  updatePostProcessingParameters() {
    if (!this.wrenObjectsCreatedCalled)
      return;

    if (this._wrenHdr)
      this.updateExposure();

    if (this._wrenGtao) {
      if (this.ambientOcclusionRadius === 0.0 || GtaoLevel === 0) {
        this._wrenGtao.detachFromViewport();
        return;
      } else if (!this._wrenGtao.hasBeenSetup)
        this._wrenGtao.setup(this._wrenViewport);

      const qualityLevel = GtaoLevel;
      this.updateNear();
      this._wrenGtao.setRadius(this.ambientOcclusionRadius);
      this._wrenGtao.setQualityLevel(qualityLevel);
      this._wrenGtao.applyOldInverseViewMatrixToWren();
      this._wrenGtao.copyNewInverseViewMatrix(this._inverseViewMatrix);
    }

    if (this._wrenBloom) {
      if (this.bloomThreshold === -1.0) {
        this._wrenBloom.detachFromViewport();
        return;
      } else if (!this._wrenBloom.hasBeenSetup)
        this._wrenBloom.setup(this._wrenViewport);

      this._wrenBloom.setThreshold(this.bloomThreshold);
    }
  }

  updateOrientation() {
    if (this.wrenObjectsCreatedCalled)
      this._applyOrientationToWren();
  }

  // Private functions

  _applyFarToWren() {
    if (this.far > 0.0)
      _wr_camera_set_far(this._wrenCamera, this.far);
    else
      _wr_camera_set_far(this._wrenCamera, WbViewpoint.DEFAULT_FAR);
  }

  _applyFieldOfViewToWren() {
    _wr_camera_set_fovy(this._wrenCamera, this._fieldOfViewY);
    if (this._wrenGtao)
      this._wrenGtao.setFov(this._fieldOfViewY);
  }

  _applyNearToWren() {
    _wr_camera_set_near(this._wrenCamera, this.near);
  }

  _applyOrientationToWren() {
    _wr_camera_set_orientation(this._wrenCamera, _wrjs_array4(this.orientation.w, this.orientation.x, this.orientation.y, this.orientation.z));
  }

  _applyPositionToWren() {
    _wr_camera_set_position(this._wrenCamera, _wrjs_array3(this.position.x, this.position.y, this.position.z));
  }

  _updateFieldOfViewY() {
    this._tanHalfFieldOfViewY = Math.tan(0.5 * this.fieldOfView);

    // According to VRML standards, the meaning of fieldOfView depends on the aspect ratio:
    // the view angle is taken with respect to the largest dimension
    if (this.aspectRatio < 1.0)
      this._fieldOfViewY = this.fieldOfView;
    else {
      this._tanHalfFieldOfViewY /= this.aspectRatio;
      this._fieldOfViewY = 2.0 * Math.atan(this._tanHalfFieldOfViewY);
    }
  }
}

WbViewpoint.DEFAULT_FAR = 1000000.0;function loadHdr(url, onLoad) {
  const xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', url, true);
  xmlhttp.responseType = 'arraybuffer';
  xmlhttp.overrideMimeType('arrayBuffer');
  xmlhttp.onreadystatechange = () => {
    if (xmlhttp.readyState === 4 && (xmlhttp.status === 200 || xmlhttp.status === 0)) { // Some browsers return HTTP Status 0 when using non-http protocol (for file://)
      onLoad(parse(xmlhttp.response));
    }
  };
  xmlhttp.send();
}

function parse(buffer) {
  let dec = new TextDecoder('utf-8');
  let dat = dec.decode(buffer);
  const lines = dat.split('\n');
  let number = lines[3] === '' ? 4 : 3;
  const dimension = lines[number].split(' ');
  let width = parseInt(dimension[1]);
  let height = parseInt(dimension[3]);

  const byteArray = new Uint8Array(buffer);
  byteArray.pos = lines[0].length + lines[1].length + lines[2].length + lines[3].length + 4;

  if (number === 4)
    byteArray.pos += lines[4].length + 1;

  const imageRgbaData = new Uint8Array(byteArray.subarray(byteArray.pos));
  let data;
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
    const e = sourceArray[sourceOffset + 3];
    const scale = Math.pow(2.0, e - 128.0) / 255.0;
    destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
    destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
    destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
  };
  const numElements = (imageRgbaData.length / 4) * 3;
  const floatArray = new Float32Array(numElements);
  for (let j = 0; j < numElements; j++)
    RGBEByteToRGBFloat(imageRgbaData, j * 4, floatArray, j * 3);

  data = floatArray;

  return {
    width: width,
    height: height,
    data: data
  };
}/*
  This module takes an x3d world, parse it and populate the scene.
*/
class Parser {
  constructor(prefix = '') {
    this._prefix = prefix;
    WbWorld.init();
  }

  async parse(text, renderer, parent, callback) {
    let xml = null;
    if (window.DOMParser) {
      const parser = new DOMParser();
      xml = parser.parseFromString(text, 'text/xml');
    }

    if (typeof xml === 'undefined')
      console.error('File to parse not found');
    else {
      const scene = xml.getElementsByTagName('Scene')[0];
      if (typeof scene === 'undefined') {
        const node = xml.getElementsByTagName('nodes')[0];
        if (typeof node === 'undefined')
          console.error('Unknown content, nor Scene, nor Node');
        else
          await this._parseChildren(node, parent);
      } else
        await this._parseNode(scene);
    }

    if (document.getElementById('webotsProgressMessage'))
      document.getElementById('webotsProgressMessage').innerHTML = 'Finalizing...';

    if (typeof WbWorld.instance.viewpoint === 'undefined')
      return;
    WbWorld.instance.viewpoint.finalize();

    WbWorld.instance.sceneTree.forEach(node => {
      node.finalize();
    });

    WbWorld.instance.readyForUpdates = true;

    webots.currentView.x3dScene.resize();
    renderer.render();
    if (document.getElementById('webotsProgress'))
      document.getElementById('webotsProgress').style.display = 'none';
    if (webots.currentView.toolBar) {
      webots.currentView.toolBar.enableToolBarButtons(true);
      if (webots.currentView.runOnLoad === 'real-time')
        webots.currentView.toolBar.realTime(true);
      else if (webots.currentView.runOnLoad === 'run' || webots.currentView.runOnLoad === 'fast')
        webots.currentView.toolBar.run(true);
    }

    if (typeof callback === 'function')
      callback();
  }

  async _parseNode(node, parentNode, isBoundingObject) {
    if (typeof WbWorld.instance === 'undefined')
      WbWorld.init();

    let result;
    if (node.tagName === 'Scene') {
      WbWorld.instance.scene = await this._parseScene(node);
      await this._parseChildren(node, parentNode);
    } else if (node.tagName === 'WorldInfo')
      this._parseWorldInfo(node);
    else if (node.tagName === 'Viewpoint')
      WbWorld.instance.viewpoint = this._parseViewpoint(node);
    else if (node.tagName === 'Background')
      result = await this._parseBackground(node);
    else if (node.tagName === 'Transform')
      result = await this._parseTransform(node, parentNode, isBoundingObject);
    else if (node.tagName === 'Billboard')
      result = await this._parseBillboard(node, parentNode);
    else if (node.tagName === 'Group')
      result = await this._parseGroup(node, parentNode, isBoundingObject);
    else if (node.tagName === 'Shape')
      result = await this._parseShape(node, parentNode, isBoundingObject);
    else if (node.tagName === 'Switch')
      result = await this._parseSwitch(node, parentNode);
    else if (node.tagName === 'DirectionalLight')
      result = await this._parseDirectionalLight(node, parentNode);
    else if (node.tagName === 'PointLight')
      result = await this._parsePointLight(node, parentNode);
    else if (node.tagName === 'SpotLight')
      result = await this._parseSpotLight(node, parentNode);
    else if (node.tagName === 'Fog') {
      if (!WbWorld.instance.hasFog)
        result = await this._parseFog(node);
      else
        console.error('This world already has a fog.');
    } else {
      // Either it is a node added after the whole scene, or it is an unknown node
      let id;
      if (typeof parentNode !== 'undefined')
        id = parentNode.id;
      result = await this._parseGeometry(node, id);

      // We are forced to check if the result correspond to the class we expect because of the case of a USE
      if (typeof result !== 'undefined' && result instanceof WbGeometry) {
        if (typeof parentNode !== 'undefined' && parentNode instanceof WbShape) {
          if (typeof parentNode.geometry !== 'undefined')
            parentNode.geometry.delete();
          parentNode.geometry = result;
        }
      } else if (node.tagName === 'PBRAppearance') {
        if (typeof parentNode !== 'undefined' && parentNode instanceof WbShape) {
          if (typeof parentNode.appearance !== 'undefined')
            parentNode.appearance.delete();
          result = await this._parsePBRAppearance(node, id);
          parentNode.appearance = result;
        }
      } else if (node.tagName === 'Appearance') {
        if (typeof parentNode !== 'undefined' && parentNode instanceof WbShape) {
          if (typeof parentNode.appearance !== 'undefined')
            parentNode.appearance.delete();
          result = await this._parseAppearance(node, id);
          parentNode.appearance = result;
        }
      } else if (node.tagName === 'Material') {
        result = await this._parseMaterial(node, id);
        if (typeof result !== 'undefined') {
          if (typeof parentNode !== 'undefined' && parentNode instanceof WbAppearance) {
            if (typeof parentNode.material !== 'undefined')
              parentNode.material.delete();
            parentNode.material = result;
          }
        }
      } else if (node.tagName === 'ImageTexture') {
        result = await this._parseImageTexture(node, id);
        if (typeof result !== 'undefined') {
          if (typeof parentNode !== 'undefined' && parentNode instanceof WbAppearance) {
            if (typeof parentNode.material !== 'undefined')
              parentNode.texture.delete();
            parentNode.texture = result;
          }
        }
      } else if (node.tagName === 'TextureTransform') {
        result = await this._parseTextureTransform(node, id);
        if (typeof result !== 'undefined') {
          if (typeof parentNode !== 'undefined' && parentNode instanceof WbAbstractAppearance) {
            if (typeof parentNode.textureTransform !== 'undefined')
              parentNode.textureTransform.delete();
            parentNode.textureTransform = result;
          }
        }
      } else
        console.error("The parser doesn't support this type of node: " + node.tagName);
    }

    // check if top-level nodes
    if (typeof result !== 'undefined' && typeof parentNode === 'undefined')
      WbWorld.instance.sceneTree.push(result);

    return result;
  }

  async _parseChildren(node, parentNode, isBoundingObject) {
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (typeof child.tagName !== 'undefined')
        await this._parseNode(child, parentNode, isBoundingObject);
    }
    return 1;
  }

  async _parseScene(node) {
    const prefix = DefaultUrl.wrenImagesUrl();
    const smaaAreaTexture = await Parser.loadTextureData(prefix, 'smaa_area_texture.png');
    smaaAreaTexture.isTranslucent = false;
    const smaaSearchTexture = await Parser.loadTextureData(prefix, 'smaa_search_texture.png');
    smaaSearchTexture.isTranslucent = false;
    const gtaoNoiseTexture = await Parser.loadTextureData(prefix, 'gtao_noise_texture.png');
    gtaoNoiseTexture.isTranslucent = true;
    return new WbScene(smaaAreaTexture, smaaSearchTexture, gtaoNoiseTexture);
  }

  _parseWorldInfo(node) {
    WbWorld.instance.coordinateSystem = getNodeAttribute(node, 'coordinateSystem', 'ENU');
    WbWorld.computeUpVector();
  }

  _parseViewpoint(node) {
    const id = getNodeAttribute(node, 'id');
    const fieldOfView = parseFloat(getNodeAttribute(node, 'fieldOfView', M_PI_4));
    const orientation = convertStringToQuaternion(getNodeAttribute(node, 'orientation', '0 1 0 0'));
    const position = convertStringToVec3(getNodeAttribute(node, 'position', '0 0 10'));
    const exposure = parseFloat(getNodeAttribute(node, 'exposure', '1.0'));
    const bloomThreshold = parseFloat(getNodeAttribute(node, 'bloomThreshold', 21));
    const far = parseFloat(getNodeAttribute(node, 'zFar', '2000'));
    const near = parseFloat(getNodeAttribute(node, 'zNear', '0.1'));
    const followSmoothness = parseFloat(getNodeAttribute(node, 'followSmoothness'));
    const followedId = getNodeAttribute(node, 'followedId');
    const ambientOcclusionRadius = parseFloat(getNodeAttribute(node, 'ambientOcclusionRadius', 2));

    return new WbViewpoint(id, fieldOfView, orientation, position, exposure, bloomThreshold, near, far, followSmoothness, followedId, ambientOcclusionRadius);
  }

  async _parseBackground(node) {
    const id = getNodeAttribute(node, 'id');
    const skyColor = convertStringToVec3(getNodeAttribute(node, 'skyColor', '0 0 0'));
    const luminosity = parseFloat(getNodeAttribute(node, 'luminosity', '1'));

    let backUrl = getNodeAttribute(node, 'backUrl');
    let bottomUrl = getNodeAttribute(node, 'bottomUrl');
    let frontUrl = getNodeAttribute(node, 'frontUrl');
    let leftUrl = getNodeAttribute(node, 'leftUrl');
    let rightUrl = getNodeAttribute(node, 'rightUrl');
    let topUrl = getNodeAttribute(node, 'topUrl');

    const cubeImages = [];
    if (typeof backUrl !== 'undefined' && typeof bottomUrl !== 'undefined' && typeof frontUrl !== 'undefined' && typeof leftUrl !== 'undefined' && typeof rightUrl !== 'undefined' && typeof topUrl !== 'undefined') {
      backUrl = backUrl.slice(1, backUrl.length - 1);
      bottomUrl = bottomUrl.slice(1, bottomUrl.length - 1);
      frontUrl = frontUrl.slice(1, frontUrl.length - 1);
      leftUrl = leftUrl.slice(1, leftUrl.length - 1);
      rightUrl = rightUrl.slice(1, rightUrl.length - 1);
      topUrl = topUrl.slice(1, topUrl.length - 1);

      if (WbWorld.instance.coordinateSystem === 'ENU') {
        cubeImages[0] = await Parser.loadTextureData(this._prefix, backUrl, false, 90);
        cubeImages[4] = await Parser.loadTextureData(this._prefix, bottomUrl, false, -90);
        cubeImages[1] = await Parser.loadTextureData(this._prefix, frontUrl, false, -90);
        cubeImages[3] = await Parser.loadTextureData(this._prefix, leftUrl, false, 180);
        cubeImages[2] = await Parser.loadTextureData(this._prefix, rightUrl);
        cubeImages[5] = await Parser.loadTextureData(this._prefix, topUrl, false, -90);
      } else {
        cubeImages[5] = await Parser.loadTextureData(this._prefix, backUrl);
        cubeImages[3] = await Parser.loadTextureData(this._prefix, bottomUrl);
        cubeImages[4] = await Parser.loadTextureData(this._prefix, frontUrl);
        cubeImages[1] = await Parser.loadTextureData(this._prefix, leftUrl);
        cubeImages[0] = await Parser.loadTextureData(this._prefix, rightUrl);
        cubeImages[2] = await Parser.loadTextureData(this._prefix, topUrl);
      }
    }

    let backIrradianceUrl = getNodeAttribute(node, 'backIrradianceUrl');
    let bottomIrradianceUrl = getNodeAttribute(node, 'bottomIrradianceUrl');
    let frontIrradianceUrl = getNodeAttribute(node, 'frontIrradianceUrl');
    let leftIrradianceUrl = getNodeAttribute(node, 'leftIrradianceUrl');
    let rightIrradianceUrl = getNodeAttribute(node, 'rightIrradianceUrl');
    let topIrradianceUrl = getNodeAttribute(node, 'topIrradianceUrl');

    const irradianceCubeURL = [];
    if (typeof backIrradianceUrl !== 'undefined' && typeof bottomIrradianceUrl !== 'undefined' && typeof frontIrradianceUrl !== 'undefined' && typeof leftIrradianceUrl !== 'undefined' && typeof rightIrradianceUrl !== 'undefined' && typeof topIrradianceUrl !== 'undefined') {
      backIrradianceUrl = backIrradianceUrl.slice(1, backIrradianceUrl.length - 1);
      bottomIrradianceUrl = bottomIrradianceUrl.slice(1, bottomIrradianceUrl.length - 1);
      frontIrradianceUrl = frontIrradianceUrl.slice(1, frontIrradianceUrl.length - 1);
      leftIrradianceUrl = leftIrradianceUrl.slice(1, leftIrradianceUrl.length - 1);
      rightIrradianceUrl = rightIrradianceUrl.slice(1, rightIrradianceUrl.length - 1);
      topIrradianceUrl = topIrradianceUrl.slice(1, topIrradianceUrl.length - 1);

      if (WbWorld.instance.coordinateSystem === 'ENU') {
        irradianceCubeURL[0] = await Parser.loadTextureData(this._prefix, backIrradianceUrl, true, 90);
        irradianceCubeURL[4] = await Parser.loadTextureData(this._prefix, bottomIrradianceUrl, true, -90);
        irradianceCubeURL[1] = await Parser.loadTextureData(this._prefix, frontIrradianceUrl, true, -90);
        irradianceCubeURL[3] = await Parser.loadTextureData(this._prefix, leftIrradianceUrl, true, 180);
        irradianceCubeURL[2] = await Parser.loadTextureData(this._prefix, rightIrradianceUrl, true);
        irradianceCubeURL[5] = await Parser.loadTextureData(this._prefix, topIrradianceUrl, true, -90);
      } else {
        irradianceCubeURL[2] = await Parser.loadTextureData(this._prefix, topIrradianceUrl, true);
        irradianceCubeURL[5] = await Parser.loadTextureData(this._prefix, backIrradianceUrl, true);
        irradianceCubeURL[3] = await Parser.loadTextureData(this._prefix, bottomIrradianceUrl, true);
        irradianceCubeURL[4] = await Parser.loadTextureData(this._prefix, frontIrradianceUrl, true);
        irradianceCubeURL[1] = await Parser.loadTextureData(this._prefix, leftIrradianceUrl, true);
        irradianceCubeURL[0] = await Parser.loadTextureData(this._prefix, rightIrradianceUrl, true);
      }
    }

    const background = new WbBackground(id, skyColor, luminosity, cubeImages, irradianceCubeURL);
    WbBackground.instance = background;

    WbWorld.instance.nodes.set(background.id, background);

    return background;
  }

  async _checkUse(node, parentNode) {
    let use = getNodeAttribute(node, 'USE');
    if (typeof use === 'undefined')
      return;

    const id = getNodeAttribute(node, 'id');
    let result = WbWorld.instance.nodes.get(use);

    if (typeof result === 'undefined') {
      use = 'n' + use;
      result = WbWorld.instance.nodes.get(use);
    }

    if (typeof result === 'undefined')
      return;

    const useNode = await result.clone(id);
    if (typeof parentNode !== 'undefined') {
      useNode.parent = parentNode.id;
      if (result instanceof WbShape || result instanceof WbGroup || result instanceof WbLight)
        parentNode.children.push(useNode);
    }

    WbWorld.instance.nodes.set(id, useNode);
    return useNode;
  }

  async _parseTransform(node, parentNode, isBoundingObject) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();
    const isSolid = getNodeAttribute(node, 'solid', 'false').toLowerCase() === 'true';
    const translation = convertStringToVec3(getNodeAttribute(node, 'translation', '0 0 0'));
    const scale = convertStringToVec3(getNodeAttribute(node, 'scale', '1 1 1'));
    const rotation = convertStringToQuaternion(getNodeAttribute(node, 'rotation', '0 1 0 0'));

    const transform = new WbTransform(id, isSolid, translation, scale, rotation);

    WbWorld.instance.nodes.set(transform.id, transform);

    await this._parseChildren(node, transform, isBoundingObject);

    if (typeof parentNode !== 'undefined') {
      transform.parent = parentNode.id;
      parentNode.children.push(transform);
    }

    return transform;
  }

  async _parseGroup(node, parentNode, isBoundingObject) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    const isPropeller = getNodeAttribute(node, 'isPropeller', 'false').toLowerCase() === 'true';

    const group = new WbGroup(id, isPropeller);

    WbWorld.instance.nodes.set(group.id, group);
    await this._parseChildren(node, group, isBoundingObject);

    if (typeof parentNode !== 'undefined') {
      group.parent = parentNode.id;
      parentNode.children.push(group);
    }

    return group;
  }

  async _parseShape(node, parentNode, isBoundingObject) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    const castShadows = getNodeAttribute(node, 'castShadows', 'false').toLowerCase() === 'true';
    const isPickable = getNodeAttribute(node, 'isPickable', 'true').toLowerCase() === 'true';
    let geometry;
    let appearance;

    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (typeof child.tagName === 'undefined')
        continue;

      if (typeof appearance === 'undefined') {
        if (child.tagName === 'Appearance') {
          if (isBoundingObject)
            continue;
          // If a sibling PBRAppearance is detected, prefer it.
          let pbrAppearanceChild = false;
          for (let j = 0; j < node.childNodes.length; j++) {
            const child0 = node.childNodes[j];
            if (child0.tagName === 'PBRAppearance') {
              pbrAppearanceChild = true;
              break;
            }
          }
          if (pbrAppearanceChild)
            continue;
          appearance = await this._parseAppearance(child);
        } else if (child.tagName === 'PBRAppearance')
          appearance = await this._parsePBRAppearance(child);
        if (typeof appearance !== 'undefined')
          continue;
      }

      if (typeof geometry === 'undefined') {
        geometry = await this._parseGeometry(child, id);
        if (typeof geometry !== 'undefined')
          continue;
      }

      console.log('X3dLoader: Unknown node: ' + child.tagName);
    }

    if (isBoundingObject)
      appearance = undefined;

    const shape = new WbShape(id, castShadows, isPickable, geometry, appearance);

    if (typeof parentNode !== 'undefined') {
      parentNode.children.push(shape);
      shape.parent = parentNode.id;
    }

    if (typeof appearance !== 'undefined')
      appearance.parent = shape.id;

    WbWorld.instance.nodes.set(shape.id, shape);

    return shape;
  }

  async _parseBillboard(node, parentNode) {
    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    const billboard = new WbBillboard(id);

    WbWorld.instance.nodes.set(billboard.id, billboard);
    await this._parseChildren(node, billboard);

    return billboard;
  }

  async _parseDirectionalLight(node, parentNode) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');
    const on = getNodeAttribute(node, 'on', 'true').toLowerCase() === 'true';
    const color = convertStringToVec3(getNodeAttribute(node, 'color', '1 1 1'));
    const direction = convertStringToVec3(getNodeAttribute(node, 'direction', '0 0 -1'));
    const intensity = parseFloat(getNodeAttribute(node, 'intensity', '1'));
    const ambientIntensity = parseFloat(getNodeAttribute(node, 'ambientIntensity', '0'));
    const castShadows = getNodeAttribute(node, 'castShadows', 'false').toLowerCase() === 'true';

    const dirLight = new WbDirectionalLight(id, on, color, direction, intensity, castShadows, ambientIntensity);

    if (typeof parentNode !== 'undefined' && typeof dirLight !== 'undefined') {
      parentNode.children.push(dirLight);
      dirLight.parent = parentNode.id;
    }

    WbWorld.instance.nodes.set(dirLight.id, dirLight);

    return dirLight;
  }

  async _parsePointLight(node, parentNode) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');
    const on = getNodeAttribute(node, 'on', 'true').toLowerCase() === 'true';
    const attenuation = convertStringToVec3(getNodeAttribute(node, 'attenuation', '1 0 0'));
    const color = convertStringToVec3(getNodeAttribute(node, 'color', '1 1 1'));
    const intensity = parseFloat(getNodeAttribute(node, 'intensity', '1'));
    const location = convertStringToVec3(getNodeAttribute(node, 'location', '0 0 0'));
    const radius = parseFloat(getNodeAttribute(node, 'radius', '100'));
    const ambientIntensity = parseFloat(getNodeAttribute(node, 'ambientIntensity', '0'));
    const castShadows = getNodeAttribute(node, 'castShadows', 'false').toLowerCase() === 'true';

    const pointLight = new WbPointLight(id, on, attenuation, color, intensity, location, radius, ambientIntensity, castShadows, parentNode);

    if (typeof parentNode !== 'undefined' && typeof pointLight !== 'undefined')
      parentNode.children.push(pointLight);

    WbWorld.instance.nodes.set(pointLight.id, pointLight);

    return pointLight;
  }

  async _parseSpotLight(node, parentNode) {
    const use = await this._checkUse(node, parentNode);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');
    const on = getNodeAttribute(node, 'on', 'true').toLowerCase() === 'true';
    const attenuation = convertStringToVec3(getNodeAttribute(node, 'attenuation', '1 0 0'));
    const beamWidth = parseFloat(getNodeAttribute(node, 'beamWidth', '0.785'));
    const color = convertStringToVec3(getNodeAttribute(node, 'color', '1 1 1'));
    const cutOffAngle = parseFloat(getNodeAttribute(node, 'cutOffAngle', '0.785'));
    const direction = convertStringToVec3(getNodeAttribute(node, 'direction', '0 0 -1'));
    const intensity = parseFloat(getNodeAttribute(node, 'intensity', '1'));
    const location = convertStringToVec3(getNodeAttribute(node, 'location', '0 0 0'));
    const radius = parseFloat(getNodeAttribute(node, 'radius', '100'));
    const ambientIntensity = parseFloat(getNodeAttribute(node, 'ambientIntensity', '0'));
    const castShadows = getNodeAttribute(node, 'castShadows', 'false').toLowerCase() === 'true';

    const spotLight = new WbSpotLight(id, on, attenuation, beamWidth, color, cutOffAngle, direction, intensity, location, radius, ambientIntensity, castShadows, parentNode);

    if (typeof parentNode !== 'undefined' && typeof spotLight !== 'undefined')
      parentNode.children.push(spotLight);

    WbWorld.instance.nodes.set(spotLight.id, spotLight);

    return spotLight;
  }

  async _parseFog(node) {
    const id = getNodeAttribute(node, 'id');
    const color = convertStringToVec3(getNodeAttribute(node, 'color', '1 1 1'));
    const visibilityRange = parseFloat(getNodeAttribute(node, 'visibilityRange', '0'));
    const fogType = getNodeAttribute(node, 'fogType', 'LINEAR');

    const fog = new WbFog(id, color, visibilityRange, fogType);

    WbWorld.instance.nodes.set(fog.id, fog);

    if (typeof fog !== 'undefined')
      WbWorld.instance.hasFog = true;

    return fog;
  }

  async _parseGeometry(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined') {
      use.parent = parentId;
      return use;
    }

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    let geometry;
    if (node.tagName === 'Box')
      geometry = this._parseBox(node, id);
    else if (node.tagName === 'Sphere')
      geometry = this._parseSphere(node, id);
    else if (node.tagName === 'Cone')
      geometry = this._parseCone(node, id);
    else if (node.tagName === 'Plane')
      geometry = this._parsePlane(node, id);
    else if (node.tagName === 'Cylinder')
      geometry = this._parseCylinder(node, id);
    else if (node.tagName === 'Capsule')
      geometry = this._parseCapsule(node, id);
    else if (node.tagName === 'IndexedFaceSet')
      geometry = this._parseIndexedFaceSet(node, id);
    else if (node.tagName === 'IndexedLineSet')
      geometry = this._parseIndexedLineSet(node, id);
    else if (node.tagName === 'ElevationGrid')
      geometry = this._parseElevationGrid(node, id);
    else if (node.tagName === 'PointSet')
      geometry = this._parsePointSet(node, id);
    else
      console.log('Not a recognized geometry: ' + node.tagName);

    if (typeof parentId !== 'undefined' && typeof geometry !== 'undefined')
      geometry.parent = parentId;

    return geometry;
  }

  _parseBox(node, id) {
    const size = convertStringToVec3(getNodeAttribute(node, 'size', '2 2 2'));

    const box = new WbBox(id, size);
    WbWorld.instance.nodes.set(box.id, box);
    return box;
  }

  _parseSphere(node, id) {
    const radius = parseFloat(getNodeAttribute(node, 'radius', '1'));
    const ico = getNodeAttribute(node, 'ico', 'false').toLowerCase() === 'true';
    const subdivision = parseInt(getNodeAttribute(node, 'subdivision', '1,1'));

    const sphere = new WbSphere(id, radius, ico, subdivision);

    WbWorld.instance.nodes.set(sphere.id, sphere);

    return sphere;
  }

  _parseCone(node, id) {
    const bottomRadius = getNodeAttribute(node, 'bottomRadius', '1');
    const height = getNodeAttribute(node, 'height', '2');
    const subdivision = getNodeAttribute(node, 'subdivision', '32');
    const side = getNodeAttribute(node, 'side', 'true').toLowerCase() === 'true';
    const bottom = getNodeAttribute(node, 'bottom', 'true').toLowerCase() === 'true';

    const cone = new WbCone(id, bottomRadius, height, subdivision, side, bottom);

    WbWorld.instance.nodes.set(cone.id, cone);

    return cone;
  }

  _parseCylinder(node, id) {
    const radius = getNodeAttribute(node, 'radius', '1');
    const height = getNodeAttribute(node, 'height', '2');
    const subdivision = getNodeAttribute(node, 'subdivision', '32');
    const bottom = getNodeAttribute(node, 'bottom', 'true').toLowerCase() === 'true';
    const side = getNodeAttribute(node, 'side', 'true').toLowerCase() === 'true';
    const top = getNodeAttribute(node, 'top', 'true').toLowerCase() === 'true';

    const cylinder = new WbCylinder(id, radius, height, subdivision, bottom, side, top);

    WbWorld.instance.nodes.set(cylinder.id, cylinder);

    return cylinder;
  }

  _parsePlane(node, id) {
    const size = convertStringToVec2(getNodeAttribute(node, 'size', '1,1'));

    const plane = new WbPlane(id, size);

    WbWorld.instance.nodes.set(plane.id, plane);

    return plane;
  }

  _parseCapsule(node, id) {
    const radius = getNodeAttribute(node, 'radius', '1');
    const height = getNodeAttribute(node, 'height', '2');
    const subdivision = getNodeAttribute(node, 'subdivision', '32');
    const bottom = getNodeAttribute(node, 'bottom', 'true').toLowerCase() === 'true';
    const side = getNodeAttribute(node, 'side', 'true').toLowerCase() === 'true';
    const top = getNodeAttribute(node, 'top', 'true').toLowerCase() === 'true';

    const capsule = new WbCapsule(id, radius, height, subdivision, bottom, side, top);

    WbWorld.instance.nodes.set(capsule.id, capsule);

    return capsule;
  }

  _parseIndexedFaceSet(node, id) {
    const coordIndexStr = getNodeAttribute(node, 'coordIndex', '').trim().split(/\s/);    const coordIndex = coordIndexStr.map(Number).filter(el => { return el !== -1; });

    const normalIndexStr = getNodeAttribute(node, 'normalIndex', '').trim().split(/\s/);
    const normalIndex = normalIndexStr.map(Number).filter(el => { return el !== -1; });

    const texCoordIndexStr = getNodeAttribute(node, 'texCoordIndex', '').trim().split(/\s/);    const texCoordIndex = texCoordIndexStr.map(Number).filter(el => { return el !== -1; });

    const coordArray = [];
    const coordinate = node.getElementsByTagName('Coordinate')[0];
    if (typeof coordinate !== 'undefined') {
      const coordStr = getNodeAttribute(coordinate, 'point', '').split(/\s/);
      const coord = coordStr.map(el => parseFloat(el));
      for (let i = 0; i < coord.length; i = i + 3)
        coordArray.push(new WbVector3(coord[i], coord[i + 1], coord[i + 2]));
    }

    const texCoordArray = [];
    const textureCoordinate = node.getElementsByTagName('TextureCoordinate')[0];
    if (typeof textureCoordinate !== 'undefined') {
      const texcoordsStr = getNodeAttribute(textureCoordinate, 'point', '').split(/\s/);
      const texCoord = texcoordsStr.map(el => parseFloat(el));
      for (let i = 0; i < texCoord.length; i = i + 2)
        texCoordArray.push(new WbVector2(texCoord[i], texCoord[i + 1]));
    }

    const normalArray = [];
    const normalNode = node.getElementsByTagName('Normal')[0];
    if (typeof normalNode !== 'undefined') {
      const normalStr = getNodeAttribute(normalNode, 'vector', '').split(/[\s,]+/);
      const normal = normalStr.map(el => parseFloat(el));
      for (let i = 0; i < normal.length; i = i + 3)
        normalArray.push(new WbVector3(normal[i], normal[i + 1], normal[i + 2]));
    }

    const ccw = parseFloat(getNodeAttribute(node, 'ccw', '1'));

    const ifs = new WbIndexedFaceSet(id, coordIndex, normalIndex, texCoordIndex, coordArray, texCoordArray, normalArray, ccw);
    WbWorld.instance.nodes.set(ifs.id, ifs);

    return ifs;
  }

  _parseIndexedLineSet(node, id) {
    const coordinate = node.getElementsByTagName('Coordinate')[0];

    if (typeof coordinate === 'undefined')
      return undefined;

    const indicesStr = getNodeAttribute(node, 'coordIndex', '').trim().split(/\s/);

    const verticesStr = getNodeAttribute(coordinate, 'point', '').trim().split(/\s/);

    const coord = [];
    for (let i = 0; i < verticesStr.length; i += 3)
      coord.push(new WbVector3(parseFloat(verticesStr[i]), parseFloat(verticesStr[i + 1]), parseFloat(verticesStr[i + 2])));

    const coordIndex = indicesStr.map(Number);

    const ils = new WbIndexedLineSet(id, coord, coordIndex);
    WbWorld.instance.nodes.set(ils.id, ils);

    return ils;
  }

  _parseElevationGrid(node, id) {
    const heightStr = getNodeAttribute(node, 'height');
    if (typeof heightStr === 'undefined')
      return;

    const xDimension = parseInt(getNodeAttribute(node, 'xDimension', '0'));
    const xSpacing = parseFloat(getNodeAttribute(node, 'xSpacing', '1'));
    const zDimension = parseInt(getNodeAttribute(node, 'zDimension', '0'));
    const zSpacing = parseFloat(getNodeAttribute(node, 'zSpacing', '1'));
    const thickness = parseFloat(getNodeAttribute(node, 'thickness', '1'));

    const height = heightStr.split(' ').map(Number);

    const eg = new WbElevationGrid(id, height, xDimension, xSpacing, zDimension, zSpacing, thickness);
    WbWorld.instance.nodes.set(eg.id, eg);

    return eg;
  }

  _parsePointSet(node, id) {
    const coordinate = node.getElementsByTagName('Coordinate')[0];

    if (typeof coordinate === 'undefined')
      return;

    const coordStrArray = getNodeAttribute(coordinate, 'point', '').trim().split(/\s/);

    if (typeof coordStrArray === 'undefined')
      return;

    const coordArray = coordStrArray.map(Number);
    const coord = [];
    for (let i = 0; i < coordArray.length; i += 3)
      coord.push(new WbVector3(coordArray[i], coordArray[i + 1], coordArray[i + 2]));

    const colorNode = node.getElementsByTagName('Color')[0];
    let color;
    if (typeof colorNode !== 'undefined') {
      const colorStrArray = getNodeAttribute(colorNode, 'color', '').trim().split(/\s/);
      if (typeof colorStrArray !== 'undefined') {
        const colorArray = colorStrArray.map(Number);
        color = [];
        for (let i = 0; i < colorArray.length; i += 3)
          color.push(new WbVector3(colorArray[i], colorArray[i + 1], colorArray[i + 2]));
      }
    }

    const ps = new WbPointSet(id, coord, color);
    WbWorld.instance.nodes.set(ps.id, ps);

    return ps;
  }

  async _parseSwitch(node, parent) {
    if (typeof parent === 'undefined')
      return;

    const child = node.childNodes[0];

    let boundingObject;
    if (child.tagName === 'Shape')
      boundingObject = await this._parseShape(child, undefined, true);
    else if (child.tagName === 'Transform')
      boundingObject = await this._parseTransform(child, undefined, true);
    else if (child.tagName === 'Group')
      boundingObject = await this._parseGroup(child, undefined, true);
    else
      console.error('Unknown boundingObject: ' + child.tagName);

    if (typeof boundingObject === 'undefined')
      return;

    boundingObject.parent = parent.id;
    parent.boundingObject = boundingObject;

    return boundingObject;
  }

  async _parseAppearance(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined')
      return use;

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    // Get the Material tag.
    const materialNode = node.getElementsByTagName('Material')[0];
    let material;
    if (typeof materialNode !== 'undefined')
      material = await this._parseMaterial(materialNode);

    // Check to see if there is a texture.
    const imageTexture = node.getElementsByTagName('ImageTexture')[0];
    let texture;
    if (typeof imageTexture !== 'undefined')
      texture = await this._parseImageTexture(imageTexture);

    // Check to see if there is a textureTransform.
    const textureTransform = node.getElementsByTagName('TextureTransform')[0];
    let transform;
    if (typeof textureTransform !== 'undefined')
      transform = await this._parseTextureTransform(textureTransform);

    const appearance = new WbAppearance(id, material, texture, transform);
    if (typeof appearance !== 'undefined') {
      if (typeof material !== 'undefined')
        material.parent = appearance.id;

      if (typeof texture !== 'undefined')
        texture.parent = appearance.id;

      if (typeof transform !== 'undefined')
        transform.parent = appearance.id;

      if (typeof parentId !== 'undefined')
        appearance.parent = parentId;

      WbWorld.instance.nodes.set(appearance.id, appearance);
    }

    return appearance;
  }

  async _parseMaterial(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined')
      return use;

    let id = getNodeAttribute(node, 'id');
    if (typeof id === 'undefined')
      id = getAnId();

    const ambientIntensity = parseFloat(getNodeAttribute(node, 'ambientIntensity', '0.2'));
    const diffuseColor = convertStringToVec3(getNodeAttribute(node, 'diffuseColor', '0.8 0.8 0.8'));
    const specularColor = convertStringToVec3(getNodeAttribute(node, 'specularColor', '0 0 0'));
    const emissiveColor = convertStringToVec3(getNodeAttribute(node, 'emissiveColor', '0 0 0'));
    const shininess = parseFloat(getNodeAttribute(node, 'shininess', '0.2'));
    const transparency = parseFloat(getNodeAttribute(node, 'transparency', '0'));

    const material = new WbMaterial(id, ambientIntensity, diffuseColor, specularColor, emissiveColor, shininess, transparency);

    if (typeof parentId !== 'undefined')
      material.parent = parentId;

    WbWorld.instance.nodes.set(material.id, material);

    return material;
  }

  async _parseImageTexture(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');
    let url = getNodeAttribute(node, 'url', '');
    url = url.slice(1, url.length - 1);
    const isTransparent = getNodeAttribute(node, 'isTransparent', 'false').toLowerCase() === 'true';
    const s = getNodeAttribute(node, 'repeatS', 'true').toLowerCase() === 'true';
    const t = getNodeAttribute(node, 'repeatT', 'true').toLowerCase() === 'true';
    const filtering = parseFloat(getNodeAttribute(node, 'filtering', '4'));

    let imageTexture;
    if (typeof url !== 'undefined' && url !== '') {
      imageTexture = new WbImageTexture(id, this._prefix, url, isTransparent, s, t, filtering);
      await imageTexture.updateUrl();
    }

    if (typeof imageTexture !== 'undefined') {
      if (typeof parentId !== 'undefined')
        imageTexture.parent = parentId;

      WbWorld.instance.nodes.set(imageTexture.id, imageTexture);
    }

    return imageTexture;
  }

  async _parsePBRAppearance(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');

    const baseColor = convertStringToVec3(getNodeAttribute(node, 'baseColor', '1 1 1'));
    const transparency = parseFloat(getNodeAttribute(node, 'transparency', '0'));
    const roughness = parseFloat(getNodeAttribute(node, 'roughness', '0'));
    const metalness = parseFloat(getNodeAttribute(node, 'metalness', '1'));
    const IBLStrength = parseFloat(getNodeAttribute(node, 'IBLStrength', '1'));
    const normalMapFactor = parseFloat(getNodeAttribute(node, 'normalMapFactor', '1'));
    const occlusionMapStrength = parseFloat(getNodeAttribute(node, 'occlusionMapStrength', '1'));
    const emissiveColor = convertStringToVec3(getNodeAttribute(node, 'emissiveColor', '0 0 0'));
    const emissiveIntensity = parseFloat(getNodeAttribute(node, 'emissiveIntensity', '1'));

    // Check to see if there is a textureTransform.
    const textureTransform = node.getElementsByTagName('TextureTransform')[0];
    let transform;
    if (typeof textureTransform !== 'undefined')
      transform = await this._parseTextureTransform(textureTransform);

    const imageTextures = node.getElementsByTagName('ImageTexture');
    let baseColorMap, roughnessMap, metalnessMap, normalMap, occlusionMap, emissiveColorMap;
    for (let i = 0; i < imageTextures.length; i++) {
      const imageTexture = imageTextures[i];
      const type = getNodeAttribute(imageTexture, 'type', undefined);
      if (type === 'baseColor') {
        baseColorMap = await this._parseImageTexture(imageTexture);
        if (typeof baseColorMap !== 'undefined')
          baseColorMap.type = 'baseColorMap';
      } else if (type === 'roughness') {
        roughnessMap = await this._parseImageTexture(imageTexture);
        if (typeof roughnessMap !== 'undefined')
          roughnessMap.type = 'roughnessMap';
      } else if (type === 'metalness') {
        metalnessMap = await this._parseImageTexture(imageTexture);
        if (typeof metalnessMap !== 'undefined')
          metalnessMap.type = 'metalnessMap';
      } else if (type === 'normal') {
        normalMap = await this._parseImageTexture(imageTexture);
        if (typeof normalMap !== 'undefined')
          normalMap.type = 'normalMap';
      } else if (type === 'occlusion') {
        occlusionMap = await this._parseImageTexture(imageTexture);
        if (typeof occlusionMap !== 'undefined')
          occlusionMap.type = 'occlusionMap';
      } else if (type === 'emissiveColor') {
        emissiveColorMap = await this._parseImageTexture(imageTexture);
        if (typeof emissiveColorMap !== 'undefined')
          emissiveColorMap.type = 'emissiveColorMap';
      }
    }

    const pbrAppearance = new WbPBRAppearance(id, baseColor, baseColorMap, transparency, roughness, roughnessMap, metalness, metalnessMap, IBLStrength,
      normalMap, normalMapFactor, occlusionMap, occlusionMapStrength, emissiveColor, emissiveColorMap, emissiveIntensity, transform);

    if (typeof pbrAppearance !== 'undefined') {
      if (typeof transform !== 'undefined')
        transform.parent = pbrAppearance.id;

      if (typeof baseColorMap !== 'undefined')
        baseColorMap.parent = pbrAppearance.id;

      if (typeof roughnessMap !== 'undefined')
        roughnessMap.parent = pbrAppearance.id;

      if (typeof metalnessMap !== 'undefined')
        metalnessMap.parent = pbrAppearance.id;

      if (typeof normalMap !== 'undefined')
        normalMap.parent = pbrAppearance.id;

      if (typeof occlusionMap !== 'undefined')
        occlusionMap.parent = pbrAppearance.id;

      if (typeof emissiveColorMap !== 'undefined')
        emissiveColorMap.parent = pbrAppearance.id;

      if (typeof parentId !== 'undefined')
        pbrAppearance.parent = parentId;

      WbWorld.instance.nodes.set(pbrAppearance.id, pbrAppearance);
    }

    return pbrAppearance;
  }

  async _parseTextureTransform(node, parentId) {
    const use = await this._checkUse(node);
    if (typeof use !== 'undefined')
      return use;

    const id = getNodeAttribute(node, 'id');
    const center = convertStringToVec2(getNodeAttribute(node, 'center', '0 0'));
    const rotation = parseFloat(getNodeAttribute(node, 'rotation', '0'));
    const scale = convertStringToVec2(getNodeAttribute(node, 'scale', '1 1'));
    const translation = convertStringToVec2(getNodeAttribute(node, 'translation', '0 0'));

    const textureTransform = new WbTextureTransform(id, center, rotation, scale, translation);

    if (typeof parentId !== 'undefined')
      textureTransform.parent = parentId;

    WbWorld.instance.nodes.set(textureTransform.id, textureTransform);

    return textureTransform;
  }

  static async loadTextureData(prefix, url, isHdr, rotation) {
    const canvas2 = document.createElement('canvas');
    const context = canvas2.getContext('2d');

    const image = new WbImage();
    if (url.startsWith('webots://')) {
      if (typeof webots.currentView.repository === 'undefined')
        webots.currentView.repository = 'cyberbotics';
      if (typeof webots.currentView.branch === 'undefined' || webots.currentView.branch === '')
        webots.currentView.branch = 'released';
      url = url.replace('webots://', 'https://raw.githubusercontent.com/' + webots.currentView.repository + '/webots/' + webots.currentView.branch + '/');
    }
    if (typeof prefix !== 'undefined' && !url.startsWith('http'))
      url = prefix + url;
    if (isHdr) {
      const img = await Parser.loadHDRImage(url);
      image.bits = img.data;
      image.width = img.width;
      image.height = img.height;
      image.url = url;
      if (typeof rotation !== 'undefined')
        image.bits = rotateHDR(image, rotation);
    } else {
      const img = await Parser.loadImage(url);
      canvas2.width = img.width;
      canvas2.height = img.height;
      if (typeof rotation !== 'undefined') {
        context.save();
        context.translate(canvas2.width / 2, canvas2.height / 2);
        context.rotate(rotation * Math.PI / 180);
        context.drawImage(img, -canvas2.width / 2, -canvas2.height / 2);
        context.restore();
      } else
        context.drawImage(img, 0, 0);

      const dataBGRA = context.getImageData(0, 0, img.width, img.height).data;
      let data = new Uint8ClampedArray(dataBGRA.length);
      data = dataBGRA;

      image.bits = data;
      image.width = img.width;
      image.height = img.height;
      image.url = url;
    }
    return image;
  }

  static loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        resolve(img);
      };
      img.onerror = () => console.log('Error in loading: ' + src);
      img.setAttribute('crossOrigin', '');
      img.src = src;
    });
  }

  static loadHDRImage(src) {
    return new Promise((resolve, reject) => {
      loadHdr(src, function(img) { resolve(img); });
    });
  }
}

function getNodeAttribute(node, attributeName, defaultValue) {
  console.assert(node && node.attributes);
  if (attributeName in node.attributes)
    return node.attributes.getNamedItem(attributeName).value;
  return defaultValue;
}

function convertStringToVec2(s) {
  s = s.split(/\s/);
  return new WbVector2(parseFloat(s[0]), parseFloat(s[1]));
}

function convertStringToVec3(s) {
  s = s.split(/\s/);
  return new WbVector3(parseFloat(s[0]), parseFloat(s[1]), parseFloat(s[2]));
}

function convertStringToQuaternion(s) {
  const pos = s.split(/\s/);
  return new WbVector4(parseFloat(pos[0]), parseFloat(pos[1]), parseFloat(pos[2]), parseFloat(pos[3]));
}

function rotateHDR(image, rotate) {
  let rotatedbits = [];
  if (rotate === 90) {
    for (let x = 0; x < image.width; x++) {
      for (let y = 0; y < image.height; y++) {
        const u = y * image.width * 3 + x * 3;
        const v = (image.width - 1 - x) * image.height * 3 + y * 3;
        for (let c = 0; c < 3; c++)
          rotatedbits[u + c] = image.bits[v + c];
      }
    }
    const swap = image.width;
    image.width = image.height;
    image.height = swap;
  } else if (rotate === -90) {
    for (let x = 0; x < image.width; x++) {
      for (let y = 0; y < image.height; y++) {
        const u = y * image.width * 3 + x * 3;
        const v = x * image.width * 3 + (image.height - 1 - y) * 3;
        for (let c = 0; c < 3; c++)
          rotatedbits[u + c] = image.bits[v + c];
      }
    }
    const swap = image.width;
    image.width = image.height;
    image.height = swap;
  } else if (rotate === 180) {
    for (let x = 0; x < image.width; x++) {
      for (let y = 0; y < image.height; y++) {
        const u = y * image.width * 3 + x * 3;
        const v = (image.height - 1 - y) * image.width * 3 + (image.width - 1 - x) * 3;
        for (let c = 0; c < 3; c++)
          rotatedbits[u + c] = image.bits[v + c];
      }
    }
  }
  return rotatedbits;
}class WrenRenderer {
  constructor() {
    this._canvas = document.createElement('canvas');
    this._canvas.id = 'canvas';
    let div = document.getElementById('view3d');

    if (typeof div === 'undefined' || div === null)
      div = document.getElementsByTagName('webots-streaming');
    div.insertBefore(this._canvas, div.firstChild);

    _wr_config_enable_shadows(!disableShadows);

    // glGetError causes freeze with Firefox on Windows 10
    _wr_gl_state_disable_check_error();
  }

  setSize(width, height) {
    this._canvas.width = width;
    this._canvas.height = height;
  }

  render() {
    if (!_wr_gl_state_is_initialized())
      return;

    try {
      WbWorld.instance.viewpoint.updatePostProcessingParameters();

      _wr_scene_render(_wr_scene_get_instance(), null, true);
    } catch (error) {
      console.log('No Context');
    }
  }

  renderMinimal() {
    if (!_wr_gl_state_is_initialized())
      return;

    try {
      _wr_scene_render(_wr_scene_get_instance(), null, true);
    } catch (error) {
      console.log('No Context');
    }
  }
}class X3dScene {
  constructor(domElement) {
    this.domElement = domElement;
    this._loader = new Parser(this.prefix);
  }

  init(texturePathPrefix = '') {
    this.prefix = texturePathPrefix;
    this.renderer = new WrenRenderer();

    this.resize();

    this.destroyWorld();
  }

  render() {
    // Set maximum rendering frequency.
    // To avoid slowing down the simulation rendering the scene too often, the last rendering time is checked
    // and the rendering is performed only at a given maximum frequency.
    // To be sure that no rendering request is lost, a timeout is set.
    const renderingMinTimeStep = 40; // Rendering maximum frequency: every 40 ms.
    const currentTime = (new Date()).getTime();
    if (this._nextRenderingTime && this._nextRenderingTime > currentTime) {
      if (!this._renderingTimeout)
        this._renderingTimeout = setTimeout(() => this.render(), this._nextRenderingTime - currentTime);
      return;
    }

    this.renderer.render();

    this._nextRenderingTime = (new Date()).getTime() + renderingMinTimeStep;
    clearTimeout(this._renderingTimeout);
    this._renderingTimeout = null;
  }

  renderMinimal() {
    this.renderer.renderMinimal();
  }

  resize() {
    const width = this.domElement.clientWidth;
    const height = this.domElement.clientHeight;

    this.renderer.setSize(width, height);

    if (typeof WbWorld.instance === 'undefined')
      return;

    if (typeof WbWorld.instance.scene !== 'undefined')
      WbWorld.instance.scene.updateFrameBuffer();

    if (typeof WbWorld.instance.viewpoint !== 'undefined')
      WbWorld.instance.viewpoint.updatePostProcessingEffects();

    this.render();
  }

  destroyWorld() {
    if (typeof WbWorld.instance !== 'undefined') {
      let index = WbWorld.instance.sceneTree.length - 1;
      while (index >= 0) {
        WbWorld.instance.sceneTree[index].delete();
        --index;
      }

      if (typeof WbWorld.instance.viewpoint !== 'undefined')
        WbWorld.instance.viewpoint.delete();

      if (typeof WbWorld.instance.scene !== 'undefined')
        WbWorld.instance.scene.destroy();

      WbWorld.instance = undefined;
    }

    this.renderMinimal();
    this._loader = undefined;
    webots.currentView.runOnLoad = false;
  }

  _deleteObject(id) {
    const object = WbWorld.instance.nodes.get('n' + id);
    if (typeof object === 'undefined')
      return;

    object.delete();

    this.render();
  }

  loadWorldFile(url, onLoad) {
    const prefix = this.prefix;
    const renderer = this.renderer;
    const xmlhttp = new XMLHttpRequest();
    xmlhttp.open('GET', url, true);
    xmlhttp.overrideMimeType('plain/text');
    xmlhttp.onreadystatechange = async function() {
      if (xmlhttp.readyState === 4 && (xmlhttp.status === 200 || xmlhttp.status === 0)) { // Some browsers return HTTP Status 0 when using non-http protocol (for file://)
        const loader = new Parser(prefix);
        await loader.parse(xmlhttp.responseText, renderer);
        onLoad();
      }
    };
    xmlhttp.send();
  }

  _loadObject(x3dObject, parentId, callback) {
    let parentNode;
    if (typeof parentId !== 'undefined' && parentId > 0) {
      parentNode = WbWorld.instance.nodes.get('n' + parentId);
      const ancestor = getAncestor(parentNode);
      ancestor.isPreFinalizeCalled = false;
      ancestor.wrenObjectsCreatedCalled = false;
      ancestor.isPostFinalizeCalled = false;
    }

    if (typeof this._loader === 'undefined')
      this._loader = new Parser(this.prefix);

    this._loader.parse(x3dObject, this.renderer, parentNode, callback);

    this.render();
  }

  applyPose(pose, appliedFields = [], automaticMove) {
    const id = pose.id;
    if (typeof WbWorld.instance === 'undefined')
      return appliedFields;

    const object = WbWorld.instance.nodes.get('n' + id);
    if (typeof object === 'undefined')
      return;

    let fields = [...appliedFields];

    fields = this._applyPoseToObject(pose, object, fields);

    // Update the related USE nodes
    let length = object.useList.length - 1;
    while (length >= 0) {
      const use = WbWorld.instance.nodes.get(object.useList[length]);
      if (typeof use === 'undefined') {
        // remove a USE node from the list if it has been deleted
        const index = object.useList.indexOf(length);
        this.useList.splice(index, 1);
      } else {
        fields = [...appliedFields];
        fields = this._applyPoseToObject(pose, use, fields);
      }

      --length;
    }

    return fields;
  }

  _applyPoseToObject(pose, object, fields, automaticMove) {
    for (let key in pose) {
      if (key === 'id')
        continue;

      if (fields.indexOf(key) !== -1)
        continue;

      let valid = true;
      if (key === 'translation') {
        const translation = convertStringToVec3(pose[key]);

        if (object instanceof WbTransform) {
          if (typeof WbWorld.instance.viewpoint.followedId !== 'undefined' && WbWorld.instance.viewpoint.followedId === object.id)
            WbWorld.instance.viewpoint.setFollowedObjectDeltaPosition(translation, object.translation);

          object.translation = translation;
          if (WbWorld.instance.readyForUpdates)
            object.applyTranslationToWren();
        } else if (object instanceof WbTextureTransform) {
          object.translation = translation;
          if (WbWorld.instance.readyForUpdates) {
            let appearance = WbWorld.instance.nodes.get(object.parent);
            if (typeof appearance !== 'undefined') {
              let shape = WbWorld.instance.nodes.get(appearance.parent);
              if (typeof shape !== 'undefined')
                shape.updateAppearance();
            }
          }
        }
      } else if (key === 'rotation') {
        const quaternion = convertStringToQuaternion(pose[key]);
        object.rotation = quaternion;
        if (WbWorld.instance.readyForUpdates)
          object.applyRotationToWren();
      } else if (object instanceof WbPBRAppearance || object instanceof WbMaterial) {
        if (key === 'baseColor')
          object.baseColor = convertStringToVec3(pose[key]);
        else if (key === 'diffuseColor')
          object.diffuseColor = convertStringToVec3(pose[key]);
        else if (key === 'emissiveColor')
          object.emissiveColor = convertStringToVec3(pose[key]);

        if (object instanceof WbMaterial) {
          if (WbWorld.instance.readyForUpdates) {
            let appearance = WbWorld.instance.nodes.get(object.parent);
            if (typeof appearance !== 'undefined') {
              let shape = WbWorld.instance.nodes.get(appearance.parent);
              if (typeof shape !== 'undefined')
                shape.updateAppearance();
            }
          }
        } else {
          if (WbWorld.instance.readyForUpdates) {
            let shape = WbWorld.instance.nodes.get(object.parent);
            if (typeof shape !== 'undefined')
              shape.updateAppearance();
          }
        }
      } else
        valid = false;

      if (valid)
        fields.push(key);
    }

    if (typeof object.parent !== 'undefined') {
      const parent = WbWorld.instance.nodes.get(object.parent);
      if (typeof parent !== 'undefined' && parent instanceof WbGroup && parent.isPropeller && parent.currentHelix !== object.id && WbWorld.instance.readyForUpdates)
        parent.switchHelix(object.id);
    }

    return fields;
  }

  applyLabel(label, view) {
    view.setLabel({
      id: label.id,
      text: label.text,
      font: label.font,
      color: label.rgba,
      size: label.size,
      x: label.x,
      y: label.y
    });
  }

  processServerMessage(data, view) {
    if (data.startsWith('application/json:')) {
      if (typeof view.time !== 'undefined') { // otherwise ignore late updates until the scene loading is completed
        data = data.substring(data.indexOf(':') + 1);
        const frame = JSON.parse(data);
        view.time = frame.time;
        if (document.getElementById('webotsClock'))
          document.getElementById('webotsClock').innerHTML = webots.parseMillisecondsIntoReadableTime(frame.time);

        if (frame.hasOwnProperty('poses')) {
          for (let i = 0; i < frame.poses.length; i++)
            this.applyPose(frame.poses[i]);
        }

        if (frame.hasOwnProperty('labels')) {
          for (let i = 0; i < frame.labels.length; i++)
            this.applyLabel(frame.labels[i], view);
        }
        if (typeof WbWorld.instance !== 'undefined' && typeof WbWorld.instance.viewpoint !== 'undefined')
          WbWorld.instance.viewpoint.updateFollowUp(view.time);
        this.render();
      } else { // parse the labels even so the scene loading is not completed
        data = data.substring(data.indexOf(':') + 1);
        let frame = JSON.parse(data);
        if (frame.hasOwnProperty('labels')) {
          for (let i = 0; i < frame.labels.length; i++)
            this.applyLabel(frame.labels[i], view);
        }
      }
    } else if (data.startsWith('node:')) {
      data = data.substring(data.indexOf(':') + 1);
      const parentId = data.split(':')[0];
      data = data.substring(data.indexOf(':') + 1);
      this._loadObject(data, parentId);
    } else if (data.startsWith('delete:')) {
      data = data.substring(data.indexOf(':') + 1).trim();
      this._deleteObject(data);
    } else if (data.startsWith('model:')) {
      if (view.toolBar)
        view.toolBar.enableToolBarButtons(false);

      if (document.getElementById('webotsProgressMessage'))
        document.getElementById('webotsProgressMessage').innerHTML = 'Loading 3D scene...';
      if (document.getElementById('webotsProgressPercent'))
        document.getElementById('webotsProgressPercent').innerHTML = '';
      if (document.getElementById('webotsProgress'))
        document.getElementById('webotsProgress').style.display = 'block';
      this.destroyWorld();
      view.removeLabels();
      data = data.substring(data.indexOf(':') + 1).trim();
      if (!data) // received an empty model case: just destroy the view
        return true;
      view.stream.socket.send('pause');
      this._loadObject(data, 0, view.onready);
    } else
      return false;
    return true;
  }

  resetViewpoint() {
    WbWorld.instance.viewpoint.resetViewpoint();
    this.render();
  }
}/*
 * Injects a Webots 3D view inside a HTML tag.
 * @class
 * @classdesc
 *   The Webots view object displays a 3D view on a web page.
 *   This view represents a Webots simulation world that may be
 *   connected to a webots instance running on a remote server.
 * @example
 *   // Example: Initialize from a Webots streaming server
 *   const view = new webots.View(document.getElementById("myDiv"));
 *   view.open("ws://localhost:80/simple/worlds/simple.wbt");
 *   // or view.open("ws://localhost:80");
 *   // or view.open("file.x3d");
 *   view.onready = () => {
 *       // the initialization is done
 *   }
 *   view.onclose = () => {
 *       view = null;
 *   }
 */

/* The following member variables can be set by the application:

webots.showRevert          // defines whether the revert button should be displayed
webots.showQuit            // defines whether the quit button should be displayed
webots.showRun             // defines whether the run button should be displayed
*/
let webots = window.webots || {};

webots.View = class View {
  constructor(view3D, mobile) {
    webots.currentView = this;
    this.onerror = (text) => {
      console.log('%c' + text, 'color:black');
    };
    this.onstdout = (text) => {
      console.log('%c' + text, 'color:blue');
    };
    this.onstderr = (text) => {
      console.log('%c' + text, 'color:red');
    };
    this.onquit = () => { // You can change this behavior by overriding this onquit() method
      window.history.back(); // go back to the previous page in the navigation history
    };
    this.onresize = () => {
      if (typeof this.x3dScene !== 'undefined')
        this.x3dScene.resize();
      else if (typeof this.multimediaClient !== 'undefined')
        this.multimediaClient.requestNewSize();

      const labels = document.getElementsByClassName('webots-label');
      for (let i = labels.length - 1; i >= 0; i--) {
        const element = labels.item(i);
        element.style.fontSize = this._getHeight(this._x3dDiv) * element.size / 2.25 + 'px'; // 2.25 is an empirical value to match with Webots appearance
        element.style.left = this._getWidth(this._x3dDiv) * element.x + 'px';
        element.style.top = this._getHeight(this._x3dDiv) * element.y + 'px';
      }
    };

    window.onresize = this.onresize;

    this.view3D = view3D;
    this.view3D.className = view3D.className + ' webotsView';

    if (typeof mobile === 'undefined')
      this._mobileDevice = SystemInfo.isMobileDevice();
    else
      this._mobileDevice = mobile;

    this.fullscreenEnabled = !SystemInfo.isIOS();
    if (!this.fullscreenEnabled) {
      // Add tag needed to run standalone web page in fullscreen on iOS.
      let meta = document.createElement('meta');
      meta.name = 'apple-mobile-web-app-capable';
      meta.content = 'yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
    }

    this.timeout = 60 * 1000; // default to one minute
    this.deadline = this.timeout;
    this.runOnLoad = false;
    this.quitting = false;
  }

  setTimeout(timeout) { // expressed in seconds
    if (timeout < 0) {
      this.timeout = timeout;
      this.deadline = 0;
      return;
    }

    this.timeout = timeout * 1000; // convert to millisecons
    this.deadline = this.timeout;
    if (typeof this.time !== 'undefined')
      this.deadline += this.time;
  }

  setAnimation(url, gui, loop) {
    if (typeof gui === 'undefined')
      gui = 'play';
    if (typeof loop === 'undefined')
      loop = true;
    this.animation = new Animation(url, this.x3dScene, this, gui, loop);
  }

  open(url, mode, texturePathPrefix = '') {
    const userAgents = navigator.userAgent;
    let chromeAgent = userAgents.indexOf('Chrome') > -1;
    let safariAgent = userAgents.indexOf('Safari') > -1;

    // Verify that chrome userAgent is false because safari userAgent is also included in Chrome browser.
    if (!chromeAgent && safariAgent) {
      alert('Safari does not have the technical capabilities to display a Webots simulation.\n\nPlease use a compatible browser (Chrome, Firefox, Edge, Opera).');
      return;
    }
    this.url = url;
    if (typeof mode === 'undefined')
      mode = 'x3d';
    this.mode = mode;

    const initWorld = () => {
      function findGetParameter(parameterName) {
        let tmp = [];
        let items = window.location.search.substr(1).split('&');
        for (let index = 0; index < items.length; index++) {
          tmp = items[index].split('=');
          if (tmp[0] === parameterName)
            return decodeURIComponent(tmp[1]);
        }
        return undefined;
      }

      if (typeof this.progress === 'undefined') {
        this.progress = document.createElement('div');
        this.progress.id = 'webotsProgress';
        this.progress.innerHTML = "<div><img src='" + DefaultUrl.wwiImagesUrl() + "load_animation.gif'>" +
        "</div><div id='webotsProgressMessage'>Initializing...</div>" +
        "</div><div id='webotsProgressPercent'></div>";
        this.view3D.appendChild(this.progress);
      }

      if (document.getElementById('webotsProgress'))
        document.getElementById('webotsProgress').style.display = 'block';

      if (this._isWebSocketProtocol) {
        if (typeof this.toolBar === 'undefined')
          this.toolBar = new Toolbar(this.view3D, this);
        else if (!document.getElementById('toolBar'))
          this.view3D.appendChild(this.toolBar.domElement);

        const url = findGetParameter('url');
        if (url || this.url.endsWith('.wbt')) { // url expected form: "wss://localhost:1999/simple/worlds/simple.wbt" or
          // "wss://localhost/1999/?url=webots://github.com/cyberbotics/webots/branch/master/projects/languages/python"
          this._server = new Server(this.url, this, finalizeWorld);
          this._server.connect();
        } else { // url expected form: "ws://cyberbotics1.epfl.ch:80"
          const httpServerUrl = 'http' + this.url.slice(2); // replace 'ws'/'wss' with 'http'/'https'
          this.stream = new Stream(this.url, this, finalizeWorld);
          if (typeof this.x3dScene !== 'undefined')
            this.x3dScene.prefix = httpServerUrl + '/';
          this.stream.connect();
        }
      } else // assuming it's an URL to a .x3d file
        this.x3dScene.loadWorldFile(this.url, finalizeWorld);
    };

    const finalizeWorld = () => {
      if (document.getElementById('webotsProgressMessage'))
        document.getElementById('webotsProgressMessage').innerHTML = 'Loading World...';
      if (typeof this.x3dScene !== 'undefined') {
        if (!this._isWebSocketProtocol) { // skip robot windows initialization
          if (this.animation != null)
            this.animation.init(loadFinalize);
          else
            loadFinalize();
          this.onresize();
          return;
        }
      }

      loadFinalize();
    };

    let loadFinalize = () => {
      if (typeof this.multimediaClient !== 'undefined')
        // finalize multimedia client and set toolbar buttons status
        this.multimediaClient.finalize();

      if (typeof this.onready === 'function')
        this.onready();

      if (this.runOnLoad && this.toolBar)
        this.toolBar.realTime();
    };

    if (this.broadcast)
      this.setTimeout(-1);
    this._isWebSocketProtocol = this.url.startsWith('ws://') || this.url.startsWith('wss://');

    if (mode === 'mjpeg') {
      this.url = url;
      this.multimediaClient = new MultimediaClient(this, this.view3D);
    } else if (typeof this.x3dScene === 'undefined') {
      this._x3dDiv = document.getElementById('view3d');
      if (this._x3dDiv === null || typeof this._x3dDiv === 'undefined') {
        this._x3dDiv = document.createElement('div');
        this._x3dDiv.id = 'view3d';
        this.view3D.appendChild(this._x3dDiv);
      }

      this._x3dDiv.className = 'webots3DView';
      this.x3dScene = new X3dScene(this._x3dDiv);
      this.x3dScene.init(texturePathPrefix);
      let param = document.createElement('param');
      param.name = 'showProgress';
      param.value = false;
      this.x3dScene.domElement.appendChild(param);
    } else {
      if (typeof this._x3dDiv !== 'undefined') {
        this.view3D.appendChild(this._x3dDiv);
        this.x3dScene.prefix = texturePathPrefix;
      }
      if (typeof this.progress !== 'undefined')
        this.view3D.appendChild(this.progress);
    }

    if (typeof this.x3dScene !== 'undefined' && typeof this.mouseEvents === 'undefined') {
      let canvas = document.getElementById('canvas');
      this.mouseEvents = new MouseEvents(this.x3dScene, canvas, this._mobileDevice);
    }

    initWorld();
  }

  close() {
    if (this.multimediaClient)
      this.multimediaClient.disconnect();
    if (this._server && this._server.socket)
      this._server.socket.close();
    if (this.stream)
      this.stream.close();
  }

  // Functions for internal use.

  updateWorldList(currentWorld, worlds) {
    if (!this.toolBar || this.broadcast)
      // Do not show world list if no toolbar exists or in broadcast mode,
      // where multiple users can connect to the same Webots instance.
      return;

    if (typeof this.toolBar.worldSelect !== 'undefined')
      this.toolBar.deleteWorldSelect();
    if (worlds.length <= 1)
      return;
    this.toolBar.createWorldSelect();
    for (let i in worlds) {
      const option = document.createElement('option');
      option.value = worlds[i];
      option.text = worlds[i];
      this.toolBar.worldSelect.appendChild(option);
      if (currentWorld === worlds[i])
        this.toolBar.worldSelect.selectedIndex = i;
    }
    this.toolBar.worldSelect.onchange = () => {
      if (this.broadcast || typeof this.toolBar.worldSelect === 'undefined')
        return;
      if (this.toolBar)
        this.toolBar.enableToolBarButtons(false);
      if (document.getElementById('webotsProgressMessage'))
        document.getElementById('webotsProgressMessage').innerHTML = 'Loading ' + this.toolBar.worldSelect.value + '...';
      if (document.getElementById('webotsProgress'))
        document.getElementById('webotsProgress').style.display = 'block';
      this.stream.socket.send('load:' + this.toolBar.worldSelect.value);
    };
  }

  setLabel(properties) {
    let labelElement = document.getElementById('label' + properties.id);
    if (labelElement == null) {
      labelElement = document.createElement('div');
      labelElement.id = 'label' + properties.id;
      labelElement.className = 'webots-label';
      this._x3dDiv.appendChild(labelElement);
    }

    let font = properties.font.split('/');
    font = font[font.length - 1].replace('.ttf', '');

    labelElement.style.fontFamily = font;
    labelElement.style.color = 'rgba(' + properties.color + ')';
    labelElement.style.fontSize = this._getHeight(this._x3dDiv) * properties.size / 2.25 + 'px'; // 2.25 is an empirical value to match with Webots appearance
    labelElement.style.left = this._getWidth(this._x3dDiv) * properties.x + 'px';
    labelElement.style.top = this._getHeight(this._x3dDiv) * properties.y + 'px';
    labelElement.x = properties.x;
    labelElement.y = properties.y;
    labelElement.size = properties.size;

    if (properties.text.includes('█'))
      properties.text = properties.text.replaceAll('█', '<span style="background:' + labelElement.style.color + '"> </span>');

    labelElement.innerHTML = properties.text;
  }

  removeLabels() {
    const labels = document.getElementsByClassName('webots-label');
    for (let i = labels.length - 1; i >= 0; i--) {
      const element = labels.item(i);
      element.parentNode.removeChild(element);
    }
  }

  resetSimulation() {
    if (document.getElementById('webotsProgress'))
      document.getElementById('webotsProgress').style.display = 'none';
    this.removeLabels();
    if (document.getElementById('webotsClock'))
      document.getElementById('webotsClock').innerHTML = webots.parseMillisecondsIntoReadableTime(0);
    this.deadline = this.timeout;
    if (document.getElementById('webotsTimeout')) {
      if (this.deadline >= 0)
        document.getElementById('webotsTimeout').innerHTML = webots.parseMillisecondsIntoReadableTime(this.deadline);
      else
        document.getElementById('webotsTimeout').innerHTML = webots.parseMillisecondsIntoReadableTime(0);
    }
  }

  quitSimulation() {
    if (this.broadcast)
      return;
    this.close();
    if (document.getElementById('webotsProgressMessage'))
      document.getElementById('webotsProgressMessage').innerHTML = 'Bye bye...';
    if (document.getElementById('webotsProgress'))
      document.getElementById('webotsProgress').style.display = 'block';
    setTimeout(() => {
      if (document.getElementById('webotsProgress'))
        document.getElementById('webotsProgress').style.display = 'none';
    }, 1000);
    this.quitting = true;
    this.onquit();
  }

  destroyWorld() {
    if (typeof this.x3dScene !== 'undefined')
      this.x3dScene.destroyWorld();
    this.removeLabels();

    if (typeof this.mouseEvents !== 'undefined' && typeof this.mouseEvents.picker !== 'undefined') {
      this.mouseEvents.picker.selectedId = -1;
      this.mouseEvents.picker.coordinates = new WbVector3();
      Selector.reset();
    }
  }

  _getHeight(el) {
    const s = window.getComputedStyle(el, null);
    return el.clientHeight - parseInt(s.getPropertyValue('padding-top')) - parseInt(s.getPropertyValue('padding-bottom'));
  }

  _getWidth(el) {
    const s = window.getComputedStyle(el, null);
    return el.clientWidth - parseInt(s.getPropertyValue('padding-right')) - parseInt(s.getPropertyValue('padding-left'));
  }
};

webots.parseMillisecondsIntoReadableTime = (milliseconds) => {
  const hours = (milliseconds + 0.9) / (1000 * 60 * 60);
  const absoluteHours = Math.floor(hours);
  const h = absoluteHours > 9 ? absoluteHours : '0' + absoluteHours;
  const minutes = (hours - absoluteHours) * 60;
  const absoluteMinutes = Math.floor(minutes);
  const m = absoluteMinutes > 9 ? absoluteMinutes : '0' + absoluteMinutes;
  const seconds = (minutes - absoluteMinutes) * 60;
  const absoluteSeconds = Math.floor(seconds);
  const s = absoluteSeconds > 9 ? absoluteSeconds : '0' + absoluteSeconds;
  let ms = Math.floor((seconds - absoluteSeconds) * 1000);
  if (ms < 10)
    ms = '00' + ms;
  else if (ms < 100)
    ms = '0' + ms;
  return h + ':' + m + ':' + s + ':' + ms;
};exports.webots=webots;Object.defineProperty(exports,'__esModule',{value:true});}));