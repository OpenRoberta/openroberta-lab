include: "classpath:/common.methods.yml"

HSVTORGB:
  PYTHON: |
    def hsv2rgb(color):
        h = float(color.h)
        s = float(color.s / 100.0)
        v = float(color.v / 100.0)
    
        c = v * s
        x = c * (1 - abs(((h/60.0) % 2) - 1))
        m = v - c

        if 0.0 <= h < 60:
            rgb = (c, x, 0)
        elif 0.0 <= h < 120:
            rgb = (x, c, 0)
        elif 0.0 <= h < 180:
            rgb = (0, c, x)
        elif 0.0 <= h < 240:
            rgb = (0, x, c)
        elif 0.0 <= h < 300:
            rgb = (x, 0, c)
        elif 0.0 <= h < 360:
            rgb = (c, 0, x)
    
        return list(map(lambda n: (n + m) * 255, rgb))  

TANKDRIVE_DIST:
  PYTHON: |
    def circle_circumference(diameter):
        return 3.14159265359 * (diameter)

    def distance_to_angle(distance):
        return (distance/circle_circumference(WHEEL_DIAMETER)) * 360
    
    def rpm_to_mm_sec(rpm):
        return (rpm/360) * circle_circumference(WHEEL_DIAMETER)
    
    def catch_edge_cases(dist, left_speed, right_speed):
        near_zero = 0.0001
        #don't do anything to avoid stalling program
        if((abs(left_speed) < near_zero and abs(right_speed) < near_zero) or abs(dist) < near_zero):
            return True
        #just go straight no need for calculations
        if abs(left_speed - right_speed) <  near_zero:
            drive_base.settings(straight_speed=get_speed_from_percent(left_speed))
            drive_base.straight(dist * 10)
            return True
        #in case velocities cancel dont move, because no distance will be driven
        if abs(left_speed+right_speed) < near_zero:
            return True
        return False
    
    def wait_for_completion():
        while not (left_motor.done() and right_motor.done()):
              pass
    
    def tank_drive_dist(dist, left_speed, right_speed):
        if catch_edge_cases(dist, left_speed, right_speed):
            return
        sign = abs(dist)/dist
        #to mm always calc with positive dist
        dist = (abs(dist) * 10)
        #we have to keep rpm to set motor speed later
        rpm_left = get_speed_from_percent(left_speed)
        rpm_right = get_speed_from_percent(right_speed)
        #we need mm/sec to calculate driven radius
        speed_left_mm_sec =  rpm_to_mm_sec(rpm_left)
        speed_right_mm_sec = rpm_to_mm_sec(rpm_right)
        
        #we need this distinction because inner/outer circle change depending on which motor is faster
        if (abs(rpm_right) > abs(rpm_left)):
            drives_radius = (TRACKWIDTH/2.0) * ((speed_left_mm_sec+speed_right_mm_sec)/(speed_right_mm_sec-speed_left_mm_sec))
            left_circle = circle_circumference(drives_radius - (TRACKWIDTH/2))
            right_circle = circle_circumference(drives_radius + (TRACKWIDTH/2))
        else:
            drives_radius = (TRACKWIDTH/2.0) * ((speed_left_mm_sec+speed_right_mm_sec)/(speed_left_mm_sec-speed_right_mm_sec))
            left_circle = circle_circumference(drives_radius + (TRACKWIDTH/2))
            right_circle = circle_circumference(drives_radius - (TRACKWIDTH/2))
        
        percent_to_drive = (dist / circle_circumference(drives_radius))
        angle_left = distance_to_angle(percent_to_drive * left_circle)
        angle_right = distance_to_angle(percent_to_drive * right_circle)
        
        left_motor.run_angle(abs(rpm_left), sign * angle_left , wait=False)
        right_motor.run_angle(abs(rpm_right), sign * angle_right, wait=False)
        
        wait_for_completion()

DIFFDRIVE:
  PYTHON: |
    def diff_drive(left_speed, right_speed, regulated):
        if(regulated):
            left_motor.run(get_speed_from_percent(left_speed))
            right_motor.run(get_speed_from_percent(right_speed))
        else:
            left_motor.dc(left_speed)
            right_motor.dc(right_speed)

SPEED_FROM_PERCENT:
  PYTHON: |
    def get_speed_from_percent(percent):
        max_deg_s = 810.0
        return int(max_deg_s * (percent/100.0))

GESTURES:
  PYTHON: |
    def get_acceleration():
        return sqrt((abs(hub.imu.acceleration()[0])**2) + (abs(hub.imu.acceleration()[1])**2) + (abs(hub.imu.acceleration()[2])**2))

    def is_free_fall():
        threshold = 350
        stopWatch.time()
        start = stopWatch.time()
        while start - stopWatch.time() < 333:
            if(get_acceleration() < threshold): 
                return True;
        return False

    def is_tapped():
        threshold = 3500
        val = 0.0
        prev_val = get_acceleration()
        start = stopWatch.time()
        while start - stopWatch.time() < 333:
            val = get_acceleration()
            if abs(val - prev_val) > threshold:
                return True
        return False

    def is_shaken():
        count_tapped = 0
        tapped = True
        while tapped := is_tapped():
            if tapped:
                count_tapped += 1
                wait(200)
            if count_tapped >= 3:
                return True
        return False
