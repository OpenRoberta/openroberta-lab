/*
 * This is a class GENERATED by the TransportGenerator maven plugin. DON'T MODIFY IT.
 * IF you modify it, your work may be lost: the class will be overwritten automatically
 * when the maven plugin is re-executed for any reasons.
 */
package de.fhg.iais.roberta.generated.restEntities;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * full request for the /init REST request with logging and request data, but no initToken<br><br>
 * Version: 1<br>
 * Datum: 2020-06-15
 */
public class InitRequest {
    protected boolean immutable = false;
    protected List<String> log;
    protected JSONObject data;
    
    /**
     * full request for the /init REST request with logging and request data, but no initToken
     */
    public static InitRequest make() {
        return new InitRequest();
    }
    
    /**
     * full request for the /init REST request with logging and request data, but no initToken
     */
    public static InitRequest makeFromString(String jsonS) {
        try {
            JSONObject jsonO = new JSONObject(jsonS);
            return make(jsonO);
        } catch (JSONException e) {
            throw new RuntimeException("JSON parse error when parsing: " + jsonS, e);
        }
    }
    
    /**
     * full request for the /init REST request with logging and request data, but no initToken
     */
    public static InitRequest makeFromProperties(List<String> log,JSONObject data) {
        InitRequest entity = new InitRequest();
        entity.setLog(log);
        entity.setData(data);
        entity.immutable();
        return entity;
    }
    
    /**
     * full request for the /init REST request with logging and request data, but no initToken
     */
    public static InitRequest make(JSONObject jsonO) {
        return make().merge(jsonO).immutable();
    }
    
    /**
     * merge the properties of a JSON-object into this bean. The bean must be "under construction".
     * The keys of the JSON-Object must be valid. The bean remains "under construction".<br>
     * Throws a runtime exception if inconsistencies are detected.
     */
    public InitRequest merge(JSONObject jsonO) {
        try {
            for (String key : JSONObject.getNames(jsonO)) {
                if ("_version".equals(key)) {
                } else if ("log".equals(key)) {
                    JSONArray array = jsonO.optJSONArray(key);
                    if (array != null && array.length() > 0) {
                        for (int i = 0; i < array.length(); i++) {
                            addLog(array.getString(i));
                        }
                    } else {
                        setLog(new ArrayList<String>());
                    }
                } else if ("data".equals(key)) {
                    setData(jsonO.getJSONObject(key));
                } else {
                    throw new RuntimeException("JSON parse error. Found invalid key: " + key + " in " + jsonO);
                }
            }
            return this;
        } catch (Exception e) {
            throw new RuntimeException("JSON parse / casting error when parsing: " + jsonO, e);
        }
    }
    
    /**
     * moves a bean from state "under construction" to state "immutable".<br>
     * Checks whether all required fields are set. All lists are made immutable.<br>
     * Throws a runtime exception if inconsistencies are detected.
     */
    public InitRequest immutable() {
        if (this.immutable) {
            return this;
        }
        this.immutable = true;
        this.log = (this.log != null) ? Collections.unmodifiableList(this.log) : null;
        return validate();
    }
    
    /**
     * Checks whether all required fields are set.<br>
     * Throws a runtime exception if inconsistencies are detected.
     */
    private InitRequest validate() {
        String _message = null;
        if ( !this.immutable ) {
            _message = "InitRequest-object is already immutable: " + toString();
        }
        if ( log == null) {
            _message = "required property log of InitRequest-object is not set: " + toString();
        }
        if ( data == null) {
            _message = "required property data of InitRequest-object is not set: " + toString();
        }
        if ( _message != null ) {
            this.immutable = false;
            throw new RuntimeException(_message);
        }
        return this;
    }
    
    /**
     * GET log. Object must be immutable. Never return null or an undefined/default value.
     */
    public List<String> getLog() {
        if (!this.immutable) {
            throw new RuntimeException("no log from an object under construction: " + toString());
        }
        return this.log;
    }
    
    /**
     * SET log. Object must be mutable.
     */
    public InitRequest setLog(List<String> log) {
        if (this.immutable) {
            throw new RuntimeException("log assigned to an immutable object: " + toString());
        }
        if ( this.log == null ) {
            this.log = new ArrayList<String>();
        }
        this.log.addAll(log);
        return this;
    }
    
    /**
     * ADD log. Object must be mutable.
     */
    public InitRequest addLog(String log) {
        if (this.immutable) {
            throw new RuntimeException("log assigned to an immutable object: " + toString());
        }
        if ( this.log == null ) {
            this.log = new ArrayList<String>();
        }
        this.log.add(log);
        return this;
    }
    
    /**
     * ADD ALL log. Object must be mutable.
     */
    public InitRequest addAllLog(List<String> log) {
        if (this.immutable) {
            throw new RuntimeException("log assigned to an immutable object: " + toString());
        }
        if ( this.log == null ) {
            this.log = new ArrayList<String>();
        }
        this.log.addAll(log);
        return this;
    }
    
    /**
     * GET data. Object must be immutable. Never return null or an undefined/default value.
     */
    public JSONObject getData() {
        if (!this.immutable) {
            throw new RuntimeException("no data from an object under construction: " + toString());
        }
        return this.data;
    }
    
    /**
     * SET data. Object must be mutable.
     */
    public InitRequest setData(JSONObject data) {
        if (this.immutable) {
            throw new RuntimeException("data assigned to an immutable object: " + toString());
        }
        this.data = data;
        return this;
    }
    
    /**
     * generates a JSON-object from an immutable bean.<br>
     * Throws a runtime exception if inconsistencies are detected.
     */
    public JSONObject toJson() {
        if (!this.immutable) {
            throw new RuntimeException("no JSON from an object under construction: " + toString());
        }
        JSONObject jsonO = new JSONObject();
        try {
            jsonO.put("_version", "1");
            {
                JSONArray array = new JSONArray();
                for (String item : this.log) {
                    array.put(item);
                }
                jsonO.put("log", array);
            }
            jsonO.put("data", this.data);
        } catch (JSONException e) {
            throw new RuntimeException("JSON unparse error when unparsing: " + this, e);
        }
        return jsonO;
    }
    
    @Override
    public String toString() {
        return "InitRequest [immutable=" + this.immutable + ", log=" + this.log + ", data=" + this.data + " ]";
    }
    @Override
    public int hashCode() {
        throw new RuntimeException("no hashCode from transport beans!");
    }
    
    @Override
    public boolean equals(Object obj) {
        throw new RuntimeException("no equals from transport beans!");
    }
    
}
